/* soapStub.h
   Generated by gSOAP 2.8.16 from ServerAPI.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#define SOAP_NAMESPACE_OF_ns1	"http://impl.service.wfe.runa.ru/"
#define SOAP_NAMESPACE_OF_ns2	"http://stub.service.wfe.runa.ru/"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20816
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns1__classPresentationType
#define SOAP_TYPE_ns1__classPresentationType (63)
/* ns1:classPresentationType */
enum ns1__classPresentationType { ns1__classPresentationType__NONE = 0, ns1__classPresentationType__SYSTEM_USCORELOG = 1, ns1__classPresentationType__EXECUTOR = 2, ns1__classPresentationType__ACTOR = 3, ns1__classPresentationType__GROUP = 4, ns1__classPresentationType__RELATION = 5, ns1__classPresentationType__RELATIONPAIR = 6, ns1__classPresentationType__DEFINITION = 7, ns1__classPresentationType__DEFINITION_USCOREHISTORY = 8, ns1__classPresentationType__PROCESS = 9, ns1__classPresentationType__TASK = 10, ns1__classPresentationType__REPORTS = 11 };
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (7)
/* Primitive xsd:anyType schema type: */
class SOAP_CMAC xsd__anyType
{
public:
	char *__item;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 7; } /* = unique id SOAP_TYPE_xsd__anyType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__anyType() { xsd__anyType::soap_default(NULL); }
	virtual ~xsd__anyType() { }
};
#endif

#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (9)
/* Base64 schema type: */
class SOAP_CMAC xsd__base64Binary
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of type xsd:string */
	char *type;	/* optional element of type xsd:string */
	char *options;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 9; } /* = unique id SOAP_TYPE_xsd__base64Binary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__base64Binary() { xsd__base64Binary::soap_default(NULL); }
	virtual ~xsd__base64Binary() { }
};
#endif

#ifndef SOAP_TYPE_xsd__base64Binary_
#define SOAP_TYPE_xsd__base64Binary_ (13)
/* Primitive xsd:base64Binary schema type: */
class SOAP_CMAC xsd__base64Binary_ : public xsd__anyType
{
public:
	xsd__base64Binary __item;
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE_xsd__base64Binary_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__base64Binary_() { xsd__base64Binary_::soap_default(NULL); }
	virtual ~xsd__base64Binary_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (14)
/* Primitive xsd:boolean schema type: */
class SOAP_CMAC xsd__boolean : public xsd__anyType
{
public:
	bool __item;
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_xsd__boolean */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__boolean() { xsd__boolean::soap_default(NULL); }
	virtual ~xsd__boolean() { }
};
#endif

#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (16)
/* Primitive xsd:dateTime schema type: */
class SOAP_CMAC xsd__dateTime : public xsd__anyType
{
public:
	time_t __item;
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_xsd__dateTime */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__dateTime() { xsd__dateTime::soap_default(NULL); }
	virtual ~xsd__dateTime() { }
};
#endif

#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (18)
/* Primitive xsd:int schema type: */
class SOAP_CMAC xsd__int : public xsd__anyType
{
public:
	int __item;
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_xsd__int */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__int() { xsd__int::soap_default(NULL); }
	virtual ~xsd__int() { }
};
#endif

#ifndef SOAP_TYPE_xsd__long
#define SOAP_TYPE_xsd__long (19)
/* Primitive xsd:long schema type: */
class SOAP_CMAC xsd__long : public xsd__anyType
{
public:
	LONG64 __item;
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_xsd__long */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__long() { xsd__long::soap_default(NULL); }
	virtual ~xsd__long() { }
};
#endif

#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (21)
/* Primitive xsd:string schema type: */
class SOAP_CMAC xsd__string : public xsd__anyType
{
public:
	wchar_t *__item;
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_xsd__string */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__string() { xsd__string::soap_default(NULL); }
	virtual ~xsd__string() { }
};
#endif

#ifndef SOAP_TYPE_ns1__classPresentationType_
#define SOAP_TYPE_ns1__classPresentationType_ (64)
/* Primitive ns1:classPresentationType schema type: */
class SOAP_CMAC ns1__classPresentationType_ : public xsd__anyType
{
public:
	enum ns1__classPresentationType __item;
public:
	virtual int soap_type() const { return 64; } /* = unique id SOAP_TYPE_ns1__classPresentationType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__classPresentationType_() { ns1__classPresentationType_::soap_default(NULL); }
	virtual ~ns1__classPresentationType_() { }
};
#endif

#ifndef SOAP_TYPE_ns1__authenticateByKerberos
#define SOAP_TYPE_ns1__authenticateByKerberos (24)
/* ns1:authenticateByKerberos */
class SOAP_CMAC ns1__authenticateByKerberos : public xsd__anyType
{
public:
	xsd__base64Binary *token;	/* optional element of type xsd:base64Binary */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_ns1__authenticateByKerberos */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__authenticateByKerberos() { ns1__authenticateByKerberos::soap_default(NULL); }
	virtual ~ns1__authenticateByKerberos() { }
};
#endif

#ifndef SOAP_TYPE_ns1__authenticateByKerberosResponse
#define SOAP_TYPE_ns1__authenticateByKerberosResponse (25)
/* ns1:authenticateByKerberosResponse */
class SOAP_CMAC ns1__authenticateByKerberosResponse : public xsd__anyType
{
public:
	class ns1__user *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:user */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_ns1__authenticateByKerberosResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__authenticateByKerberosResponse() { ns1__authenticateByKerberosResponse::soap_default(NULL); }
	virtual ~ns1__authenticateByKerberosResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__user
#define SOAP_TYPE_ns1__user (26)
/* ns1:user */
class SOAP_CMAC ns1__user : public xsd__anyType
{
public:
	class ns1__actor *actor;	/* optional element of type ns1:actor */
	xsd__base64Binary *securedKey;	/* optional element of type xsd:base64Binary */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_ns1__user */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__user() { ns1__user::soap_default(NULL); }
	virtual ~ns1__user() { }
};
#endif

#ifndef SOAP_TYPE_ns1__identifiable
#define SOAP_TYPE_ns1__identifiable (30)
/* Primitive ns1:identifiable schema type: */
class SOAP_CMAC ns1__identifiable : public xsd__anyType
{
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_ns1__identifiable */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__identifiable() { ns1__identifiable::soap_default(NULL); }
	virtual ~ns1__identifiable() { }
};
#endif

#ifndef SOAP_TYPE_ns1__authenticateByLoginPassword
#define SOAP_TYPE_ns1__authenticateByLoginPassword (32)
/* ns1:authenticateByLoginPassword */
class SOAP_CMAC ns1__authenticateByLoginPassword : public xsd__anyType
{
public:
	wchar_t *name;	/* optional element of type xsd:string */
	wchar_t *password;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_ns1__authenticateByLoginPassword */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__authenticateByLoginPassword() { ns1__authenticateByLoginPassword::soap_default(NULL); }
	virtual ~ns1__authenticateByLoginPassword() { }
};
#endif

#ifndef SOAP_TYPE_ns1__authenticateByLoginPasswordResponse
#define SOAP_TYPE_ns1__authenticateByLoginPasswordResponse (33)
/* ns1:authenticateByLoginPasswordResponse */
class SOAP_CMAC ns1__authenticateByLoginPasswordResponse : public xsd__anyType
{
public:
	ns1__user *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:user */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_ns1__authenticateByLoginPasswordResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__authenticateByLoginPasswordResponse() { ns1__authenticateByLoginPasswordResponse::soap_default(NULL); }
	virtual ~ns1__authenticateByLoginPasswordResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__authenticateByTrustedPrincipal
#define SOAP_TYPE_ns1__authenticateByTrustedPrincipal (34)
/* ns1:authenticateByTrustedPrincipal */
class SOAP_CMAC ns1__authenticateByTrustedPrincipal : public xsd__anyType
{
public:
	ns1__user *serviceUser;	/* optional element of type ns1:user */
	wchar_t *login;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_ns1__authenticateByTrustedPrincipal */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__authenticateByTrustedPrincipal() { ns1__authenticateByTrustedPrincipal::soap_default(NULL); }
	virtual ~ns1__authenticateByTrustedPrincipal() { }
};
#endif

#ifndef SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse
#define SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse (35)
/* ns1:authenticateByTrustedPrincipalResponse */
class SOAP_CMAC ns1__authenticateByTrustedPrincipalResponse : public xsd__anyType
{
public:
	ns1__user *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:user */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__authenticateByTrustedPrincipalResponse() { ns1__authenticateByTrustedPrincipalResponse::soap_default(NULL); }
	virtual ~ns1__authenticateByTrustedPrincipalResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__authenticateByCallerPrincipal
#define SOAP_TYPE_ns1__authenticateByCallerPrincipal (36)
/* Primitive ns1:authenticateByCallerPrincipal schema type: */
class SOAP_CMAC ns1__authenticateByCallerPrincipal : public xsd__anyType
{
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_ns1__authenticateByCallerPrincipal */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__authenticateByCallerPrincipal() { ns1__authenticateByCallerPrincipal::soap_default(NULL); }
	virtual ~ns1__authenticateByCallerPrincipal() { }
};
#endif

#ifndef SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse
#define SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse (37)
/* ns1:authenticateByCallerPrincipalResponse */
class SOAP_CMAC ns1__authenticateByCallerPrincipalResponse : public xsd__anyType
{
public:
	ns1__user *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:user */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__authenticateByCallerPrincipalResponse() { ns1__authenticateByCallerPrincipalResponse::soap_default(NULL); }
	virtual ~ns1__authenticateByCallerPrincipalResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getMyTasks
#define SOAP_TYPE_ns1__getMyTasks (38)
/* ns1:getMyTasks */
class SOAP_CMAC ns1__getMyTasks : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	class ns1__batchPresentation *batchPresentation;	/* optional element of type ns1:batchPresentation */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_ns1__getMyTasks */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getMyTasks() { ns1__getMyTasks::soap_default(NULL); }
	virtual ~ns1__getMyTasks() { }
};
#endif

#ifndef SOAP_TYPE_ns1__batchPresentation
#define SOAP_TYPE_ns1__batchPresentation (39)
/* ns1:batchPresentation */
class SOAP_CMAC ns1__batchPresentation : public xsd__anyType
{
public:
	LONG64 *id;	/* optional element of type xsd:long */
	LONG64 *version;	/* optional element of type xsd:long */
	enum ns1__classPresentationType *type;	/* optional element of type ns1:classPresentationType */
	wchar_t *category;	/* optional element of type xsd:string */
	wchar_t *name;	/* optional element of type xsd:string */
	bool active;	/* required element of type xsd:boolean */
	int rangeSize;	/* required element of type xsd:int */
	int pageNumber;	/* required element of type xsd:int */
	xsd__base64Binary *fieldsData;	/* optional element of type xsd:base64Binary */
	time_t *createDate;	/* optional element of type xsd:dateTime */
	bool shared;	/* required element of type xsd:boolean */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_ns1__batchPresentation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__batchPresentation() { ns1__batchPresentation::soap_default(NULL); }
	virtual ~ns1__batchPresentation() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getMyTasksResponse
#define SOAP_TYPE_ns1__getMyTasksResponse (40)
/* ns1:getMyTasksResponse */
class SOAP_CMAC ns1__getMyTasksResponse : public xsd__anyType
{
public:
	int __sizeresult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <result> */
	class ns1__wfTask **result;	/* optional element of type ns1:wfTask */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_ns1__getMyTasksResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getMyTasksResponse() { ns1__getMyTasksResponse::soap_default(NULL); }
	virtual ~ns1__getMyTasksResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__wfTask
#define SOAP_TYPE_ns1__wfTask (41)
/* ns1:wfTask */
class SOAP_CMAC ns1__wfTask : public xsd__anyType
{
public:
	LONG64 *id;	/* optional element of type xsd:long */
	wchar_t *name;	/* optional element of type xsd:string */
	wchar_t *nodeId;	/* optional element of type xsd:string */
	wchar_t *description;	/* optional element of type xsd:string */
	wchar_t *swimlaneName;	/* optional element of type xsd:string */
	class ns1__wfExecutor *owner;	/* optional element of type ns1:wfExecutor */
	ns1__actor *targetActor;	/* optional element of type ns1:actor */
	LONG64 *definitionId;	/* optional element of type xsd:long */
	wchar_t *definitionName;	/* optional element of type xsd:string */
	LONG64 *processId;	/* optional element of type xsd:long */
	wchar_t *processHierarchyIds;	/* optional element of type xsd:string */
	time_t *creationDate;	/* optional element of type xsd:dateTime */
	time_t *deadlineDate;	/* optional element of type xsd:dateTime */
	time_t *deadlineWarningDate;	/* optional element of type xsd:dateTime */
	bool escalated;	/* required element of type xsd:boolean */
	bool firstOpen;	/* required element of type xsd:boolean */
	bool acquiredBySubstitution;	/* required element of type xsd:boolean */
	int *multitaskIndex;	/* optional element of type xsd:int */
	int __sizevariables;	/* sequence of elements <variables> */
	class ns2__wfVariableStub **variables;	/* optional element of type ns2:wfVariableStub */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_ns1__wfTask */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__wfTask() { ns1__wfTask::soap_default(NULL); }
	virtual ~ns1__wfTask() { }
};
#endif

#ifndef SOAP_TYPE_ns1__variableDefinition
#define SOAP_TYPE_ns1__variableDefinition (42)
/* ns1:variableDefinition */
class SOAP_CMAC ns1__variableDefinition : public xsd__anyType
{
public:
	bool synthetic;	/* required element of type xsd:boolean */
	wchar_t *name;	/* optional element of type xsd:string */
	wchar_t *scriptingName;	/* optional element of type xsd:string */
	wchar_t *description;	/* optional element of type xsd:string */
	wchar_t *format;	/* optional element of type xsd:string */
	wchar_t *formatLabel;	/* optional element of type xsd:string */
	class ns1__userType *userType;	/* optional element of type ns1:userType */
	int __sizeformatComponentUserTypes;	/* sequence of elements <formatComponentUserTypes> */
	ns1__userType **formatComponentUserTypes;	/* optional element of type ns1:userType */
	bool publicAccess;	/* required element of type xsd:boolean */
	xsd__anyType *defaultValue;	/* optional element of type xsd:anyType */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE_ns1__variableDefinition */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__variableDefinition() { ns1__variableDefinition::soap_default(NULL); }
	virtual ~ns1__variableDefinition() { }
};
#endif

#ifndef SOAP_TYPE__ns1__userType_attributesMap_entry
#define SOAP_TYPE__ns1__userType_attributesMap_entry (84)
/* ns1:userType-attributesMap-entry */
class SOAP_CMAC _ns1__userType_attributesMap_entry
{
public:
	wchar_t *key;	/* optional element of type xsd:string */
	ns1__variableDefinition *value;	/* optional element of type ns1:variableDefinition */
public:
	virtual int soap_type() const { return 84; } /* = unique id SOAP_TYPE__ns1__userType_attributesMap_entry */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__userType_attributesMap_entry() { _ns1__userType_attributesMap_entry::soap_default(NULL); }
	virtual ~_ns1__userType_attributesMap_entry() { }
};
#endif

#ifndef SOAP_TYPE__ns1__userType_attributesMap
#define SOAP_TYPE__ns1__userType_attributesMap (83)
/* ns1:userType-attributesMap */
class SOAP_CMAC _ns1__userType_attributesMap
{
public:
	int __sizeentry;	/* sequence of elements <entry> */
	_ns1__userType_attributesMap_entry *entry;	/* optional element of type ns1:userType-attributesMap-entry */
public:
	virtual int soap_type() const { return 83; } /* = unique id SOAP_TYPE__ns1__userType_attributesMap */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__userType_attributesMap() { _ns1__userType_attributesMap::soap_default(NULL); }
	virtual ~_ns1__userType_attributesMap() { }
};
#endif

#ifndef SOAP_TYPE_ns1__userType
#define SOAP_TYPE_ns1__userType (43)
/* ns1:userType */
class SOAP_CMAC ns1__userType : public xsd__anyType
{
public:
	wchar_t *name;	/* optional element of type xsd:string */
	int __sizeattributes;	/* sequence of elements <attributes> */
	ns1__variableDefinition **attributes;	/* optional element of type ns1:variableDefinition */
	_ns1__userType_attributesMap attributesMap;	/* required element of type ns1:userType-attributesMap */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE_ns1__userType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__userType() { ns1__userType::soap_default(NULL); }
	virtual ~ns1__userType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__variableFormat
#define SOAP_TYPE_ns1__variableFormat (44)
/* Primitive ns1:variableFormat schema type: */
class SOAP_CMAC ns1__variableFormat : public xsd__anyType
{
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE_ns1__variableFormat */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__variableFormat() { ns1__variableFormat::soap_default(NULL); }
	virtual ~ns1__variableFormat() { }
};
#endif

#ifndef SOAP_TYPE_ns1__markTaskOpened
#define SOAP_TYPE_ns1__markTaskOpened (45)
/* ns1:markTaskOpened */
class SOAP_CMAC ns1__markTaskOpened : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *taskId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE_ns1__markTaskOpened */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__markTaskOpened() { ns1__markTaskOpened::soap_default(NULL); }
	virtual ~ns1__markTaskOpened() { }
};
#endif

#ifndef SOAP_TYPE_ns1__markTaskOpenedResponse
#define SOAP_TYPE_ns1__markTaskOpenedResponse (46)
/* Primitive ns1:markTaskOpenedResponse schema type: */
class SOAP_CMAC ns1__markTaskOpenedResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE_ns1__markTaskOpenedResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__markTaskOpenedResponse() { ns1__markTaskOpenedResponse::soap_default(NULL); }
	virtual ~ns1__markTaskOpenedResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__reassignTask
#define SOAP_TYPE_ns1__reassignTask (47)
/* ns1:reassignTask */
class SOAP_CMAC ns1__reassignTask : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *batchPresentation;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE_ns1__reassignTask */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__reassignTask() { ns1__reassignTask::soap_default(NULL); }
	virtual ~ns1__reassignTask() { }
};
#endif

#ifndef SOAP_TYPE_ns1__reassignTaskResponse
#define SOAP_TYPE_ns1__reassignTaskResponse (48)
/* Primitive ns1:reassignTaskResponse schema type: */
class SOAP_CMAC ns1__reassignTaskResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE_ns1__reassignTaskResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__reassignTaskResponse() { ns1__reassignTaskResponse::soap_default(NULL); }
	virtual ~ns1__reassignTaskResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__reassignTasks
#define SOAP_TYPE_ns1__reassignTasks (49)
/* ns1:reassignTasks */
class SOAP_CMAC ns1__reassignTasks : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	ns1__batchPresentation *batchPresentation;	/* optional element of type ns1:batchPresentation */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE_ns1__reassignTasks */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__reassignTasks() { ns1__reassignTasks::soap_default(NULL); }
	virtual ~ns1__reassignTasks() { }
};
#endif

#ifndef SOAP_TYPE_ns1__reassignTasksResponse
#define SOAP_TYPE_ns1__reassignTasksResponse (50)
/* ns1:reassignTasksResponse */
class SOAP_CMAC ns1__reassignTasksResponse : public xsd__anyType
{
public:
	int result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE_ns1__reassignTasksResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__reassignTasksResponse() { ns1__reassignTasksResponse::soap_default(NULL); }
	virtual ~ns1__reassignTasksResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getTasks
#define SOAP_TYPE_ns1__getTasks (51)
/* ns1:getTasks */
class SOAP_CMAC ns1__getTasks : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	ns1__batchPresentation *batchPresentation;	/* optional element of type ns1:batchPresentation */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE_ns1__getTasks */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getTasks() { ns1__getTasks::soap_default(NULL); }
	virtual ~ns1__getTasks() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getTasksResponse
#define SOAP_TYPE_ns1__getTasksResponse (52)
/* ns1:getTasksResponse */
class SOAP_CMAC ns1__getTasksResponse : public xsd__anyType
{
public:
	int __sizeresult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <result> */
	ns1__wfTask **result;	/* optional element of type ns1:wfTask */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE_ns1__getTasksResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getTasksResponse() { ns1__getTasksResponse::soap_default(NULL); }
	virtual ~ns1__getTasksResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__completeTaskWS
#define SOAP_TYPE_ns1__completeTaskWS (53)
/* ns1:completeTaskWS */
class SOAP_CMAC ns1__completeTaskWS : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *taskId;	/* optional element of type xsd:long */
	int __sizevariables;	/* sequence of elements <variables> */
	class ns1__variable **variables;	/* optional element of type ns1:variable */
	LONG64 *swimlaneActorId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE_ns1__completeTaskWS */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__completeTaskWS() { ns1__completeTaskWS::soap_default(NULL); }
	virtual ~ns1__completeTaskWS() { }
};
#endif

#ifndef SOAP_TYPE_ns1__variable
#define SOAP_TYPE_ns1__variable (54)
/* ns1:variable */
class SOAP_CMAC ns1__variable : public xsd__anyType
{
public:
	wchar_t *name;	/* optional element of type xsd:string */
	wchar_t *scriptingName;	/* optional element of type xsd:string */
	wchar_t *format;	/* optional element of type xsd:string */
	wchar_t *value;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE_ns1__variable */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__variable() { ns1__variable::soap_default(NULL); }
	virtual ~ns1__variable() { }
};
#endif

#ifndef SOAP_TYPE_ns1__completeTaskWSResponse
#define SOAP_TYPE_ns1__completeTaskWSResponse (55)
/* Primitive ns1:completeTaskWSResponse schema type: */
class SOAP_CMAC ns1__completeTaskWSResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE_ns1__completeTaskWSResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__completeTaskWSResponse() { ns1__completeTaskWSResponse::soap_default(NULL); }
	virtual ~ns1__completeTaskWSResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getProcessTasks
#define SOAP_TYPE_ns1__getProcessTasks (56)
/* ns1:getProcessTasks */
class SOAP_CMAC ns1__getProcessTasks : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *processId;	/* optional element of type xsd:long */
	bool includeSubprocesses;	/* required element of type xsd:boolean */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE_ns1__getProcessTasks */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getProcessTasks() { ns1__getProcessTasks::soap_default(NULL); }
	virtual ~ns1__getProcessTasks() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getProcessTasksResponse
#define SOAP_TYPE_ns1__getProcessTasksResponse (57)
/* ns1:getProcessTasksResponse */
class SOAP_CMAC ns1__getProcessTasksResponse : public xsd__anyType
{
public:
	int __sizeresult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* sequence of elements <result> */
	ns1__wfTask **result;	/* optional element of type ns1:wfTask */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE_ns1__getProcessTasksResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getProcessTasksResponse() { ns1__getProcessTasksResponse::soap_default(NULL); }
	virtual ~ns1__getProcessTasksResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getTask
#define SOAP_TYPE_ns1__getTask (58)
/* ns1:getTask */
class SOAP_CMAC ns1__getTask : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *taskId;	/* optional element of type xsd:long */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE_ns1__getTask */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getTask() { ns1__getTask::soap_default(NULL); }
	virtual ~ns1__getTask() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getTaskResponse
#define SOAP_TYPE_ns1__getTaskResponse (59)
/* ns1:getTaskResponse */
class SOAP_CMAC ns1__getTaskResponse : public xsd__anyType
{
public:
	ns1__wfTask *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:wfTask */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE_ns1__getTaskResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getTaskResponse() { ns1__getTaskResponse::soap_default(NULL); }
	virtual ~ns1__getTaskResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__assignTask
#define SOAP_TYPE_ns1__assignTask (60)
/* ns1:assignTask */
class SOAP_CMAC ns1__assignTask : public xsd__anyType
{
public:
	ns1__user *user;	/* optional element of type ns1:user */
	LONG64 *taskId;	/* optional element of type xsd:long */
	ns1__wfExecutor *previousOwner;	/* optional element of type ns1:wfExecutor */
	ns1__wfExecutor *newExecutor;	/* optional element of type ns1:wfExecutor */
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE_ns1__assignTask */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__assignTask() { ns1__assignTask::soap_default(NULL); }
	virtual ~ns1__assignTask() { }
};
#endif

#ifndef SOAP_TYPE_ns1__assignTaskResponse
#define SOAP_TYPE_ns1__assignTaskResponse (61)
/* Primitive ns1:assignTaskResponse schema type: */
class SOAP_CMAC ns1__assignTaskResponse : public xsd__anyType
{
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE_ns1__assignTaskResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__assignTaskResponse() { ns1__assignTaskResponse::soap_default(NULL); }
	virtual ~ns1__assignTaskResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns2__wfVariableStub
#define SOAP_TYPE_ns2__wfVariableStub (62)
/* ns2:wfVariableStub */
class SOAP_CMAC ns2__wfVariableStub : public xsd__anyType
{
public:
	ns1__variableDefinition *definition;	/* optional element of type ns1:variableDefinition */
	xsd__anyType *value;	/* optional element of type xsd:anyType */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE_ns2__wfVariableStub */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__wfVariableStub() { ns2__wfVariableStub::soap_default(NULL); }
	virtual ~ns2__wfVariableStub() { }
};
#endif

#ifndef SOAP_TYPE_ns1__identifiableBase
#define SOAP_TYPE_ns1__identifiableBase (29)
/* Primitive ns1:identifiableBase schema type: */
class SOAP_CMAC ns1__identifiableBase : public ns1__identifiable
{
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_ns1__identifiableBase */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__identifiableBase() { ns1__identifiableBase::soap_default(NULL); }
	virtual ~ns1__identifiableBase() { }
};
#endif

#ifndef SOAP_TYPE_ns1__executor
#define SOAP_TYPE_ns1__executor (28)
/* ns1:executor */
class SOAP_CMAC ns1__executor : public ns1__identifiableBase
{
public:
	LONG64 *id;	/* optional element of type xsd:long */
	LONG64 *version;	/* optional element of type xsd:long */
	wchar_t *name;	/* optional element of type xsd:string */
	wchar_t *description;	/* optional element of type xsd:string */
	wchar_t *fullName;	/* optional element of type xsd:string */
	time_t *createDate;	/* optional element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_ns1__executor */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__executor() { ns1__executor::soap_default(NULL); }
	virtual ~ns1__executor() { }
};
#endif

#ifndef SOAP_TYPE_ns1__actor
#define SOAP_TYPE_ns1__actor (27)
/* ns1:actor */
class SOAP_CMAC ns1__actor : public ns1__executor
{
public:
	LONG64 *code;	/* optional element of type xsd:long */
	bool active;	/* required element of type xsd:boolean */
	wchar_t *email;	/* optional element of type xsd:string */
	wchar_t *phone;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_ns1__actor */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__actor() { ns1__actor::soap_default(NULL); }
	virtual ~ns1__actor() { }
};
#endif

#ifndef SOAP_TYPE_ns1__wfExecutor
#define SOAP_TYPE_ns1__wfExecutor (31)
/* ns1:wfExecutor */
class SOAP_CMAC ns1__wfExecutor : public ns1__executor
{
public:
	wchar_t *executorClassName;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_ns1__wfExecutor */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__wfExecutor() { ns1__wfExecutor::soap_default(NULL); }
	virtual ~ns1__wfExecutor() { }
};
#endif

#ifndef SOAP_TYPE___ns1__authenticateByKerberos
#define SOAP_TYPE___ns1__authenticateByKerberos (91)
/* Operation wrapper: */
struct __ns1__authenticateByKerberos
{
public:
	ns1__authenticateByKerberos *ns1__authenticateByKerberos_;	/* optional element of type ns1:authenticateByKerberos */
public:
	int soap_type() const { return 91; } /* = unique id SOAP_TYPE___ns1__authenticateByKerberos */
};
#endif

#ifndef SOAP_TYPE___ns1__authenticateByLoginPassword
#define SOAP_TYPE___ns1__authenticateByLoginPassword (95)
/* Operation wrapper: */
struct __ns1__authenticateByLoginPassword
{
public:
	ns1__authenticateByLoginPassword *ns1__authenticateByLoginPassword_;	/* optional element of type ns1:authenticateByLoginPassword */
public:
	int soap_type() const { return 95; } /* = unique id SOAP_TYPE___ns1__authenticateByLoginPassword */
};
#endif

#ifndef SOAP_TYPE___ns1__authenticateByTrustedPrincipal
#define SOAP_TYPE___ns1__authenticateByTrustedPrincipal (99)
/* Operation wrapper: */
struct __ns1__authenticateByTrustedPrincipal
{
public:
	ns1__authenticateByTrustedPrincipal *ns1__authenticateByTrustedPrincipal_;	/* optional element of type ns1:authenticateByTrustedPrincipal */
public:
	int soap_type() const { return 99; } /* = unique id SOAP_TYPE___ns1__authenticateByTrustedPrincipal */
};
#endif

#ifndef SOAP_TYPE___ns1__authenticateByCallerPrincipal
#define SOAP_TYPE___ns1__authenticateByCallerPrincipal (103)
/* Operation wrapper: */
struct __ns1__authenticateByCallerPrincipal
{
public:
	ns1__authenticateByCallerPrincipal *ns1__authenticateByCallerPrincipal_;	/* optional element of type ns1:authenticateByCallerPrincipal */
public:
	int soap_type() const { return 103; } /* = unique id SOAP_TYPE___ns1__authenticateByCallerPrincipal */
};
#endif

#ifndef SOAP_TYPE___ns1__getMyTasks
#define SOAP_TYPE___ns1__getMyTasks (107)
/* Operation wrapper: */
struct __ns1__getMyTasks
{
public:
	ns1__getMyTasks *ns1__getMyTasks_;	/* optional element of type ns1:getMyTasks */
public:
	int soap_type() const { return 107; } /* = unique id SOAP_TYPE___ns1__getMyTasks */
};
#endif

#ifndef SOAP_TYPE___ns1__markTaskOpenedResponse
#define SOAP_TYPE___ns1__markTaskOpenedResponse (111)
/* Operation wrapper: */
struct __ns1__markTaskOpenedResponse
{
public:
	ns1__markTaskOpenedResponse *ns1__markTaskOpenedResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:markTaskOpenedResponse */
public:
	int soap_type() const { return 111; } /* = unique id SOAP_TYPE___ns1__markTaskOpenedResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__markTaskOpened
#define SOAP_TYPE___ns1__markTaskOpened (112)
/* Operation wrapper: */
struct __ns1__markTaskOpened
{
public:
	ns1__markTaskOpened *ns1__markTaskOpened_;	/* optional element of type ns1:markTaskOpened */
public:
	int soap_type() const { return 112; } /* = unique id SOAP_TYPE___ns1__markTaskOpened */
};
#endif

#ifndef SOAP_TYPE___ns1__reassignTaskResponse
#define SOAP_TYPE___ns1__reassignTaskResponse (116)
/* Operation wrapper: */
struct __ns1__reassignTaskResponse
{
public:
	ns1__reassignTaskResponse *ns1__reassignTaskResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:reassignTaskResponse */
public:
	int soap_type() const { return 116; } /* = unique id SOAP_TYPE___ns1__reassignTaskResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__reassignTask
#define SOAP_TYPE___ns1__reassignTask (117)
/* Operation wrapper: */
struct __ns1__reassignTask
{
public:
	ns1__reassignTask *ns1__reassignTask_;	/* optional element of type ns1:reassignTask */
public:
	int soap_type() const { return 117; } /* = unique id SOAP_TYPE___ns1__reassignTask */
};
#endif

#ifndef SOAP_TYPE___ns1__reassignTasks
#define SOAP_TYPE___ns1__reassignTasks (121)
/* Operation wrapper: */
struct __ns1__reassignTasks
{
public:
	ns1__reassignTasks *ns1__reassignTasks_;	/* optional element of type ns1:reassignTasks */
public:
	int soap_type() const { return 121; } /* = unique id SOAP_TYPE___ns1__reassignTasks */
};
#endif

#ifndef SOAP_TYPE___ns1__getTasks
#define SOAP_TYPE___ns1__getTasks (125)
/* Operation wrapper: */
struct __ns1__getTasks
{
public:
	ns1__getTasks *ns1__getTasks_;	/* optional element of type ns1:getTasks */
public:
	int soap_type() const { return 125; } /* = unique id SOAP_TYPE___ns1__getTasks */
};
#endif

#ifndef SOAP_TYPE___ns1__completeTaskWSResponse
#define SOAP_TYPE___ns1__completeTaskWSResponse (129)
/* Operation wrapper: */
struct __ns1__completeTaskWSResponse
{
public:
	ns1__completeTaskWSResponse *ns1__completeTaskWSResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:completeTaskWSResponse */
public:
	int soap_type() const { return 129; } /* = unique id SOAP_TYPE___ns1__completeTaskWSResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__completeTaskWS
#define SOAP_TYPE___ns1__completeTaskWS (130)
/* Operation wrapper: */
struct __ns1__completeTaskWS
{
public:
	ns1__completeTaskWS *ns1__completeTaskWS_;	/* optional element of type ns1:completeTaskWS */
public:
	int soap_type() const { return 130; } /* = unique id SOAP_TYPE___ns1__completeTaskWS */
};
#endif

#ifndef SOAP_TYPE___ns1__getProcessTasks
#define SOAP_TYPE___ns1__getProcessTasks (134)
/* Operation wrapper: */
struct __ns1__getProcessTasks
{
public:
	ns1__getProcessTasks *ns1__getProcessTasks_;	/* optional element of type ns1:getProcessTasks */
public:
	int soap_type() const { return 134; } /* = unique id SOAP_TYPE___ns1__getProcessTasks */
};
#endif

#ifndef SOAP_TYPE___ns1__assignTaskResponse
#define SOAP_TYPE___ns1__assignTaskResponse (138)
/* Operation wrapper: */
struct __ns1__assignTaskResponse
{
public:
	ns1__assignTaskResponse *ns1__assignTaskResponse_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:assignTaskResponse */
public:
	int soap_type() const { return 138; } /* = unique id SOAP_TYPE___ns1__assignTaskResponse */
};
#endif

#ifndef SOAP_TYPE___ns1__assignTask
#define SOAP_TYPE___ns1__assignTask (139)
/* Operation wrapper: */
struct __ns1__assignTask
{
public:
	ns1__assignTask *ns1__assignTask_;	/* optional element of type ns1:assignTask */
public:
	int soap_type() const { return 139; } /* = unique id SOAP_TYPE___ns1__assignTask */
};
#endif

#ifndef SOAP_TYPE___ns1__getTask
#define SOAP_TYPE___ns1__getTask (143)
/* Operation wrapper: */
struct __ns1__getTask
{
public:
	ns1__getTask *ns1__getTask_;	/* optional element of type ns1:getTask */
public:
	int soap_type() const { return 143; } /* = unique id SOAP_TYPE___ns1__getTask */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (144)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 144; } /* = unique id SOAP_TYPE_SOAP_ENV__Header */
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (145)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 145; } /* = unique id SOAP_TYPE_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (147)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
public:
	int soap_type() const { return 147; } /* = unique id SOAP_TYPE_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (150)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 150; } /* = unique id SOAP_TYPE_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (151)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 151; } /* = unique id SOAP_TYPE_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
