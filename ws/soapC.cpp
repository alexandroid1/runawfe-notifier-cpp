/* soapC.cpp
   Generated by gSOAP 2.8.16 from ServerAPI.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "stdafx.h"
#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.16 2016-09-01 03:35:11 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_ns1__classPresentationType:
		return soap_in_ns1__classPresentationType(soap, NULL, NULL, "ns1:classPresentationType");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__classPresentationType_:
		return soap_in_ns1__classPresentationType_(soap, NULL, NULL, "ns1:classPresentationType");
	case SOAP_TYPE_ns2__wfVariableStub:
		return soap_in_ns2__wfVariableStub(soap, NULL, NULL, "ns2:wfVariableStub");
	case SOAP_TYPE_ns1__assignTaskResponse:
		return soap_in_ns1__assignTaskResponse(soap, NULL, NULL, "ns1:assignTaskResponse");
	case SOAP_TYPE_ns1__assignTask:
		return soap_in_ns1__assignTask(soap, NULL, NULL, "ns1:assignTask");
	case SOAP_TYPE_ns1__getTaskResponse:
		return soap_in_ns1__getTaskResponse(soap, NULL, NULL, "ns1:getTaskResponse");
	case SOAP_TYPE_ns1__getTask:
		return soap_in_ns1__getTask(soap, NULL, NULL, "ns1:getTask");
	case SOAP_TYPE_ns1__getProcessTasksResponse:
		return soap_in_ns1__getProcessTasksResponse(soap, NULL, NULL, "ns1:getProcessTasksResponse");
	case SOAP_TYPE_ns1__getProcessTasks:
		return soap_in_ns1__getProcessTasks(soap, NULL, NULL, "ns1:getProcessTasks");
	case SOAP_TYPE_ns1__completeTaskWSResponse:
		return soap_in_ns1__completeTaskWSResponse(soap, NULL, NULL, "ns1:completeTaskWSResponse");
	case SOAP_TYPE_ns1__variable:
		return soap_in_ns1__variable(soap, NULL, NULL, "ns1:variable");
	case SOAP_TYPE_ns1__completeTaskWS:
		return soap_in_ns1__completeTaskWS(soap, NULL, NULL, "ns1:completeTaskWS");
	case SOAP_TYPE_ns1__getTasksResponse:
		return soap_in_ns1__getTasksResponse(soap, NULL, NULL, "ns1:getTasksResponse");
	case SOAP_TYPE_ns1__getTasks:
		return soap_in_ns1__getTasks(soap, NULL, NULL, "ns1:getTasks");
	case SOAP_TYPE_ns1__reassignTasksResponse:
		return soap_in_ns1__reassignTasksResponse(soap, NULL, NULL, "ns1:reassignTasksResponse");
	case SOAP_TYPE_ns1__reassignTasks:
		return soap_in_ns1__reassignTasks(soap, NULL, NULL, "ns1:reassignTasks");
	case SOAP_TYPE_ns1__reassignTaskResponse:
		return soap_in_ns1__reassignTaskResponse(soap, NULL, NULL, "ns1:reassignTaskResponse");
	case SOAP_TYPE_ns1__reassignTask:
		return soap_in_ns1__reassignTask(soap, NULL, NULL, "ns1:reassignTask");
	case SOAP_TYPE_ns1__markTaskOpenedResponse:
		return soap_in_ns1__markTaskOpenedResponse(soap, NULL, NULL, "ns1:markTaskOpenedResponse");
	case SOAP_TYPE_ns1__markTaskOpened:
		return soap_in_ns1__markTaskOpened(soap, NULL, NULL, "ns1:markTaskOpened");
	case SOAP_TYPE_ns1__variableFormat:
		return soap_in_ns1__variableFormat(soap, NULL, NULL, "ns1:variableFormat");
	case SOAP_TYPE_ns1__userType:
		return soap_in_ns1__userType(soap, NULL, NULL, "ns1:userType");
	case SOAP_TYPE_ns1__variableDefinition:
		return soap_in_ns1__variableDefinition(soap, NULL, NULL, "ns1:variableDefinition");
	case SOAP_TYPE_ns1__wfTask:
		return soap_in_ns1__wfTask(soap, NULL, NULL, "ns1:wfTask");
	case SOAP_TYPE_ns1__getMyTasksResponse:
		return soap_in_ns1__getMyTasksResponse(soap, NULL, NULL, "ns1:getMyTasksResponse");
	case SOAP_TYPE_ns1__batchPresentation:
		return soap_in_ns1__batchPresentation(soap, NULL, NULL, "ns1:batchPresentation");
	case SOAP_TYPE_ns1__getMyTasks:
		return soap_in_ns1__getMyTasks(soap, NULL, NULL, "ns1:getMyTasks");
	case SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse:
		return soap_in_ns1__authenticateByCallerPrincipalResponse(soap, NULL, NULL, "ns1:authenticateByCallerPrincipalResponse");
	case SOAP_TYPE_ns1__authenticateByCallerPrincipal:
		return soap_in_ns1__authenticateByCallerPrincipal(soap, NULL, NULL, "ns1:authenticateByCallerPrincipal");
	case SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse:
		return soap_in_ns1__authenticateByTrustedPrincipalResponse(soap, NULL, NULL, "ns1:authenticateByTrustedPrincipalResponse");
	case SOAP_TYPE_ns1__authenticateByTrustedPrincipal:
		return soap_in_ns1__authenticateByTrustedPrincipal(soap, NULL, NULL, "ns1:authenticateByTrustedPrincipal");
	case SOAP_TYPE_ns1__authenticateByLoginPasswordResponse:
		return soap_in_ns1__authenticateByLoginPasswordResponse(soap, NULL, NULL, "ns1:authenticateByLoginPasswordResponse");
	case SOAP_TYPE_ns1__authenticateByLoginPassword:
		return soap_in_ns1__authenticateByLoginPassword(soap, NULL, NULL, "ns1:authenticateByLoginPassword");
	case SOAP_TYPE_ns1__wfExecutor:
		return soap_in_ns1__wfExecutor(soap, NULL, NULL, "ns1:wfExecutor");
	case SOAP_TYPE_ns1__identifiable:
		return soap_in_ns1__identifiable(soap, NULL, NULL, "ns1:identifiable");
	case SOAP_TYPE_ns1__identifiableBase:
		return soap_in_ns1__identifiableBase(soap, NULL, NULL, "ns1:identifiableBase");
	case SOAP_TYPE_ns1__executor:
		return soap_in_ns1__executor(soap, NULL, NULL, "ns1:executor");
	case SOAP_TYPE_ns1__actor:
		return soap_in_ns1__actor(soap, NULL, NULL, "ns1:actor");
	case SOAP_TYPE_ns1__user:
		return soap_in_ns1__user(soap, NULL, NULL, "ns1:user");
	case SOAP_TYPE_ns1__authenticateByKerberosResponse:
		return soap_in_ns1__authenticateByKerberosResponse(soap, NULL, NULL, "ns1:authenticateByKerberosResponse");
	case SOAP_TYPE_ns1__authenticateByKerberos:
		return soap_in_ns1__authenticateByKerberos(soap, NULL, NULL, "ns1:authenticateByKerberos");
	case SOAP_TYPE_xsd__string:
		return soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__long:
		return soap_in_xsd__long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_xsd__int:
		return soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_xsd__dateTime:
		return soap_in_xsd__dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_xsd__base64Binary_:
		return soap_in_xsd__base64Binary_(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__anyType:
		return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerTons1__getTaskResponse:
		return soap_in_PointerTons1__getTaskResponse(soap, NULL, NULL, "ns1:getTaskResponse");
	case SOAP_TYPE_PointerTons1__getTask:
		return soap_in_PointerTons1__getTask(soap, NULL, NULL, "ns1:getTask");
	case SOAP_TYPE_PointerTons1__assignTaskResponse:
		return soap_in_PointerTons1__assignTaskResponse(soap, NULL, NULL, "ns1:assignTaskResponse");
	case SOAP_TYPE_PointerTons1__assignTask:
		return soap_in_PointerTons1__assignTask(soap, NULL, NULL, "ns1:assignTask");
	case SOAP_TYPE_PointerTons1__getProcessTasksResponse:
		return soap_in_PointerTons1__getProcessTasksResponse(soap, NULL, NULL, "ns1:getProcessTasksResponse");
	case SOAP_TYPE_PointerTons1__getProcessTasks:
		return soap_in_PointerTons1__getProcessTasks(soap, NULL, NULL, "ns1:getProcessTasks");
	case SOAP_TYPE_PointerTons1__completeTaskWSResponse:
		return soap_in_PointerTons1__completeTaskWSResponse(soap, NULL, NULL, "ns1:completeTaskWSResponse");
	case SOAP_TYPE_PointerTons1__completeTaskWS:
		return soap_in_PointerTons1__completeTaskWS(soap, NULL, NULL, "ns1:completeTaskWS");
	case SOAP_TYPE_PointerTons1__getTasksResponse:
		return soap_in_PointerTons1__getTasksResponse(soap, NULL, NULL, "ns1:getTasksResponse");
	case SOAP_TYPE_PointerTons1__getTasks:
		return soap_in_PointerTons1__getTasks(soap, NULL, NULL, "ns1:getTasks");
	case SOAP_TYPE_PointerTons1__reassignTasksResponse:
		return soap_in_PointerTons1__reassignTasksResponse(soap, NULL, NULL, "ns1:reassignTasksResponse");
	case SOAP_TYPE_PointerTons1__reassignTasks:
		return soap_in_PointerTons1__reassignTasks(soap, NULL, NULL, "ns1:reassignTasks");
	case SOAP_TYPE_PointerTons1__reassignTaskResponse:
		return soap_in_PointerTons1__reassignTaskResponse(soap, NULL, NULL, "ns1:reassignTaskResponse");
	case SOAP_TYPE_PointerTons1__reassignTask:
		return soap_in_PointerTons1__reassignTask(soap, NULL, NULL, "ns1:reassignTask");
	case SOAP_TYPE_PointerTons1__markTaskOpenedResponse:
		return soap_in_PointerTons1__markTaskOpenedResponse(soap, NULL, NULL, "ns1:markTaskOpenedResponse");
	case SOAP_TYPE_PointerTons1__markTaskOpened:
		return soap_in_PointerTons1__markTaskOpened(soap, NULL, NULL, "ns1:markTaskOpened");
	case SOAP_TYPE_PointerTons1__getMyTasksResponse:
		return soap_in_PointerTons1__getMyTasksResponse(soap, NULL, NULL, "ns1:getMyTasksResponse");
	case SOAP_TYPE_PointerTons1__getMyTasks:
		return soap_in_PointerTons1__getMyTasks(soap, NULL, NULL, "ns1:getMyTasks");
	case SOAP_TYPE_PointerTons1__authenticateByCallerPrincipalResponse:
		return soap_in_PointerTons1__authenticateByCallerPrincipalResponse(soap, NULL, NULL, "ns1:authenticateByCallerPrincipalResponse");
	case SOAP_TYPE_PointerTons1__authenticateByCallerPrincipal:
		return soap_in_PointerTons1__authenticateByCallerPrincipal(soap, NULL, NULL, "ns1:authenticateByCallerPrincipal");
	case SOAP_TYPE_PointerTons1__authenticateByTrustedPrincipalResponse:
		return soap_in_PointerTons1__authenticateByTrustedPrincipalResponse(soap, NULL, NULL, "ns1:authenticateByTrustedPrincipalResponse");
	case SOAP_TYPE_PointerTons1__authenticateByTrustedPrincipal:
		return soap_in_PointerTons1__authenticateByTrustedPrincipal(soap, NULL, NULL, "ns1:authenticateByTrustedPrincipal");
	case SOAP_TYPE_PointerTons1__authenticateByLoginPasswordResponse:
		return soap_in_PointerTons1__authenticateByLoginPasswordResponse(soap, NULL, NULL, "ns1:authenticateByLoginPasswordResponse");
	case SOAP_TYPE_PointerTons1__authenticateByLoginPassword:
		return soap_in_PointerTons1__authenticateByLoginPassword(soap, NULL, NULL, "ns1:authenticateByLoginPassword");
	case SOAP_TYPE_PointerTons1__authenticateByKerberosResponse:
		return soap_in_PointerTons1__authenticateByKerberosResponse(soap, NULL, NULL, "ns1:authenticateByKerberosResponse");
	case SOAP_TYPE_PointerTons1__authenticateByKerberos:
		return soap_in_PointerTons1__authenticateByKerberos(soap, NULL, NULL, "ns1:authenticateByKerberos");
	case SOAP_TYPE_PointerToPointerTons1__variable:
		return soap_in_PointerToPointerTons1__variable(soap, NULL, NULL, "ns1:variable");
	case SOAP_TYPE_PointerTons1__variable:
		return soap_in_PointerTons1__variable(soap, NULL, NULL, "ns1:variable");
	case SOAP_TYPE_PointerTo_ns1__userType_attributesMap_entry:
		return soap_in_PointerTo_ns1__userType_attributesMap_entry(soap, NULL, NULL, "ns1:userType-attributesMap-entry");
	case SOAP_TYPE_PointerToPointerTons1__variableDefinition:
		return soap_in_PointerToPointerTons1__variableDefinition(soap, NULL, NULL, "ns1:variableDefinition");
	case SOAP_TYPE_PointerTons1__variableDefinition:
		return soap_in_PointerTons1__variableDefinition(soap, NULL, NULL, "ns1:variableDefinition");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_in_PointerToxsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerToPointerTons1__userType:
		return soap_in_PointerToPointerTons1__userType(soap, NULL, NULL, "ns1:userType");
	case SOAP_TYPE_PointerTons1__userType:
		return soap_in_PointerTons1__userType(soap, NULL, NULL, "ns1:userType");
	case SOAP_TYPE_PointerToPointerTons2__wfVariableStub:
		return soap_in_PointerToPointerTons2__wfVariableStub(soap, NULL, NULL, "ns2:wfVariableStub");
	case SOAP_TYPE_PointerTons2__wfVariableStub:
		return soap_in_PointerTons2__wfVariableStub(soap, NULL, NULL, "ns2:wfVariableStub");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTons1__wfExecutor:
		return soap_in_PointerTons1__wfExecutor(soap, NULL, NULL, "ns1:wfExecutor");
	case SOAP_TYPE_PointerToPointerTons1__wfTask:
		return soap_in_PointerToPointerTons1__wfTask(soap, NULL, NULL, "ns1:wfTask");
	case SOAP_TYPE_PointerTons1__wfTask:
		return soap_in_PointerTons1__wfTask(soap, NULL, NULL, "ns1:wfTask");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__classPresentationType:
		return soap_in_PointerTons1__classPresentationType(soap, NULL, NULL, "ns1:classPresentationType");
	case SOAP_TYPE_PointerToLONG64:
		return soap_in_PointerToLONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_PointerTons1__batchPresentation:
		return soap_in_PointerTons1__batchPresentation(soap, NULL, NULL, "ns1:batchPresentation");
	case SOAP_TYPE_PointerTons1__actor:
		return soap_in_PointerTons1__actor(soap, NULL, NULL, "ns1:actor");
	case SOAP_TYPE_PointerTons1__user:
		return soap_in_PointerTons1__user(soap, NULL, NULL, "ns1:user");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_in_PointerToxsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_wstring:
	{	wchar_t **s;
		s = soap_in_wstring(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:classPresentationType"))
		{	*type = SOAP_TYPE_ns1__classPresentationType_;
			return soap_in_ns1__classPresentationType_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:wfVariableStub"))
		{	*type = SOAP_TYPE_ns2__wfVariableStub;
			return soap_in_ns2__wfVariableStub(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:assignTaskResponse"))
		{	*type = SOAP_TYPE_ns1__assignTaskResponse;
			return soap_in_ns1__assignTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:assignTask"))
		{	*type = SOAP_TYPE_ns1__assignTask;
			return soap_in_ns1__assignTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTaskResponse"))
		{	*type = SOAP_TYPE_ns1__getTaskResponse;
			return soap_in_ns1__getTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTask"))
		{	*type = SOAP_TYPE_ns1__getTask;
			return soap_in_ns1__getTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcessTasksResponse"))
		{	*type = SOAP_TYPE_ns1__getProcessTasksResponse;
			return soap_in_ns1__getProcessTasksResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProcessTasks"))
		{	*type = SOAP_TYPE_ns1__getProcessTasks;
			return soap_in_ns1__getProcessTasks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:completeTaskWSResponse"))
		{	*type = SOAP_TYPE_ns1__completeTaskWSResponse;
			return soap_in_ns1__completeTaskWSResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:variable"))
		{	*type = SOAP_TYPE_ns1__variable;
			return soap_in_ns1__variable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:completeTaskWS"))
		{	*type = SOAP_TYPE_ns1__completeTaskWS;
			return soap_in_ns1__completeTaskWS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTasksResponse"))
		{	*type = SOAP_TYPE_ns1__getTasksResponse;
			return soap_in_ns1__getTasksResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTasks"))
		{	*type = SOAP_TYPE_ns1__getTasks;
			return soap_in_ns1__getTasks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:reassignTasksResponse"))
		{	*type = SOAP_TYPE_ns1__reassignTasksResponse;
			return soap_in_ns1__reassignTasksResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:reassignTasks"))
		{	*type = SOAP_TYPE_ns1__reassignTasks;
			return soap_in_ns1__reassignTasks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:reassignTaskResponse"))
		{	*type = SOAP_TYPE_ns1__reassignTaskResponse;
			return soap_in_ns1__reassignTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:reassignTask"))
		{	*type = SOAP_TYPE_ns1__reassignTask;
			return soap_in_ns1__reassignTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:markTaskOpenedResponse"))
		{	*type = SOAP_TYPE_ns1__markTaskOpenedResponse;
			return soap_in_ns1__markTaskOpenedResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:markTaskOpened"))
		{	*type = SOAP_TYPE_ns1__markTaskOpened;
			return soap_in_ns1__markTaskOpened(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:variableFormat"))
		{	*type = SOAP_TYPE_ns1__variableFormat;
			return soap_in_ns1__variableFormat(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:userType"))
		{	*type = SOAP_TYPE_ns1__userType;
			return soap_in_ns1__userType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:variableDefinition"))
		{	*type = SOAP_TYPE_ns1__variableDefinition;
			return soap_in_ns1__variableDefinition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:wfTask"))
		{	*type = SOAP_TYPE_ns1__wfTask;
			return soap_in_ns1__wfTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMyTasksResponse"))
		{	*type = SOAP_TYPE_ns1__getMyTasksResponse;
			return soap_in_ns1__getMyTasksResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:batchPresentation"))
		{	*type = SOAP_TYPE_ns1__batchPresentation;
			return soap_in_ns1__batchPresentation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMyTasks"))
		{	*type = SOAP_TYPE_ns1__getMyTasks;
			return soap_in_ns1__getMyTasks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:authenticateByCallerPrincipalResponse"))
		{	*type = SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse;
			return soap_in_ns1__authenticateByCallerPrincipalResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:authenticateByCallerPrincipal"))
		{	*type = SOAP_TYPE_ns1__authenticateByCallerPrincipal;
			return soap_in_ns1__authenticateByCallerPrincipal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:authenticateByTrustedPrincipalResponse"))
		{	*type = SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse;
			return soap_in_ns1__authenticateByTrustedPrincipalResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:authenticateByTrustedPrincipal"))
		{	*type = SOAP_TYPE_ns1__authenticateByTrustedPrincipal;
			return soap_in_ns1__authenticateByTrustedPrincipal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:authenticateByLoginPasswordResponse"))
		{	*type = SOAP_TYPE_ns1__authenticateByLoginPasswordResponse;
			return soap_in_ns1__authenticateByLoginPasswordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:authenticateByLoginPassword"))
		{	*type = SOAP_TYPE_ns1__authenticateByLoginPassword;
			return soap_in_ns1__authenticateByLoginPassword(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:wfExecutor"))
		{	*type = SOAP_TYPE_ns1__wfExecutor;
			return soap_in_ns1__wfExecutor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:identifiable"))
		{	*type = SOAP_TYPE_ns1__identifiable;
			return soap_in_ns1__identifiable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:identifiableBase"))
		{	*type = SOAP_TYPE_ns1__identifiableBase;
			return soap_in_ns1__identifiableBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:executor"))
		{	*type = SOAP_TYPE_ns1__executor;
			return soap_in_ns1__executor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:actor"))
		{	*type = SOAP_TYPE_ns1__actor;
			return soap_in_ns1__actor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:user"))
		{	*type = SOAP_TYPE_ns1__user;
			return soap_in_ns1__user(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:authenticateByKerberosResponse"))
		{	*type = SOAP_TYPE_ns1__authenticateByKerberosResponse;
			return soap_in_ns1__authenticateByKerberosResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:authenticateByKerberos"))
		{	*type = SOAP_TYPE_ns1__authenticateByKerberos;
			return soap_in_ns1__authenticateByKerberos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_xsd__string;
			return soap_in_xsd__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_xsd__long;
			return soap_in_xsd__long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_xsd__int;
			return soap_in_xsd__int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_xsd__dateTime;
			return soap_in_xsd__dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary_;
			return soap_in_xsd__base64Binary_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_xsd__anyType;
			return soap_in_xsd__anyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:classPresentationType"))
		{	*type = SOAP_TYPE_ns1__classPresentationType;
			return soap_in_ns1__classPresentationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	wchar_t **s;
			*type = SOAP_TYPE_wstring;
			s = soap_in_wstring(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:userType-attributesMap-entry"))
		{	*type = SOAP_TYPE__ns1__userType_attributesMap_entry;
			return soap_in__ns1__userType_attributesMap_entry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:userType-attributesMap"))
		{	*type = SOAP_TYPE__ns1__userType_attributesMap;
			return soap_in__ns1__userType_attributesMap(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_ns1__classPresentationType:
		return soap_out_ns1__classPresentationType(soap, tag, id, (const enum ns1__classPresentationType *)ptr, "ns1:classPresentationType");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE__ns1__userType_attributesMap_entry:
		return ((_ns1__userType_attributesMap_entry *)ptr)->soap_out(soap, "ns1:userType-attributesMap-entry", id, NULL);
	case SOAP_TYPE__ns1__userType_attributesMap:
		return ((_ns1__userType_attributesMap *)ptr)->soap_out(soap, "ns1:userType-attributesMap", id, NULL);
	case SOAP_TYPE_ns1__classPresentationType_:
		return ((ns1__classPresentationType_ *)ptr)->soap_out(soap, tag, id, "ns1:classPresentationType");
	case SOAP_TYPE_ns2__wfVariableStub:
		return ((ns2__wfVariableStub *)ptr)->soap_out(soap, tag, id, "ns2:wfVariableStub");
	case SOAP_TYPE_ns1__assignTaskResponse:
		return ((ns1__assignTaskResponse *)ptr)->soap_out(soap, tag, id, "ns1:assignTaskResponse");
	case SOAP_TYPE_ns1__assignTask:
		return ((ns1__assignTask *)ptr)->soap_out(soap, tag, id, "ns1:assignTask");
	case SOAP_TYPE_ns1__getTaskResponse:
		return ((ns1__getTaskResponse *)ptr)->soap_out(soap, tag, id, "ns1:getTaskResponse");
	case SOAP_TYPE_ns1__getTask:
		return ((ns1__getTask *)ptr)->soap_out(soap, tag, id, "ns1:getTask");
	case SOAP_TYPE_ns1__getProcessTasksResponse:
		return ((ns1__getProcessTasksResponse *)ptr)->soap_out(soap, tag, id, "ns1:getProcessTasksResponse");
	case SOAP_TYPE_ns1__getProcessTasks:
		return ((ns1__getProcessTasks *)ptr)->soap_out(soap, tag, id, "ns1:getProcessTasks");
	case SOAP_TYPE_ns1__completeTaskWSResponse:
		return ((ns1__completeTaskWSResponse *)ptr)->soap_out(soap, tag, id, "ns1:completeTaskWSResponse");
	case SOAP_TYPE_ns1__variable:
		return ((ns1__variable *)ptr)->soap_out(soap, tag, id, "ns1:variable");
	case SOAP_TYPE_ns1__completeTaskWS:
		return ((ns1__completeTaskWS *)ptr)->soap_out(soap, tag, id, "ns1:completeTaskWS");
	case SOAP_TYPE_ns1__getTasksResponse:
		return ((ns1__getTasksResponse *)ptr)->soap_out(soap, tag, id, "ns1:getTasksResponse");
	case SOAP_TYPE_ns1__getTasks:
		return ((ns1__getTasks *)ptr)->soap_out(soap, tag, id, "ns1:getTasks");
	case SOAP_TYPE_ns1__reassignTasksResponse:
		return ((ns1__reassignTasksResponse *)ptr)->soap_out(soap, tag, id, "ns1:reassignTasksResponse");
	case SOAP_TYPE_ns1__reassignTasks:
		return ((ns1__reassignTasks *)ptr)->soap_out(soap, tag, id, "ns1:reassignTasks");
	case SOAP_TYPE_ns1__reassignTaskResponse:
		return ((ns1__reassignTaskResponse *)ptr)->soap_out(soap, tag, id, "ns1:reassignTaskResponse");
	case SOAP_TYPE_ns1__reassignTask:
		return ((ns1__reassignTask *)ptr)->soap_out(soap, tag, id, "ns1:reassignTask");
	case SOAP_TYPE_ns1__markTaskOpenedResponse:
		return ((ns1__markTaskOpenedResponse *)ptr)->soap_out(soap, tag, id, "ns1:markTaskOpenedResponse");
	case SOAP_TYPE_ns1__markTaskOpened:
		return ((ns1__markTaskOpened *)ptr)->soap_out(soap, tag, id, "ns1:markTaskOpened");
	case SOAP_TYPE_ns1__variableFormat:
		return ((ns1__variableFormat *)ptr)->soap_out(soap, tag, id, "ns1:variableFormat");
	case SOAP_TYPE_ns1__userType:
		return ((ns1__userType *)ptr)->soap_out(soap, tag, id, "ns1:userType");
	case SOAP_TYPE_ns1__variableDefinition:
		return ((ns1__variableDefinition *)ptr)->soap_out(soap, tag, id, "ns1:variableDefinition");
	case SOAP_TYPE_ns1__wfTask:
		return ((ns1__wfTask *)ptr)->soap_out(soap, tag, id, "ns1:wfTask");
	case SOAP_TYPE_ns1__getMyTasksResponse:
		return ((ns1__getMyTasksResponse *)ptr)->soap_out(soap, tag, id, "ns1:getMyTasksResponse");
	case SOAP_TYPE_ns1__batchPresentation:
		return ((ns1__batchPresentation *)ptr)->soap_out(soap, tag, id, "ns1:batchPresentation");
	case SOAP_TYPE_ns1__getMyTasks:
		return ((ns1__getMyTasks *)ptr)->soap_out(soap, tag, id, "ns1:getMyTasks");
	case SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse:
		return ((ns1__authenticateByCallerPrincipalResponse *)ptr)->soap_out(soap, tag, id, "ns1:authenticateByCallerPrincipalResponse");
	case SOAP_TYPE_ns1__authenticateByCallerPrincipal:
		return ((ns1__authenticateByCallerPrincipal *)ptr)->soap_out(soap, tag, id, "ns1:authenticateByCallerPrincipal");
	case SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse:
		return ((ns1__authenticateByTrustedPrincipalResponse *)ptr)->soap_out(soap, tag, id, "ns1:authenticateByTrustedPrincipalResponse");
	case SOAP_TYPE_ns1__authenticateByTrustedPrincipal:
		return ((ns1__authenticateByTrustedPrincipal *)ptr)->soap_out(soap, tag, id, "ns1:authenticateByTrustedPrincipal");
	case SOAP_TYPE_ns1__authenticateByLoginPasswordResponse:
		return ((ns1__authenticateByLoginPasswordResponse *)ptr)->soap_out(soap, tag, id, "ns1:authenticateByLoginPasswordResponse");
	case SOAP_TYPE_ns1__authenticateByLoginPassword:
		return ((ns1__authenticateByLoginPassword *)ptr)->soap_out(soap, tag, id, "ns1:authenticateByLoginPassword");
	case SOAP_TYPE_ns1__wfExecutor:
		return ((ns1__wfExecutor *)ptr)->soap_out(soap, tag, id, "ns1:wfExecutor");
	case SOAP_TYPE_ns1__identifiable:
		return ((ns1__identifiable *)ptr)->soap_out(soap, tag, id, "ns1:identifiable");
	case SOAP_TYPE_ns1__identifiableBase:
		return ((ns1__identifiableBase *)ptr)->soap_out(soap, tag, id, "ns1:identifiableBase");
	case SOAP_TYPE_ns1__executor:
		return ((ns1__executor *)ptr)->soap_out(soap, tag, id, "ns1:executor");
	case SOAP_TYPE_ns1__actor:
		return ((ns1__actor *)ptr)->soap_out(soap, tag, id, "ns1:actor");
	case SOAP_TYPE_ns1__user:
		return ((ns1__user *)ptr)->soap_out(soap, tag, id, "ns1:user");
	case SOAP_TYPE_ns1__authenticateByKerberosResponse:
		return ((ns1__authenticateByKerberosResponse *)ptr)->soap_out(soap, tag, id, "ns1:authenticateByKerberosResponse");
	case SOAP_TYPE_ns1__authenticateByKerberos:
		return ((ns1__authenticateByKerberos *)ptr)->soap_out(soap, tag, id, "ns1:authenticateByKerberos");
	case SOAP_TYPE_xsd__string:
		return ((xsd__string *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_xsd__long:
		return ((xsd__long *)ptr)->soap_out(soap, tag, id, "xsd:long");
	case SOAP_TYPE_xsd__int:
		return ((xsd__int *)ptr)->soap_out(soap, tag, id, "xsd:int");
	case SOAP_TYPE_xsd__dateTime:
		return ((xsd__dateTime *)ptr)->soap_out(soap, tag, id, "xsd:dateTime");
	case SOAP_TYPE_xsd__boolean:
		return ((xsd__boolean *)ptr)->soap_out(soap, tag, id, "xsd:boolean");
	case SOAP_TYPE_xsd__base64Binary_:
		return ((xsd__base64Binary_ *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__anyType:
		return ((xsd__anyType *)ptr)->soap_out(soap, tag, id, "xsd:anyType");
	case SOAP_TYPE_PointerTons1__getTaskResponse:
		return soap_out_PointerTons1__getTaskResponse(soap, tag, id, (ns1__getTaskResponse *const*)ptr, "ns1:getTaskResponse");
	case SOAP_TYPE_PointerTons1__getTask:
		return soap_out_PointerTons1__getTask(soap, tag, id, (ns1__getTask *const*)ptr, "ns1:getTask");
	case SOAP_TYPE_PointerTons1__assignTaskResponse:
		return soap_out_PointerTons1__assignTaskResponse(soap, tag, id, (ns1__assignTaskResponse *const*)ptr, "ns1:assignTaskResponse");
	case SOAP_TYPE_PointerTons1__assignTask:
		return soap_out_PointerTons1__assignTask(soap, tag, id, (ns1__assignTask *const*)ptr, "ns1:assignTask");
	case SOAP_TYPE_PointerTons1__getProcessTasksResponse:
		return soap_out_PointerTons1__getProcessTasksResponse(soap, tag, id, (ns1__getProcessTasksResponse *const*)ptr, "ns1:getProcessTasksResponse");
	case SOAP_TYPE_PointerTons1__getProcessTasks:
		return soap_out_PointerTons1__getProcessTasks(soap, tag, id, (ns1__getProcessTasks *const*)ptr, "ns1:getProcessTasks");
	case SOAP_TYPE_PointerTons1__completeTaskWSResponse:
		return soap_out_PointerTons1__completeTaskWSResponse(soap, tag, id, (ns1__completeTaskWSResponse *const*)ptr, "ns1:completeTaskWSResponse");
	case SOAP_TYPE_PointerTons1__completeTaskWS:
		return soap_out_PointerTons1__completeTaskWS(soap, tag, id, (ns1__completeTaskWS *const*)ptr, "ns1:completeTaskWS");
	case SOAP_TYPE_PointerTons1__getTasksResponse:
		return soap_out_PointerTons1__getTasksResponse(soap, tag, id, (ns1__getTasksResponse *const*)ptr, "ns1:getTasksResponse");
	case SOAP_TYPE_PointerTons1__getTasks:
		return soap_out_PointerTons1__getTasks(soap, tag, id, (ns1__getTasks *const*)ptr, "ns1:getTasks");
	case SOAP_TYPE_PointerTons1__reassignTasksResponse:
		return soap_out_PointerTons1__reassignTasksResponse(soap, tag, id, (ns1__reassignTasksResponse *const*)ptr, "ns1:reassignTasksResponse");
	case SOAP_TYPE_PointerTons1__reassignTasks:
		return soap_out_PointerTons1__reassignTasks(soap, tag, id, (ns1__reassignTasks *const*)ptr, "ns1:reassignTasks");
	case SOAP_TYPE_PointerTons1__reassignTaskResponse:
		return soap_out_PointerTons1__reassignTaskResponse(soap, tag, id, (ns1__reassignTaskResponse *const*)ptr, "ns1:reassignTaskResponse");
	case SOAP_TYPE_PointerTons1__reassignTask:
		return soap_out_PointerTons1__reassignTask(soap, tag, id, (ns1__reassignTask *const*)ptr, "ns1:reassignTask");
	case SOAP_TYPE_PointerTons1__markTaskOpenedResponse:
		return soap_out_PointerTons1__markTaskOpenedResponse(soap, tag, id, (ns1__markTaskOpenedResponse *const*)ptr, "ns1:markTaskOpenedResponse");
	case SOAP_TYPE_PointerTons1__markTaskOpened:
		return soap_out_PointerTons1__markTaskOpened(soap, tag, id, (ns1__markTaskOpened *const*)ptr, "ns1:markTaskOpened");
	case SOAP_TYPE_PointerTons1__getMyTasksResponse:
		return soap_out_PointerTons1__getMyTasksResponse(soap, tag, id, (ns1__getMyTasksResponse *const*)ptr, "ns1:getMyTasksResponse");
	case SOAP_TYPE_PointerTons1__getMyTasks:
		return soap_out_PointerTons1__getMyTasks(soap, tag, id, (ns1__getMyTasks *const*)ptr, "ns1:getMyTasks");
	case SOAP_TYPE_PointerTons1__authenticateByCallerPrincipalResponse:
		return soap_out_PointerTons1__authenticateByCallerPrincipalResponse(soap, tag, id, (ns1__authenticateByCallerPrincipalResponse *const*)ptr, "ns1:authenticateByCallerPrincipalResponse");
	case SOAP_TYPE_PointerTons1__authenticateByCallerPrincipal:
		return soap_out_PointerTons1__authenticateByCallerPrincipal(soap, tag, id, (ns1__authenticateByCallerPrincipal *const*)ptr, "ns1:authenticateByCallerPrincipal");
	case SOAP_TYPE_PointerTons1__authenticateByTrustedPrincipalResponse:
		return soap_out_PointerTons1__authenticateByTrustedPrincipalResponse(soap, tag, id, (ns1__authenticateByTrustedPrincipalResponse *const*)ptr, "ns1:authenticateByTrustedPrincipalResponse");
	case SOAP_TYPE_PointerTons1__authenticateByTrustedPrincipal:
		return soap_out_PointerTons1__authenticateByTrustedPrincipal(soap, tag, id, (ns1__authenticateByTrustedPrincipal *const*)ptr, "ns1:authenticateByTrustedPrincipal");
	case SOAP_TYPE_PointerTons1__authenticateByLoginPasswordResponse:
		return soap_out_PointerTons1__authenticateByLoginPasswordResponse(soap, tag, id, (ns1__authenticateByLoginPasswordResponse *const*)ptr, "ns1:authenticateByLoginPasswordResponse");
	case SOAP_TYPE_PointerTons1__authenticateByLoginPassword:
		return soap_out_PointerTons1__authenticateByLoginPassword(soap, tag, id, (ns1__authenticateByLoginPassword *const*)ptr, "ns1:authenticateByLoginPassword");
	case SOAP_TYPE_PointerTons1__authenticateByKerberosResponse:
		return soap_out_PointerTons1__authenticateByKerberosResponse(soap, tag, id, (ns1__authenticateByKerberosResponse *const*)ptr, "ns1:authenticateByKerberosResponse");
	case SOAP_TYPE_PointerTons1__authenticateByKerberos:
		return soap_out_PointerTons1__authenticateByKerberos(soap, tag, id, (ns1__authenticateByKerberos *const*)ptr, "ns1:authenticateByKerberos");
	case SOAP_TYPE_PointerToPointerTons1__variable:
		return soap_out_PointerToPointerTons1__variable(soap, tag, id, (ns1__variable **const*)ptr, "ns1:variable");
	case SOAP_TYPE_PointerTons1__variable:
		return soap_out_PointerTons1__variable(soap, tag, id, (ns1__variable *const*)ptr, "ns1:variable");
	case SOAP_TYPE_PointerTo_ns1__userType_attributesMap_entry:
		return soap_out_PointerTo_ns1__userType_attributesMap_entry(soap, tag, id, (_ns1__userType_attributesMap_entry *const*)ptr, "ns1:userType-attributesMap-entry");
	case SOAP_TYPE_PointerToPointerTons1__variableDefinition:
		return soap_out_PointerToPointerTons1__variableDefinition(soap, tag, id, (ns1__variableDefinition **const*)ptr, "ns1:variableDefinition");
	case SOAP_TYPE_PointerTons1__variableDefinition:
		return soap_out_PointerTons1__variableDefinition(soap, tag, id, (ns1__variableDefinition *const*)ptr, "ns1:variableDefinition");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_out_PointerToxsd__anyType(soap, tag, id, (xsd__anyType *const*)ptr, "xsd:anyType");
	case SOAP_TYPE_PointerToPointerTons1__userType:
		return soap_out_PointerToPointerTons1__userType(soap, tag, id, (ns1__userType **const*)ptr, "ns1:userType");
	case SOAP_TYPE_PointerTons1__userType:
		return soap_out_PointerTons1__userType(soap, tag, id, (ns1__userType *const*)ptr, "ns1:userType");
	case SOAP_TYPE_PointerToPointerTons2__wfVariableStub:
		return soap_out_PointerToPointerTons2__wfVariableStub(soap, tag, id, (ns2__wfVariableStub **const*)ptr, "ns2:wfVariableStub");
	case SOAP_TYPE_PointerTons2__wfVariableStub:
		return soap_out_PointerTons2__wfVariableStub(soap, tag, id, (ns2__wfVariableStub *const*)ptr, "ns2:wfVariableStub");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTons1__wfExecutor:
		return soap_out_PointerTons1__wfExecutor(soap, tag, id, (ns1__wfExecutor *const*)ptr, "ns1:wfExecutor");
	case SOAP_TYPE_PointerToPointerTons1__wfTask:
		return soap_out_PointerToPointerTons1__wfTask(soap, tag, id, (ns1__wfTask **const*)ptr, "ns1:wfTask");
	case SOAP_TYPE_PointerTons1__wfTask:
		return soap_out_PointerTons1__wfTask(soap, tag, id, (ns1__wfTask *const*)ptr, "ns1:wfTask");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__classPresentationType:
		return soap_out_PointerTons1__classPresentationType(soap, tag, id, (enum ns1__classPresentationType *const*)ptr, "ns1:classPresentationType");
	case SOAP_TYPE_PointerToLONG64:
		return soap_out_PointerToLONG64(soap, tag, id, (LONG64 *const*)ptr, "xsd:long");
	case SOAP_TYPE_PointerTons1__batchPresentation:
		return soap_out_PointerTons1__batchPresentation(soap, tag, id, (ns1__batchPresentation *const*)ptr, "ns1:batchPresentation");
	case SOAP_TYPE_PointerTons1__actor:
		return soap_out_PointerTons1__actor(soap, tag, id, (ns1__actor *const*)ptr, "ns1:actor");
	case SOAP_TYPE_PointerTons1__user:
		return soap_out_PointerTons1__user(soap, tag, id, (ns1__user *const*)ptr, "ns1:user");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_out_PointerToxsd__base64Binary(soap, tag, id, (xsd__base64Binary *const*)ptr, "xsd:base64Binary");
	case SOAP_TYPE_wstring:
		return soap_out_wstring(soap, tag, id, (wchar_t*const*)&ptr, "xsd:string");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns1__userType_attributesMap_entry:
		((_ns1__userType_attributesMap_entry *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__userType_attributesMap:
		((_ns1__userType_attributesMap *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__classPresentationType_:
		((ns1__classPresentationType_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__wfVariableStub:
		((ns2__wfVariableStub *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__assignTaskResponse:
		((ns1__assignTaskResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__assignTask:
		((ns1__assignTask *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getTaskResponse:
		((ns1__getTaskResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getTask:
		((ns1__getTask *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getProcessTasksResponse:
		((ns1__getProcessTasksResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getProcessTasks:
		((ns1__getProcessTasks *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__completeTaskWSResponse:
		((ns1__completeTaskWSResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__variable:
		((ns1__variable *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__completeTaskWS:
		((ns1__completeTaskWS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getTasksResponse:
		((ns1__getTasksResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getTasks:
		((ns1__getTasks *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__reassignTasksResponse:
		((ns1__reassignTasksResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__reassignTasks:
		((ns1__reassignTasks *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__reassignTaskResponse:
		((ns1__reassignTaskResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__reassignTask:
		((ns1__reassignTask *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__markTaskOpenedResponse:
		((ns1__markTaskOpenedResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__markTaskOpened:
		((ns1__markTaskOpened *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__variableFormat:
		((ns1__variableFormat *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__userType:
		((ns1__userType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__variableDefinition:
		((ns1__variableDefinition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__wfTask:
		((ns1__wfTask *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getMyTasksResponse:
		((ns1__getMyTasksResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__batchPresentation:
		((ns1__batchPresentation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getMyTasks:
		((ns1__getMyTasks *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse:
		((ns1__authenticateByCallerPrincipalResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__authenticateByCallerPrincipal:
		((ns1__authenticateByCallerPrincipal *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse:
		((ns1__authenticateByTrustedPrincipalResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__authenticateByTrustedPrincipal:
		((ns1__authenticateByTrustedPrincipal *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__authenticateByLoginPasswordResponse:
		((ns1__authenticateByLoginPasswordResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__authenticateByLoginPassword:
		((ns1__authenticateByLoginPassword *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__wfExecutor:
		((ns1__wfExecutor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__identifiable:
		((ns1__identifiable *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__identifiableBase:
		((ns1__identifiableBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__executor:
		((ns1__executor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__actor:
		((ns1__actor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__user:
		((ns1__user *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__authenticateByKerberosResponse:
		((ns1__authenticateByKerberosResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__authenticateByKerberos:
		((ns1__authenticateByKerberos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__string:
		((xsd__string *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__long:
		((xsd__long *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__int:
		((xsd__int *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__dateTime:
		((xsd__dateTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__boolean:
		((xsd__boolean *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary_:
		((xsd__base64Binary_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anyType:
		((xsd__anyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__getTask:
		soap_serialize___ns1__getTask(soap, (const struct __ns1__getTask *)ptr);
		break;
	case SOAP_TYPE___ns1__assignTask:
		soap_serialize___ns1__assignTask(soap, (const struct __ns1__assignTask *)ptr);
		break;
	case SOAP_TYPE___ns1__assignTaskResponse:
		soap_serialize___ns1__assignTaskResponse(soap, (const struct __ns1__assignTaskResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__getProcessTasks:
		soap_serialize___ns1__getProcessTasks(soap, (const struct __ns1__getProcessTasks *)ptr);
		break;
	case SOAP_TYPE___ns1__completeTaskWS:
		soap_serialize___ns1__completeTaskWS(soap, (const struct __ns1__completeTaskWS *)ptr);
		break;
	case SOAP_TYPE___ns1__completeTaskWSResponse:
		soap_serialize___ns1__completeTaskWSResponse(soap, (const struct __ns1__completeTaskWSResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__getTasks:
		soap_serialize___ns1__getTasks(soap, (const struct __ns1__getTasks *)ptr);
		break;
	case SOAP_TYPE___ns1__reassignTasks:
		soap_serialize___ns1__reassignTasks(soap, (const struct __ns1__reassignTasks *)ptr);
		break;
	case SOAP_TYPE___ns1__reassignTask:
		soap_serialize___ns1__reassignTask(soap, (const struct __ns1__reassignTask *)ptr);
		break;
	case SOAP_TYPE___ns1__reassignTaskResponse:
		soap_serialize___ns1__reassignTaskResponse(soap, (const struct __ns1__reassignTaskResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__markTaskOpened:
		soap_serialize___ns1__markTaskOpened(soap, (const struct __ns1__markTaskOpened *)ptr);
		break;
	case SOAP_TYPE___ns1__markTaskOpenedResponse:
		soap_serialize___ns1__markTaskOpenedResponse(soap, (const struct __ns1__markTaskOpenedResponse *)ptr);
		break;
	case SOAP_TYPE___ns1__getMyTasks:
		soap_serialize___ns1__getMyTasks(soap, (const struct __ns1__getMyTasks *)ptr);
		break;
	case SOAP_TYPE___ns1__authenticateByCallerPrincipal:
		soap_serialize___ns1__authenticateByCallerPrincipal(soap, (const struct __ns1__authenticateByCallerPrincipal *)ptr);
		break;
	case SOAP_TYPE___ns1__authenticateByTrustedPrincipal:
		soap_serialize___ns1__authenticateByTrustedPrincipal(soap, (const struct __ns1__authenticateByTrustedPrincipal *)ptr);
		break;
	case SOAP_TYPE___ns1__authenticateByLoginPassword:
		soap_serialize___ns1__authenticateByLoginPassword(soap, (const struct __ns1__authenticateByLoginPassword *)ptr);
		break;
	case SOAP_TYPE___ns1__authenticateByKerberos:
		soap_serialize___ns1__authenticateByKerberos(soap, (const struct __ns1__authenticateByKerberos *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getTaskResponse:
		soap_serialize_PointerTons1__getTaskResponse(soap, (ns1__getTaskResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getTask:
		soap_serialize_PointerTons1__getTask(soap, (ns1__getTask *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__assignTaskResponse:
		soap_serialize_PointerTons1__assignTaskResponse(soap, (ns1__assignTaskResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__assignTask:
		soap_serialize_PointerTons1__assignTask(soap, (ns1__assignTask *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getProcessTasksResponse:
		soap_serialize_PointerTons1__getProcessTasksResponse(soap, (ns1__getProcessTasksResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getProcessTasks:
		soap_serialize_PointerTons1__getProcessTasks(soap, (ns1__getProcessTasks *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__completeTaskWSResponse:
		soap_serialize_PointerTons1__completeTaskWSResponse(soap, (ns1__completeTaskWSResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__completeTaskWS:
		soap_serialize_PointerTons1__completeTaskWS(soap, (ns1__completeTaskWS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getTasksResponse:
		soap_serialize_PointerTons1__getTasksResponse(soap, (ns1__getTasksResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getTasks:
		soap_serialize_PointerTons1__getTasks(soap, (ns1__getTasks *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__reassignTasksResponse:
		soap_serialize_PointerTons1__reassignTasksResponse(soap, (ns1__reassignTasksResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__reassignTasks:
		soap_serialize_PointerTons1__reassignTasks(soap, (ns1__reassignTasks *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__reassignTaskResponse:
		soap_serialize_PointerTons1__reassignTaskResponse(soap, (ns1__reassignTaskResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__reassignTask:
		soap_serialize_PointerTons1__reassignTask(soap, (ns1__reassignTask *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__markTaskOpenedResponse:
		soap_serialize_PointerTons1__markTaskOpenedResponse(soap, (ns1__markTaskOpenedResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__markTaskOpened:
		soap_serialize_PointerTons1__markTaskOpened(soap, (ns1__markTaskOpened *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getMyTasksResponse:
		soap_serialize_PointerTons1__getMyTasksResponse(soap, (ns1__getMyTasksResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getMyTasks:
		soap_serialize_PointerTons1__getMyTasks(soap, (ns1__getMyTasks *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__authenticateByCallerPrincipalResponse:
		soap_serialize_PointerTons1__authenticateByCallerPrincipalResponse(soap, (ns1__authenticateByCallerPrincipalResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__authenticateByCallerPrincipal:
		soap_serialize_PointerTons1__authenticateByCallerPrincipal(soap, (ns1__authenticateByCallerPrincipal *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__authenticateByTrustedPrincipalResponse:
		soap_serialize_PointerTons1__authenticateByTrustedPrincipalResponse(soap, (ns1__authenticateByTrustedPrincipalResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__authenticateByTrustedPrincipal:
		soap_serialize_PointerTons1__authenticateByTrustedPrincipal(soap, (ns1__authenticateByTrustedPrincipal *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__authenticateByLoginPasswordResponse:
		soap_serialize_PointerTons1__authenticateByLoginPasswordResponse(soap, (ns1__authenticateByLoginPasswordResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__authenticateByLoginPassword:
		soap_serialize_PointerTons1__authenticateByLoginPassword(soap, (ns1__authenticateByLoginPassword *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__authenticateByKerberosResponse:
		soap_serialize_PointerTons1__authenticateByKerberosResponse(soap, (ns1__authenticateByKerberosResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__authenticateByKerberos:
		soap_serialize_PointerTons1__authenticateByKerberos(soap, (ns1__authenticateByKerberos *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__variable:
		soap_serialize_PointerToPointerTons1__variable(soap, (ns1__variable **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__variable:
		soap_serialize_PointerTons1__variable(soap, (ns1__variable *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__userType_attributesMap_entry:
		soap_serialize_PointerTo_ns1__userType_attributesMap_entry(soap, (_ns1__userType_attributesMap_entry *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__variableDefinition:
		soap_serialize_PointerToPointerTons1__variableDefinition(soap, (ns1__variableDefinition **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__variableDefinition:
		soap_serialize_PointerTons1__variableDefinition(soap, (ns1__variableDefinition *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyType:
		soap_serialize_PointerToxsd__anyType(soap, (xsd__anyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__userType:
		soap_serialize_PointerToPointerTons1__userType(soap, (ns1__userType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__userType:
		soap_serialize_PointerTons1__userType(soap, (ns1__userType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons2__wfVariableStub:
		soap_serialize_PointerToPointerTons2__wfVariableStub(soap, (ns2__wfVariableStub **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__wfVariableStub:
		soap_serialize_PointerTons2__wfVariableStub(soap, (ns2__wfVariableStub *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__wfExecutor:
		soap_serialize_PointerTons1__wfExecutor(soap, (ns1__wfExecutor *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__wfTask:
		soap_serialize_PointerToPointerTons1__wfTask(soap, (ns1__wfTask **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__wfTask:
		soap_serialize_PointerTons1__wfTask(soap, (ns1__wfTask *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__classPresentationType:
		soap_serialize_PointerTons1__classPresentationType(soap, (enum ns1__classPresentationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToLONG64:
		soap_serialize_PointerToLONG64(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__batchPresentation:
		soap_serialize_PointerTons1__batchPresentation(soap, (ns1__batchPresentation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__actor:
		soap_serialize_PointerTons1__actor(soap, (ns1__actor *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__user:
		soap_serialize_PointerTons1__user(soap, (ns1__user *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__base64Binary:
		soap_serialize_PointerToxsd__base64Binary(soap, (xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_wstring:
		soap_serialize_wstring(soap, (wchar_t*const*)&ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_xsd__anyType:
		return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary_:
		return (void*)soap_instantiate_xsd__base64Binary_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__boolean:
		return (void*)soap_instantiate_xsd__boolean(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__dateTime:
		return (void*)soap_instantiate_xsd__dateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__int:
		return (void*)soap_instantiate_xsd__int(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__long:
		return (void*)soap_instantiate_xsd__long(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__string:
		return (void*)soap_instantiate_xsd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__classPresentationType_:
		return (void*)soap_instantiate_ns1__classPresentationType_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__authenticateByKerberos:
		return (void*)soap_instantiate_ns1__authenticateByKerberos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__authenticateByKerberosResponse:
		return (void*)soap_instantiate_ns1__authenticateByKerberosResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__user:
		return (void*)soap_instantiate_ns1__user(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__identifiable:
		return (void*)soap_instantiate_ns1__identifiable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__authenticateByLoginPassword:
		return (void*)soap_instantiate_ns1__authenticateByLoginPassword(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__authenticateByLoginPasswordResponse:
		return (void*)soap_instantiate_ns1__authenticateByLoginPasswordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__authenticateByTrustedPrincipal:
		return (void*)soap_instantiate_ns1__authenticateByTrustedPrincipal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse:
		return (void*)soap_instantiate_ns1__authenticateByTrustedPrincipalResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__authenticateByCallerPrincipal:
		return (void*)soap_instantiate_ns1__authenticateByCallerPrincipal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse:
		return (void*)soap_instantiate_ns1__authenticateByCallerPrincipalResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getMyTasks:
		return (void*)soap_instantiate_ns1__getMyTasks(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__batchPresentation:
		return (void*)soap_instantiate_ns1__batchPresentation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getMyTasksResponse:
		return (void*)soap_instantiate_ns1__getMyTasksResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__wfTask:
		return (void*)soap_instantiate_ns1__wfTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__variableDefinition:
		return (void*)soap_instantiate_ns1__variableDefinition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__userType_attributesMap_entry:
		return (void*)soap_instantiate__ns1__userType_attributesMap_entry(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__userType_attributesMap:
		return (void*)soap_instantiate__ns1__userType_attributesMap(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__userType:
		return (void*)soap_instantiate_ns1__userType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__variableFormat:
		return (void*)soap_instantiate_ns1__variableFormat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__markTaskOpened:
		return (void*)soap_instantiate_ns1__markTaskOpened(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__markTaskOpenedResponse:
		return (void*)soap_instantiate_ns1__markTaskOpenedResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__reassignTask:
		return (void*)soap_instantiate_ns1__reassignTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__reassignTaskResponse:
		return (void*)soap_instantiate_ns1__reassignTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__reassignTasks:
		return (void*)soap_instantiate_ns1__reassignTasks(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__reassignTasksResponse:
		return (void*)soap_instantiate_ns1__reassignTasksResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTasks:
		return (void*)soap_instantiate_ns1__getTasks(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTasksResponse:
		return (void*)soap_instantiate_ns1__getTasksResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__completeTaskWS:
		return (void*)soap_instantiate_ns1__completeTaskWS(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__variable:
		return (void*)soap_instantiate_ns1__variable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__completeTaskWSResponse:
		return (void*)soap_instantiate_ns1__completeTaskWSResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProcessTasks:
		return (void*)soap_instantiate_ns1__getProcessTasks(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProcessTasksResponse:
		return (void*)soap_instantiate_ns1__getProcessTasksResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTask:
		return (void*)soap_instantiate_ns1__getTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTaskResponse:
		return (void*)soap_instantiate_ns1__getTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__assignTask:
		return (void*)soap_instantiate_ns1__assignTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__assignTaskResponse:
		return (void*)soap_instantiate_ns1__assignTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__wfVariableStub:
		return (void*)soap_instantiate_ns2__wfVariableStub(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__identifiableBase:
		return (void*)soap_instantiate_ns1__identifiableBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__executor:
		return (void*)soap_instantiate_ns1__executor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__actor:
		return (void*)soap_instantiate_ns1__actor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__wfExecutor:
		return (void*)soap_instantiate_ns1__wfExecutor(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__authenticateByKerberos:
		return (void*)soap_instantiate___ns1__authenticateByKerberos(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__authenticateByLoginPassword:
		return (void*)soap_instantiate___ns1__authenticateByLoginPassword(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__authenticateByTrustedPrincipal:
		return (void*)soap_instantiate___ns1__authenticateByTrustedPrincipal(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__authenticateByCallerPrincipal:
		return (void*)soap_instantiate___ns1__authenticateByCallerPrincipal(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getMyTasks:
		return (void*)soap_instantiate___ns1__getMyTasks(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__markTaskOpenedResponse:
		return (void*)soap_instantiate___ns1__markTaskOpenedResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__markTaskOpened:
		return (void*)soap_instantiate___ns1__markTaskOpened(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__reassignTaskResponse:
		return (void*)soap_instantiate___ns1__reassignTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__reassignTask:
		return (void*)soap_instantiate___ns1__reassignTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__reassignTasks:
		return (void*)soap_instantiate___ns1__reassignTasks(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getTasks:
		return (void*)soap_instantiate___ns1__getTasks(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__completeTaskWSResponse:
		return (void*)soap_instantiate___ns1__completeTaskWSResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__completeTaskWS:
		return (void*)soap_instantiate___ns1__completeTaskWS(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getProcessTasks:
		return (void*)soap_instantiate___ns1__getProcessTasks(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__assignTaskResponse:
		return (void*)soap_instantiate___ns1__assignTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__assignTask:
		return (void*)soap_instantiate___ns1__assignTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getTask:
		return (void*)soap_instantiate___ns1__getTask(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xsd__anyType:
		if (p->size < 0)
			SOAP_DELETE((xsd__anyType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__anyType*)p->ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			SOAP_DELETE((xsd__base64Binary*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__base64Binary*)p->ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary_:
		if (p->size < 0)
			SOAP_DELETE((xsd__base64Binary_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__base64Binary_*)p->ptr);
		break;
	case SOAP_TYPE_xsd__boolean:
		if (p->size < 0)
			SOAP_DELETE((xsd__boolean*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__boolean*)p->ptr);
		break;
	case SOAP_TYPE_xsd__dateTime:
		if (p->size < 0)
			SOAP_DELETE((xsd__dateTime*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__dateTime*)p->ptr);
		break;
	case SOAP_TYPE_xsd__int:
		if (p->size < 0)
			SOAP_DELETE((xsd__int*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__int*)p->ptr);
		break;
	case SOAP_TYPE_xsd__long:
		if (p->size < 0)
			SOAP_DELETE((xsd__long*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__long*)p->ptr);
		break;
	case SOAP_TYPE_xsd__string:
		if (p->size < 0)
			SOAP_DELETE((xsd__string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__string*)p->ptr);
		break;
	case SOAP_TYPE_ns1__classPresentationType_:
		if (p->size < 0)
			SOAP_DELETE((ns1__classPresentationType_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__classPresentationType_*)p->ptr);
		break;
	case SOAP_TYPE_ns1__authenticateByKerberos:
		if (p->size < 0)
			SOAP_DELETE((ns1__authenticateByKerberos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__authenticateByKerberos*)p->ptr);
		break;
	case SOAP_TYPE_ns1__authenticateByKerberosResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__authenticateByKerberosResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__authenticateByKerberosResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__user:
		if (p->size < 0)
			SOAP_DELETE((ns1__user*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__user*)p->ptr);
		break;
	case SOAP_TYPE_ns1__identifiable:
		if (p->size < 0)
			SOAP_DELETE((ns1__identifiable*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__identifiable*)p->ptr);
		break;
	case SOAP_TYPE_ns1__authenticateByLoginPassword:
		if (p->size < 0)
			SOAP_DELETE((ns1__authenticateByLoginPassword*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__authenticateByLoginPassword*)p->ptr);
		break;
	case SOAP_TYPE_ns1__authenticateByLoginPasswordResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__authenticateByLoginPasswordResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__authenticateByLoginPasswordResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__authenticateByTrustedPrincipal:
		if (p->size < 0)
			SOAP_DELETE((ns1__authenticateByTrustedPrincipal*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__authenticateByTrustedPrincipal*)p->ptr);
		break;
	case SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__authenticateByTrustedPrincipalResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__authenticateByTrustedPrincipalResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__authenticateByCallerPrincipal:
		if (p->size < 0)
			SOAP_DELETE((ns1__authenticateByCallerPrincipal*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__authenticateByCallerPrincipal*)p->ptr);
		break;
	case SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__authenticateByCallerPrincipalResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__authenticateByCallerPrincipalResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getMyTasks:
		if (p->size < 0)
			SOAP_DELETE((ns1__getMyTasks*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getMyTasks*)p->ptr);
		break;
	case SOAP_TYPE_ns1__batchPresentation:
		if (p->size < 0)
			SOAP_DELETE((ns1__batchPresentation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__batchPresentation*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getMyTasksResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getMyTasksResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getMyTasksResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__wfTask:
		if (p->size < 0)
			SOAP_DELETE((ns1__wfTask*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__wfTask*)p->ptr);
		break;
	case SOAP_TYPE_ns1__variableDefinition:
		if (p->size < 0)
			SOAP_DELETE((ns1__variableDefinition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__variableDefinition*)p->ptr);
		break;
	case SOAP_TYPE__ns1__userType_attributesMap_entry:
		if (p->size < 0)
			SOAP_DELETE((_ns1__userType_attributesMap_entry*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__userType_attributesMap_entry*)p->ptr);
		break;
	case SOAP_TYPE__ns1__userType_attributesMap:
		if (p->size < 0)
			SOAP_DELETE((_ns1__userType_attributesMap*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__userType_attributesMap*)p->ptr);
		break;
	case SOAP_TYPE_ns1__userType:
		if (p->size < 0)
			SOAP_DELETE((ns1__userType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__userType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__variableFormat:
		if (p->size < 0)
			SOAP_DELETE((ns1__variableFormat*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__variableFormat*)p->ptr);
		break;
	case SOAP_TYPE_ns1__markTaskOpened:
		if (p->size < 0)
			SOAP_DELETE((ns1__markTaskOpened*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__markTaskOpened*)p->ptr);
		break;
	case SOAP_TYPE_ns1__markTaskOpenedResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__markTaskOpenedResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__markTaskOpenedResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__reassignTask:
		if (p->size < 0)
			SOAP_DELETE((ns1__reassignTask*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__reassignTask*)p->ptr);
		break;
	case SOAP_TYPE_ns1__reassignTaskResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__reassignTaskResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__reassignTaskResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__reassignTasks:
		if (p->size < 0)
			SOAP_DELETE((ns1__reassignTasks*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__reassignTasks*)p->ptr);
		break;
	case SOAP_TYPE_ns1__reassignTasksResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__reassignTasksResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__reassignTasksResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTasks:
		if (p->size < 0)
			SOAP_DELETE((ns1__getTasks*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getTasks*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTasksResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getTasksResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getTasksResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__completeTaskWS:
		if (p->size < 0)
			SOAP_DELETE((ns1__completeTaskWS*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__completeTaskWS*)p->ptr);
		break;
	case SOAP_TYPE_ns1__variable:
		if (p->size < 0)
			SOAP_DELETE((ns1__variable*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__variable*)p->ptr);
		break;
	case SOAP_TYPE_ns1__completeTaskWSResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__completeTaskWSResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__completeTaskWSResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProcessTasks:
		if (p->size < 0)
			SOAP_DELETE((ns1__getProcessTasks*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getProcessTasks*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProcessTasksResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getProcessTasksResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getProcessTasksResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTask:
		if (p->size < 0)
			SOAP_DELETE((ns1__getTask*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getTask*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTaskResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getTaskResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getTaskResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__assignTask:
		if (p->size < 0)
			SOAP_DELETE((ns1__assignTask*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__assignTask*)p->ptr);
		break;
	case SOAP_TYPE_ns1__assignTaskResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__assignTaskResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__assignTaskResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__wfVariableStub:
		if (p->size < 0)
			SOAP_DELETE((ns2__wfVariableStub*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__wfVariableStub*)p->ptr);
		break;
	case SOAP_TYPE_ns1__identifiableBase:
		if (p->size < 0)
			SOAP_DELETE((ns1__identifiableBase*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__identifiableBase*)p->ptr);
		break;
	case SOAP_TYPE_ns1__executor:
		if (p->size < 0)
			SOAP_DELETE((ns1__executor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__executor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__actor:
		if (p->size < 0)
			SOAP_DELETE((ns1__actor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__actor*)p->ptr);
		break;
	case SOAP_TYPE_ns1__wfExecutor:
		if (p->size < 0)
			SOAP_DELETE((ns1__wfExecutor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__wfExecutor*)p->ptr);
		break;
	case SOAP_TYPE___ns1__authenticateByKerberos:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__authenticateByKerberos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__authenticateByKerberos*)p->ptr);
		break;
	case SOAP_TYPE___ns1__authenticateByLoginPassword:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__authenticateByLoginPassword*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__authenticateByLoginPassword*)p->ptr);
		break;
	case SOAP_TYPE___ns1__authenticateByTrustedPrincipal:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__authenticateByTrustedPrincipal*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__authenticateByTrustedPrincipal*)p->ptr);
		break;
	case SOAP_TYPE___ns1__authenticateByCallerPrincipal:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__authenticateByCallerPrincipal*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__authenticateByCallerPrincipal*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getMyTasks:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getMyTasks*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getMyTasks*)p->ptr);
		break;
	case SOAP_TYPE___ns1__markTaskOpenedResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__markTaskOpenedResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__markTaskOpenedResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__markTaskOpened:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__markTaskOpened*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__markTaskOpened*)p->ptr);
		break;
	case SOAP_TYPE___ns1__reassignTaskResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__reassignTaskResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__reassignTaskResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__reassignTask:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__reassignTask*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__reassignTask*)p->ptr);
		break;
	case SOAP_TYPE___ns1__reassignTasks:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__reassignTasks*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__reassignTasks*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getTasks:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getTasks*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getTasks*)p->ptr);
		break;
	case SOAP_TYPE___ns1__completeTaskWSResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__completeTaskWSResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__completeTaskWSResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__completeTaskWS:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__completeTaskWS*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__completeTaskWS*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getProcessTasks:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getProcessTasks*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getProcessTasks*)p->ptr);
		break;
	case SOAP_TYPE___ns1__assignTaskResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__assignTaskResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__assignTaskResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__assignTask:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__assignTask*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__assignTask*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getTask:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getTask*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getTask*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__classPresentationType(struct soap *soap, enum ns1__classPresentationType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__classPresentationType
	*a = SOAP_DEFAULT_ns1__classPresentationType;
#else
	*a = (enum ns1__classPresentationType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__classPresentationType[] =
{	{ (long)ns1__classPresentationType__NONE, "NONE" },
	{ (long)ns1__classPresentationType__SYSTEM_USCORELOG, "SYSTEM_LOG" },
	{ (long)ns1__classPresentationType__EXECUTOR, "EXECUTOR" },
	{ (long)ns1__classPresentationType__ACTOR, "ACTOR" },
	{ (long)ns1__classPresentationType__GROUP, "GROUP" },
	{ (long)ns1__classPresentationType__RELATION, "RELATION" },
	{ (long)ns1__classPresentationType__RELATIONPAIR, "RELATIONPAIR" },
	{ (long)ns1__classPresentationType__DEFINITION, "DEFINITION" },
	{ (long)ns1__classPresentationType__DEFINITION_USCOREHISTORY, "DEFINITION_HISTORY" },
	{ (long)ns1__classPresentationType__PROCESS, "PROCESS" },
	{ (long)ns1__classPresentationType__TASK, "TASK" },
	{ (long)ns1__classPresentationType__REPORTS, "REPORTS" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__classPresentationType2s(struct soap *soap, enum ns1__classPresentationType n)
{	const char *s = soap_code_str(soap_codes_ns1__classPresentationType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__classPresentationType(struct soap *soap, const char *tag, int id, const enum ns1__classPresentationType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__classPresentationType), type) || soap_send(soap, soap_ns1__classPresentationType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__classPresentationType(struct soap *soap, const char *s, enum ns1__classPresentationType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__classPresentationType, s);
	if (map)
		*a = (enum ns1__classPresentationType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 11)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__classPresentationType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__classPresentationType * SOAP_FMAC4 soap_in_ns1__classPresentationType(struct soap *soap, const char *tag, enum ns1__classPresentationType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__classPresentationType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__classPresentationType, sizeof(enum ns1__classPresentationType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__classPresentationType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__classPresentationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__classPresentationType, 0, sizeof(enum ns1__classPresentationType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__classPresentationType(struct soap *soap, const enum ns1__classPresentationType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__classPresentationType);
	if (soap_out_ns1__classPresentationType(soap, tag?tag:"ns1:classPresentationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__classPresentationType * SOAP_FMAC4 soap_get_ns1__classPresentationType(struct soap *soap, enum ns1__classPresentationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__classPresentationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__userType_attributesMap_entry::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns1__userType_attributesMap_entry::key = NULL;
	this->_ns1__userType_attributesMap_entry::value = NULL;
}

void _ns1__userType_attributesMap_entry::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->_ns1__userType_attributesMap_entry::key);
	soap_serialize_PointerTons1__variableDefinition(soap, &this->_ns1__userType_attributesMap_entry::value);
#endif
}

int _ns1__userType_attributesMap_entry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__userType_attributesMap_entry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__userType_attributesMap_entry(struct soap *soap, const char *tag, int id, const _ns1__userType_attributesMap_entry *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__userType_attributesMap_entry), type))
		return soap->error;
	if (soap_out_wstring(soap, "key", -1, &(a->_ns1__userType_attributesMap_entry::key), ""))
		return soap->error;
	if (soap_out_PointerTons1__variableDefinition(soap, "value", -1, &(a->_ns1__userType_attributesMap_entry::value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__userType_attributesMap_entry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__userType_attributesMap_entry(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__userType_attributesMap_entry * SOAP_FMAC4 soap_in__ns1__userType_attributesMap_entry(struct soap *soap, const char *tag, _ns1__userType_attributesMap_entry *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__userType_attributesMap_entry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__userType_attributesMap_entry, sizeof(_ns1__userType_attributesMap_entry), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__userType_attributesMap_entry)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__userType_attributesMap_entry *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_key1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "key", &(a->_ns1__userType_attributesMap_entry::key), "xsd:string"))
				{	soap_flag_key1--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__variableDefinition(soap, "value", &(a->_ns1__userType_attributesMap_entry::value), "ns1:variableDefinition"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__userType_attributesMap_entry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__userType_attributesMap_entry, 0, sizeof(_ns1__userType_attributesMap_entry), 0, soap_copy__ns1__userType_attributesMap_entry);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__userType_attributesMap_entry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__userType_attributesMap_entry);
	if (this->soap_out(soap, tag?tag:"ns1:userType-attributesMap-entry", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__userType_attributesMap_entry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__userType_attributesMap_entry(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__userType_attributesMap_entry * SOAP_FMAC4 soap_get__ns1__userType_attributesMap_entry(struct soap *soap, _ns1__userType_attributesMap_entry *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__userType_attributesMap_entry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__userType_attributesMap_entry * SOAP_FMAC2 soap_instantiate__ns1__userType_attributesMap_entry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__userType_attributesMap_entry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__userType_attributesMap_entry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__userType_attributesMap_entry);
		if (size)
			*size = sizeof(_ns1__userType_attributesMap_entry);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__userType_attributesMap_entry, n);
		if (size)
			*size = n * sizeof(_ns1__userType_attributesMap_entry);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__userType_attributesMap_entry*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__userType_attributesMap_entry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__userType_attributesMap_entry %p -> %p\n", q, p));
	*(_ns1__userType_attributesMap_entry*)p = *(_ns1__userType_attributesMap_entry*)q;
}

void _ns1__userType_attributesMap::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns1__userType_attributesMap::__sizeentry = 0;
	this->_ns1__userType_attributesMap::entry = NULL;
}

void _ns1__userType_attributesMap::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->_ns1__userType_attributesMap::entry)
	{	int i;
		for (i = 0; i < this->_ns1__userType_attributesMap::__sizeentry; i++)
		{
			soap_embedded(soap, this->_ns1__userType_attributesMap::entry + i, SOAP_TYPE__ns1__userType_attributesMap_entry);
			this->_ns1__userType_attributesMap::entry[i].soap_serialize(soap);
		}
	}
#endif
}

int _ns1__userType_attributesMap::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__userType_attributesMap(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__userType_attributesMap(struct soap *soap, const char *tag, int id, const _ns1__userType_attributesMap *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__userType_attributesMap), type))
		return soap->error;
	if (a->_ns1__userType_attributesMap::entry)
	{	int i;
		for (i = 0; i < a->_ns1__userType_attributesMap::__sizeentry; i++)
			if (a->_ns1__userType_attributesMap::entry[i].soap_out(soap, "entry", -1, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *_ns1__userType_attributesMap::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__userType_attributesMap(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__userType_attributesMap * SOAP_FMAC4 soap_in__ns1__userType_attributesMap(struct soap *soap, const char *tag, _ns1__userType_attributesMap *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__userType_attributesMap *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__userType_attributesMap, sizeof(_ns1__userType_attributesMap), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__userType_attributesMap)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__userType_attributesMap *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_entry1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "entry", 1, NULL))
			{	if (a->_ns1__userType_attributesMap::entry == NULL)
				{	if (soap_blist_entry1 == NULL)
						soap_blist_entry1 = soap_new_block(soap);
					a->_ns1__userType_attributesMap::entry = (_ns1__userType_attributesMap_entry *)soap_push_block(soap, soap_blist_entry1, sizeof(_ns1__userType_attributesMap_entry));
					if (a->_ns1__userType_attributesMap::entry == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->_ns1__userType_attributesMap::entry, _ns1__userType_attributesMap_entry);
					a->_ns1__userType_attributesMap::entry->soap_default(soap);
				}
				soap_revert(soap);
				if (soap_in__ns1__userType_attributesMap_entry(soap, "entry", a->_ns1__userType_attributesMap::entry, ""))
				{	a->_ns1__userType_attributesMap::__sizeentry++;
					a->_ns1__userType_attributesMap::entry = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_ns1__userType_attributesMap::entry)
			soap_pop_block(soap, soap_blist_entry1);
		if (a->_ns1__userType_attributesMap::__sizeentry)
			a->_ns1__userType_attributesMap::entry = (_ns1__userType_attributesMap_entry *)soap_save_block(soap, soap_blist_entry1, NULL, 1);
		else
		{	a->_ns1__userType_attributesMap::entry = NULL;
			if (soap_blist_entry1)
				soap_end_block(soap, soap_blist_entry1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__userType_attributesMap *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__userType_attributesMap, 0, sizeof(_ns1__userType_attributesMap), 0, soap_copy__ns1__userType_attributesMap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__userType_attributesMap::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__userType_attributesMap);
	if (this->soap_out(soap, tag?tag:"ns1:userType-attributesMap", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__userType_attributesMap::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__userType_attributesMap(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__userType_attributesMap * SOAP_FMAC4 soap_get__ns1__userType_attributesMap(struct soap *soap, _ns1__userType_attributesMap *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__userType_attributesMap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__userType_attributesMap * SOAP_FMAC2 soap_instantiate__ns1__userType_attributesMap(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__userType_attributesMap(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__userType_attributesMap, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__userType_attributesMap);
		if (size)
			*size = sizeof(_ns1__userType_attributesMap);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__userType_attributesMap, n);
		if (size)
			*size = n * sizeof(_ns1__userType_attributesMap);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__userType_attributesMap*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__userType_attributesMap(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__userType_attributesMap %p -> %p\n", q, p));
	*(_ns1__userType_attributesMap*)p = *(_ns1__userType_attributesMap*)q;
}

void ns1__classPresentationType_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_ns1__classPresentationType(soap, &this->ns1__classPresentationType_::__item);
}

void ns1__classPresentationType_::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__classPresentationType_::__item, SOAP_TYPE_ns1__classPresentationType);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__classPresentationType_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__classPresentationType_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__classPresentationType_(struct soap *soap, const char *tag, int id, const ns1__classPresentationType_ *a, const char *type)
{
	return soap_out_ns1__classPresentationType(soap, tag, id, &(a->ns1__classPresentationType_::__item), "ns1:classPresentationType");
}

void *ns1__classPresentationType_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__classPresentationType_(soap, tag, this, type);
}

SOAP_FMAC3 ns1__classPresentationType_ * SOAP_FMAC4 soap_in_ns1__classPresentationType_(struct soap *soap, const char *tag, ns1__classPresentationType_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__classPresentationType_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__classPresentationType_, sizeof(ns1__classPresentationType_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__classPresentationType_)
			return (ns1__classPresentationType_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns1__classPresentationType(soap, tag, &(a->ns1__classPresentationType_::__item), "ns1:classPresentationType"))
		return NULL;
	return a;
}

int ns1__classPresentationType_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__classPresentationType_);
	if (this->soap_out(soap, tag?tag:"ns1:classPresentationType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__classPresentationType_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__classPresentationType_(soap, this, tag, type);
}

SOAP_FMAC3 ns1__classPresentationType_ * SOAP_FMAC4 soap_get_ns1__classPresentationType_(struct soap *soap, ns1__classPresentationType_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__classPresentationType_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__classPresentationType_ * SOAP_FMAC2 soap_instantiate_ns1__classPresentationType_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__classPresentationType_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__classPresentationType_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__classPresentationType_);
		if (size)
			*size = sizeof(ns1__classPresentationType_);
		((ns1__classPresentationType_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__classPresentationType_, n);
		if (size)
			*size = n * sizeof(ns1__classPresentationType_);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__classPresentationType_*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__classPresentationType_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__classPresentationType_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__classPresentationType_ %p -> %p\n", q, p));
	*(ns1__classPresentationType_*)p = *(ns1__classPresentationType_*)q;
}

void ns2__wfVariableStub::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns2__wfVariableStub::definition = NULL;
	this->ns2__wfVariableStub::value = NULL;
}

void ns2__wfVariableStub::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__variableDefinition(soap, &this->ns2__wfVariableStub::definition);
	soap_serialize_PointerToxsd__anyType(soap, &this->ns2__wfVariableStub::value);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns2__wfVariableStub::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__wfVariableStub(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__wfVariableStub(struct soap *soap, const char *tag, int id, const ns2__wfVariableStub *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__wfVariableStub), "ns2:wfVariableStub"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__variableDefinition(soap, "definition", -1, &(a->ns2__wfVariableStub::definition), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "value", -1, &(a->ns2__wfVariableStub::value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__wfVariableStub::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__wfVariableStub(soap, tag, this, type);
}

SOAP_FMAC3 ns2__wfVariableStub * SOAP_FMAC4 soap_in_ns2__wfVariableStub(struct soap *soap, const char *tag, ns2__wfVariableStub *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__wfVariableStub *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__wfVariableStub, sizeof(ns2__wfVariableStub), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__wfVariableStub)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__wfVariableStub *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_definition1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_definition1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__variableDefinition(soap, "definition", &(a->ns2__wfVariableStub::definition), "ns1:variableDefinition"))
				{	soap_flag_definition1--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "value", &(a->ns2__wfVariableStub::value), "xsd:anyType"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__wfVariableStub *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__wfVariableStub, 0, sizeof(ns2__wfVariableStub), 0, soap_copy_ns2__wfVariableStub);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__wfVariableStub::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__wfVariableStub);
	if (this->soap_out(soap, tag?tag:"ns2:wfVariableStub", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__wfVariableStub::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__wfVariableStub(soap, this, tag, type);
}

SOAP_FMAC3 ns2__wfVariableStub * SOAP_FMAC4 soap_get_ns2__wfVariableStub(struct soap *soap, ns2__wfVariableStub *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__wfVariableStub(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__wfVariableStub * SOAP_FMAC2 soap_instantiate_ns2__wfVariableStub(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__wfVariableStub(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__wfVariableStub, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__wfVariableStub);
		if (size)
			*size = sizeof(ns2__wfVariableStub);
		((ns2__wfVariableStub*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__wfVariableStub, n);
		if (size)
			*size = n * sizeof(ns2__wfVariableStub);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__wfVariableStub*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__wfVariableStub*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__wfVariableStub(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__wfVariableStub %p -> %p\n", q, p));
	*(ns2__wfVariableStub*)p = *(ns2__wfVariableStub*)q;
}

void ns1__assignTaskResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void ns1__assignTaskResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__assignTaskResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__assignTaskResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__assignTaskResponse(struct soap *soap, const char *tag, int id, const ns1__assignTaskResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:assignTaskResponse");
}

void *ns1__assignTaskResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__assignTaskResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__assignTaskResponse * SOAP_FMAC4 soap_in_ns1__assignTaskResponse(struct soap *soap, const char *tag, ns1__assignTaskResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__assignTaskResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__assignTaskResponse, sizeof(ns1__assignTaskResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__assignTaskResponse)
			return (ns1__assignTaskResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__assignTaskResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__assignTaskResponse);
	if (this->soap_out(soap, tag?tag:"ns1:assignTaskResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__assignTaskResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__assignTaskResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__assignTaskResponse * SOAP_FMAC4 soap_get_ns1__assignTaskResponse(struct soap *soap, ns1__assignTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__assignTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__assignTaskResponse * SOAP_FMAC2 soap_instantiate_ns1__assignTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__assignTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__assignTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__assignTaskResponse);
		if (size)
			*size = sizeof(ns1__assignTaskResponse);
		((ns1__assignTaskResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__assignTaskResponse, n);
		if (size)
			*size = n * sizeof(ns1__assignTaskResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__assignTaskResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__assignTaskResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__assignTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__assignTaskResponse %p -> %p\n", q, p));
	*(ns1__assignTaskResponse*)p = *(ns1__assignTaskResponse*)q;
}

void ns1__assignTask::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__assignTask::user = NULL;
	this->ns1__assignTask::taskId = NULL;
	this->ns1__assignTask::previousOwner = NULL;
	this->ns1__assignTask::newExecutor = NULL;
}

void ns1__assignTask::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__assignTask::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__assignTask::taskId);
	soap_serialize_PointerTons1__wfExecutor(soap, &this->ns1__assignTask::previousOwner);
	soap_serialize_PointerTons1__wfExecutor(soap, &this->ns1__assignTask::newExecutor);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__assignTask::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__assignTask(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__assignTask(struct soap *soap, const char *tag, int id, const ns1__assignTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__assignTask), "ns1:assignTask"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__assignTask::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "taskId", -1, &(a->ns1__assignTask::taskId), ""))
		return soap->error;
	if (soap_out_PointerTons1__wfExecutor(soap, "previousOwner", -1, &(a->ns1__assignTask::previousOwner), ""))
		return soap->error;
	if (soap_out_PointerTons1__wfExecutor(soap, "newExecutor", -1, &(a->ns1__assignTask::newExecutor), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__assignTask::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__assignTask(soap, tag, this, type);
}

SOAP_FMAC3 ns1__assignTask * SOAP_FMAC4 soap_in_ns1__assignTask(struct soap *soap, const char *tag, ns1__assignTask *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__assignTask *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__assignTask, sizeof(ns1__assignTask), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__assignTask)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__assignTask *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_taskId1 = 1;
	size_t soap_flag_previousOwner1 = 1;
	size_t soap_flag_newExecutor1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__assignTask::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_taskId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "taskId", &(a->ns1__assignTask::taskId), "xsd:long"))
				{	soap_flag_taskId1--;
					continue;
				}
			if (soap_flag_previousOwner1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__wfExecutor(soap, "previousOwner", &(a->ns1__assignTask::previousOwner), "ns1:wfExecutor"))
				{	soap_flag_previousOwner1--;
					continue;
				}
			if (soap_flag_newExecutor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__wfExecutor(soap, "newExecutor", &(a->ns1__assignTask::newExecutor), "ns1:wfExecutor"))
				{	soap_flag_newExecutor1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__assignTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__assignTask, 0, sizeof(ns1__assignTask), 0, soap_copy_ns1__assignTask);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__assignTask::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__assignTask);
	if (this->soap_out(soap, tag?tag:"ns1:assignTask", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__assignTask::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__assignTask(soap, this, tag, type);
}

SOAP_FMAC3 ns1__assignTask * SOAP_FMAC4 soap_get_ns1__assignTask(struct soap *soap, ns1__assignTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__assignTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__assignTask * SOAP_FMAC2 soap_instantiate_ns1__assignTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__assignTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__assignTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__assignTask);
		if (size)
			*size = sizeof(ns1__assignTask);
		((ns1__assignTask*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__assignTask, n);
		if (size)
			*size = n * sizeof(ns1__assignTask);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__assignTask*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__assignTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__assignTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__assignTask %p -> %p\n", q, p));
	*(ns1__assignTask*)p = *(ns1__assignTask*)q;
}

void ns1__getTaskResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getTaskResponse::result = NULL;
}

void ns1__getTaskResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__wfTask(soap, &this->ns1__getTaskResponse::result);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getTaskResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getTaskResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTaskResponse(struct soap *soap, const char *tag, int id, const ns1__getTaskResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTaskResponse), "ns1:getTaskResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__wfTask(soap, "result", -1, &(a->ns1__getTaskResponse::result), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getTaskResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getTaskResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getTaskResponse * SOAP_FMAC4 soap_in_ns1__getTaskResponse(struct soap *soap, const char *tag, ns1__getTaskResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getTaskResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTaskResponse, sizeof(ns1__getTaskResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getTaskResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getTaskResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__wfTask(soap, "result", &(a->ns1__getTaskResponse::result), "ns1:wfTask"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTaskResponse, 0, sizeof(ns1__getTaskResponse), 0, soap_copy_ns1__getTaskResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getTaskResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getTaskResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getTaskResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getTaskResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getTaskResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getTaskResponse * SOAP_FMAC4 soap_get_ns1__getTaskResponse(struct soap *soap, ns1__getTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getTaskResponse * SOAP_FMAC2 soap_instantiate_ns1__getTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getTaskResponse);
		if (size)
			*size = sizeof(ns1__getTaskResponse);
		((ns1__getTaskResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getTaskResponse, n);
		if (size)
			*size = n * sizeof(ns1__getTaskResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getTaskResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getTaskResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getTaskResponse %p -> %p\n", q, p));
	*(ns1__getTaskResponse*)p = *(ns1__getTaskResponse*)q;
}

void ns1__getTask::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getTask::user = NULL;
	this->ns1__getTask::taskId = NULL;
}

void ns1__getTask::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__getTask::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getTask::taskId);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getTask::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getTask(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTask(struct soap *soap, const char *tag, int id, const ns1__getTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTask), "ns1:getTask"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__getTask::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "taskId", -1, &(a->ns1__getTask::taskId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getTask::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getTask(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getTask * SOAP_FMAC4 soap_in_ns1__getTask(struct soap *soap, const char *tag, ns1__getTask *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getTask *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTask, sizeof(ns1__getTask), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getTask)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getTask *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_taskId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__getTask::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_taskId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "taskId", &(a->ns1__getTask::taskId), "xsd:long"))
				{	soap_flag_taskId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTask, 0, sizeof(ns1__getTask), 0, soap_copy_ns1__getTask);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getTask::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getTask);
	if (this->soap_out(soap, tag?tag:"ns1:getTask", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getTask::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getTask(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getTask * SOAP_FMAC4 soap_get_ns1__getTask(struct soap *soap, ns1__getTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getTask * SOAP_FMAC2 soap_instantiate_ns1__getTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getTask);
		if (size)
			*size = sizeof(ns1__getTask);
		((ns1__getTask*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getTask, n);
		if (size)
			*size = n * sizeof(ns1__getTask);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getTask*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getTask %p -> %p\n", q, p));
	*(ns1__getTask*)p = *(ns1__getTask*)q;
}

void ns1__getProcessTasksResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getProcessTasksResponse::__sizeresult = 0;
	this->ns1__getProcessTasksResponse::result = NULL;
}

void ns1__getProcessTasksResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__getProcessTasksResponse::result)
	{	int i;
		for (i = 0; i < this->ns1__getProcessTasksResponse::__sizeresult; i++)
		{
			soap_serialize_PointerTons1__wfTask(soap, this->ns1__getProcessTasksResponse::result + i);
		}
	}
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProcessTasksResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getProcessTasksResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProcessTasksResponse(struct soap *soap, const char *tag, int id, const ns1__getProcessTasksResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProcessTasksResponse), "ns1:getProcessTasksResponse"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns1__getProcessTasksResponse::result)
	{	int i;
		for (i = 0; i < a->ns1__getProcessTasksResponse::__sizeresult; i++)
			if (soap_out_PointerTons1__wfTask(soap, "result", -1, a->ns1__getProcessTasksResponse::result + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__getProcessTasksResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getProcessTasksResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProcessTasksResponse * SOAP_FMAC4 soap_in_ns1__getProcessTasksResponse(struct soap *soap, const char *tag, ns1__getProcessTasksResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getProcessTasksResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProcessTasksResponse, sizeof(ns1__getProcessTasksResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getProcessTasksResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getProcessTasksResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_result1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "result", 1, NULL))
			{	if (a->ns1__getProcessTasksResponse::result == NULL)
				{	if (soap_blist_result1 == NULL)
						soap_blist_result1 = soap_new_block(soap);
					a->ns1__getProcessTasksResponse::result = (ns1__wfTask **)soap_push_block(soap, soap_blist_result1, sizeof(ns1__wfTask *));
					if (a->ns1__getProcessTasksResponse::result == NULL)
						return NULL;
					*a->ns1__getProcessTasksResponse::result = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__wfTask(soap, "result", a->ns1__getProcessTasksResponse::result, "ns1:wfTask"))
				{	a->ns1__getProcessTasksResponse::__sizeresult++;
					a->ns1__getProcessTasksResponse::result = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__getProcessTasksResponse::result)
			soap_pop_block(soap, soap_blist_result1);
		if (a->ns1__getProcessTasksResponse::__sizeresult)
			a->ns1__getProcessTasksResponse::result = (ns1__wfTask **)soap_save_block(soap, soap_blist_result1, NULL, 1);
		else
		{	a->ns1__getProcessTasksResponse::result = NULL;
			if (soap_blist_result1)
				soap_end_block(soap, soap_blist_result1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getProcessTasksResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProcessTasksResponse, 0, sizeof(ns1__getProcessTasksResponse), 0, soap_copy_ns1__getProcessTasksResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getProcessTasksResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getProcessTasksResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getProcessTasksResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getProcessTasksResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getProcessTasksResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProcessTasksResponse * SOAP_FMAC4 soap_get_ns1__getProcessTasksResponse(struct soap *soap, ns1__getProcessTasksResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProcessTasksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getProcessTasksResponse * SOAP_FMAC2 soap_instantiate_ns1__getProcessTasksResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProcessTasksResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProcessTasksResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessTasksResponse);
		if (size)
			*size = sizeof(ns1__getProcessTasksResponse);
		((ns1__getProcessTasksResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessTasksResponse, n);
		if (size)
			*size = n * sizeof(ns1__getProcessTasksResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getProcessTasksResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getProcessTasksResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProcessTasksResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProcessTasksResponse %p -> %p\n", q, p));
	*(ns1__getProcessTasksResponse*)p = *(ns1__getProcessTasksResponse*)q;
}

void ns1__getProcessTasks::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getProcessTasks::user = NULL;
	this->ns1__getProcessTasks::processId = NULL;
	soap_default_bool(soap, &this->ns1__getProcessTasks::includeSubprocesses);
}

void ns1__getProcessTasks::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__getProcessTasks::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__getProcessTasks::processId);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getProcessTasks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getProcessTasks(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProcessTasks(struct soap *soap, const char *tag, int id, const ns1__getProcessTasks *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProcessTasks), "ns1:getProcessTasks"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__getProcessTasks::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "processId", -1, &(a->ns1__getProcessTasks::processId), ""))
		return soap->error;
	if (soap_out_bool(soap, "includeSubprocesses", -1, &(a->ns1__getProcessTasks::includeSubprocesses), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getProcessTasks::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getProcessTasks(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getProcessTasks * SOAP_FMAC4 soap_in_ns1__getProcessTasks(struct soap *soap, const char *tag, ns1__getProcessTasks *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getProcessTasks *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProcessTasks, sizeof(ns1__getProcessTasks), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getProcessTasks)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getProcessTasks *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_processId1 = 1;
	size_t soap_flag_includeSubprocesses1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__getProcessTasks::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_processId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "processId", &(a->ns1__getProcessTasks::processId), "xsd:long"))
				{	soap_flag_processId1--;
					continue;
				}
			if (soap_flag_includeSubprocesses1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "includeSubprocesses", &(a->ns1__getProcessTasks::includeSubprocesses), "xsd:boolean"))
				{	soap_flag_includeSubprocesses1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getProcessTasks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProcessTasks, 0, sizeof(ns1__getProcessTasks), 0, soap_copy_ns1__getProcessTasks);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_includeSubprocesses1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__getProcessTasks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getProcessTasks);
	if (this->soap_out(soap, tag?tag:"ns1:getProcessTasks", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getProcessTasks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getProcessTasks(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getProcessTasks * SOAP_FMAC4 soap_get_ns1__getProcessTasks(struct soap *soap, ns1__getProcessTasks *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProcessTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getProcessTasks * SOAP_FMAC2 soap_instantiate_ns1__getProcessTasks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProcessTasks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProcessTasks, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessTasks);
		if (size)
			*size = sizeof(ns1__getProcessTasks);
		((ns1__getProcessTasks*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessTasks, n);
		if (size)
			*size = n * sizeof(ns1__getProcessTasks);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getProcessTasks*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getProcessTasks*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProcessTasks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getProcessTasks %p -> %p\n", q, p));
	*(ns1__getProcessTasks*)p = *(ns1__getProcessTasks*)q;
}

void ns1__completeTaskWSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void ns1__completeTaskWSResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__completeTaskWSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__completeTaskWSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__completeTaskWSResponse(struct soap *soap, const char *tag, int id, const ns1__completeTaskWSResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:completeTaskWSResponse");
}

void *ns1__completeTaskWSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__completeTaskWSResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__completeTaskWSResponse * SOAP_FMAC4 soap_in_ns1__completeTaskWSResponse(struct soap *soap, const char *tag, ns1__completeTaskWSResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__completeTaskWSResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__completeTaskWSResponse, sizeof(ns1__completeTaskWSResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__completeTaskWSResponse)
			return (ns1__completeTaskWSResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__completeTaskWSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__completeTaskWSResponse);
	if (this->soap_out(soap, tag?tag:"ns1:completeTaskWSResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__completeTaskWSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__completeTaskWSResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__completeTaskWSResponse * SOAP_FMAC4 soap_get_ns1__completeTaskWSResponse(struct soap *soap, ns1__completeTaskWSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__completeTaskWSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__completeTaskWSResponse * SOAP_FMAC2 soap_instantiate_ns1__completeTaskWSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__completeTaskWSResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__completeTaskWSResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__completeTaskWSResponse);
		if (size)
			*size = sizeof(ns1__completeTaskWSResponse);
		((ns1__completeTaskWSResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__completeTaskWSResponse, n);
		if (size)
			*size = n * sizeof(ns1__completeTaskWSResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__completeTaskWSResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__completeTaskWSResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__completeTaskWSResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__completeTaskWSResponse %p -> %p\n", q, p));
	*(ns1__completeTaskWSResponse*)p = *(ns1__completeTaskWSResponse*)q;
}

void ns1__variable::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__variable::name = NULL;
	this->ns1__variable::scriptingName = NULL;
	this->ns1__variable::format = NULL;
	this->ns1__variable::value = NULL;
}

void ns1__variable::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__variable::name);
	soap_serialize_wstring(soap, &this->ns1__variable::scriptingName);
	soap_serialize_wstring(soap, &this->ns1__variable::format);
	soap_serialize_wstring(soap, &this->ns1__variable::value);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__variable::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__variable(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__variable(struct soap *soap, const char *tag, int id, const ns1__variable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__variable), "ns1:variable"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__variable::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "scriptingName", -1, &(a->ns1__variable::scriptingName), ""))
		return soap->error;
	if (soap_out_wstring(soap, "format", -1, &(a->ns1__variable::format), ""))
		return soap->error;
	if (soap_out_wstring(soap, "value", -1, &(a->ns1__variable::value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__variable::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__variable(soap, tag, this, type);
}

SOAP_FMAC3 ns1__variable * SOAP_FMAC4 soap_in_ns1__variable(struct soap *soap, const char *tag, ns1__variable *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__variable *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__variable, sizeof(ns1__variable), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__variable)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__variable *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_scriptingName1 = 1;
	size_t soap_flag_format1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__variable::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_scriptingName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "scriptingName", &(a->ns1__variable::scriptingName), "xsd:string"))
				{	soap_flag_scriptingName1--;
					continue;
				}
			if (soap_flag_format1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "format", &(a->ns1__variable::format), "xsd:string"))
				{	soap_flag_format1--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "value", &(a->ns1__variable::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__variable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__variable, 0, sizeof(ns1__variable), 0, soap_copy_ns1__variable);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__variable::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__variable);
	if (this->soap_out(soap, tag?tag:"ns1:variable", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__variable::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__variable(soap, this, tag, type);
}

SOAP_FMAC3 ns1__variable * SOAP_FMAC4 soap_get_ns1__variable(struct soap *soap, ns1__variable *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__variable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__variable * SOAP_FMAC2 soap_instantiate_ns1__variable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__variable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__variable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__variable);
		if (size)
			*size = sizeof(ns1__variable);
		((ns1__variable*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__variable, n);
		if (size)
			*size = n * sizeof(ns1__variable);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__variable*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__variable*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__variable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__variable %p -> %p\n", q, p));
	*(ns1__variable*)p = *(ns1__variable*)q;
}

void ns1__completeTaskWS::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__completeTaskWS::user = NULL;
	this->ns1__completeTaskWS::taskId = NULL;
	this->ns1__completeTaskWS::__sizevariables = 0;
	this->ns1__completeTaskWS::variables = NULL;
	this->ns1__completeTaskWS::swimlaneActorId = NULL;
}

void ns1__completeTaskWS::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__completeTaskWS::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__completeTaskWS::taskId);
	if (this->ns1__completeTaskWS::variables)
	{	int i;
		for (i = 0; i < this->ns1__completeTaskWS::__sizevariables; i++)
		{
			soap_serialize_PointerTons1__variable(soap, this->ns1__completeTaskWS::variables + i);
		}
	}
	soap_serialize_PointerToLONG64(soap, &this->ns1__completeTaskWS::swimlaneActorId);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__completeTaskWS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__completeTaskWS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__completeTaskWS(struct soap *soap, const char *tag, int id, const ns1__completeTaskWS *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__completeTaskWS), "ns1:completeTaskWS"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__completeTaskWS::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "taskId", -1, &(a->ns1__completeTaskWS::taskId), ""))
		return soap->error;
	if (a->ns1__completeTaskWS::variables)
	{	int i;
		for (i = 0; i < a->ns1__completeTaskWS::__sizevariables; i++)
			if (soap_out_PointerTons1__variable(soap, "variables", -1, a->ns1__completeTaskWS::variables + i, ""))
				return soap->error;
	}
	if (soap_out_PointerToLONG64(soap, "swimlaneActorId", -1, &(a->ns1__completeTaskWS::swimlaneActorId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__completeTaskWS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__completeTaskWS(soap, tag, this, type);
}

SOAP_FMAC3 ns1__completeTaskWS * SOAP_FMAC4 soap_in_ns1__completeTaskWS(struct soap *soap, const char *tag, ns1__completeTaskWS *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__completeTaskWS *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__completeTaskWS, sizeof(ns1__completeTaskWS), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__completeTaskWS)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__completeTaskWS *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_taskId1 = 1;
	struct soap_blist *soap_blist_variables1 = NULL;
	size_t soap_flag_swimlaneActorId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__completeTaskWS::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_taskId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "taskId", &(a->ns1__completeTaskWS::taskId), "xsd:long"))
				{	soap_flag_taskId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "variables", 1, NULL))
			{	if (a->ns1__completeTaskWS::variables == NULL)
				{	if (soap_blist_variables1 == NULL)
						soap_blist_variables1 = soap_new_block(soap);
					a->ns1__completeTaskWS::variables = (ns1__variable **)soap_push_block(soap, soap_blist_variables1, sizeof(ns1__variable *));
					if (a->ns1__completeTaskWS::variables == NULL)
						return NULL;
					*a->ns1__completeTaskWS::variables = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__variable(soap, "variables", a->ns1__completeTaskWS::variables, "ns1:variable"))
				{	a->ns1__completeTaskWS::__sizevariables++;
					a->ns1__completeTaskWS::variables = NULL;
					continue;
				}
			}
			if (soap_flag_swimlaneActorId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "swimlaneActorId", &(a->ns1__completeTaskWS::swimlaneActorId), "xsd:long"))
				{	soap_flag_swimlaneActorId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__completeTaskWS::variables)
			soap_pop_block(soap, soap_blist_variables1);
		if (a->ns1__completeTaskWS::__sizevariables)
			a->ns1__completeTaskWS::variables = (ns1__variable **)soap_save_block(soap, soap_blist_variables1, NULL, 1);
		else
		{	a->ns1__completeTaskWS::variables = NULL;
			if (soap_blist_variables1)
				soap_end_block(soap, soap_blist_variables1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__completeTaskWS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__completeTaskWS, 0, sizeof(ns1__completeTaskWS), 0, soap_copy_ns1__completeTaskWS);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__completeTaskWS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__completeTaskWS);
	if (this->soap_out(soap, tag?tag:"ns1:completeTaskWS", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__completeTaskWS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__completeTaskWS(soap, this, tag, type);
}

SOAP_FMAC3 ns1__completeTaskWS * SOAP_FMAC4 soap_get_ns1__completeTaskWS(struct soap *soap, ns1__completeTaskWS *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__completeTaskWS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__completeTaskWS * SOAP_FMAC2 soap_instantiate_ns1__completeTaskWS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__completeTaskWS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__completeTaskWS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__completeTaskWS);
		if (size)
			*size = sizeof(ns1__completeTaskWS);
		((ns1__completeTaskWS*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__completeTaskWS, n);
		if (size)
			*size = n * sizeof(ns1__completeTaskWS);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__completeTaskWS*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__completeTaskWS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__completeTaskWS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__completeTaskWS %p -> %p\n", q, p));
	*(ns1__completeTaskWS*)p = *(ns1__completeTaskWS*)q;
}

void ns1__getTasksResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getTasksResponse::__sizeresult = 0;
	this->ns1__getTasksResponse::result = NULL;
}

void ns1__getTasksResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__getTasksResponse::result)
	{	int i;
		for (i = 0; i < this->ns1__getTasksResponse::__sizeresult; i++)
		{
			soap_serialize_PointerTons1__wfTask(soap, this->ns1__getTasksResponse::result + i);
		}
	}
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getTasksResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getTasksResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTasksResponse(struct soap *soap, const char *tag, int id, const ns1__getTasksResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTasksResponse), "ns1:getTasksResponse"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns1__getTasksResponse::result)
	{	int i;
		for (i = 0; i < a->ns1__getTasksResponse::__sizeresult; i++)
			if (soap_out_PointerTons1__wfTask(soap, "result", -1, a->ns1__getTasksResponse::result + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__getTasksResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getTasksResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getTasksResponse * SOAP_FMAC4 soap_in_ns1__getTasksResponse(struct soap *soap, const char *tag, ns1__getTasksResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getTasksResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTasksResponse, sizeof(ns1__getTasksResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getTasksResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getTasksResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_result1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "result", 1, NULL))
			{	if (a->ns1__getTasksResponse::result == NULL)
				{	if (soap_blist_result1 == NULL)
						soap_blist_result1 = soap_new_block(soap);
					a->ns1__getTasksResponse::result = (ns1__wfTask **)soap_push_block(soap, soap_blist_result1, sizeof(ns1__wfTask *));
					if (a->ns1__getTasksResponse::result == NULL)
						return NULL;
					*a->ns1__getTasksResponse::result = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__wfTask(soap, "result", a->ns1__getTasksResponse::result, "ns1:wfTask"))
				{	a->ns1__getTasksResponse::__sizeresult++;
					a->ns1__getTasksResponse::result = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__getTasksResponse::result)
			soap_pop_block(soap, soap_blist_result1);
		if (a->ns1__getTasksResponse::__sizeresult)
			a->ns1__getTasksResponse::result = (ns1__wfTask **)soap_save_block(soap, soap_blist_result1, NULL, 1);
		else
		{	a->ns1__getTasksResponse::result = NULL;
			if (soap_blist_result1)
				soap_end_block(soap, soap_blist_result1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getTasksResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTasksResponse, 0, sizeof(ns1__getTasksResponse), 0, soap_copy_ns1__getTasksResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getTasksResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getTasksResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getTasksResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getTasksResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getTasksResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getTasksResponse * SOAP_FMAC4 soap_get_ns1__getTasksResponse(struct soap *soap, ns1__getTasksResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTasksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getTasksResponse * SOAP_FMAC2 soap_instantiate_ns1__getTasksResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTasksResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTasksResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getTasksResponse);
		if (size)
			*size = sizeof(ns1__getTasksResponse);
		((ns1__getTasksResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getTasksResponse, n);
		if (size)
			*size = n * sizeof(ns1__getTasksResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getTasksResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getTasksResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTasksResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getTasksResponse %p -> %p\n", q, p));
	*(ns1__getTasksResponse*)p = *(ns1__getTasksResponse*)q;
}

void ns1__getTasks::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getTasks::user = NULL;
	this->ns1__getTasks::batchPresentation = NULL;
}

void ns1__getTasks::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__getTasks::user);
	soap_serialize_PointerTons1__batchPresentation(soap, &this->ns1__getTasks::batchPresentation);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getTasks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getTasks(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTasks(struct soap *soap, const char *tag, int id, const ns1__getTasks *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTasks), "ns1:getTasks"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__getTasks::user), ""))
		return soap->error;
	if (soap_out_PointerTons1__batchPresentation(soap, "batchPresentation", -1, &(a->ns1__getTasks::batchPresentation), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getTasks::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getTasks(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getTasks * SOAP_FMAC4 soap_in_ns1__getTasks(struct soap *soap, const char *tag, ns1__getTasks *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getTasks *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTasks, sizeof(ns1__getTasks), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getTasks)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getTasks *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_batchPresentation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__getTasks::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_batchPresentation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__batchPresentation(soap, "batchPresentation", &(a->ns1__getTasks::batchPresentation), "ns1:batchPresentation"))
				{	soap_flag_batchPresentation1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getTasks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTasks, 0, sizeof(ns1__getTasks), 0, soap_copy_ns1__getTasks);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getTasks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getTasks);
	if (this->soap_out(soap, tag?tag:"ns1:getTasks", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getTasks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getTasks(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getTasks * SOAP_FMAC4 soap_get_ns1__getTasks(struct soap *soap, ns1__getTasks *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getTasks * SOAP_FMAC2 soap_instantiate_ns1__getTasks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTasks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTasks, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getTasks);
		if (size)
			*size = sizeof(ns1__getTasks);
		((ns1__getTasks*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getTasks, n);
		if (size)
			*size = n * sizeof(ns1__getTasks);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getTasks*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getTasks*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTasks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getTasks %p -> %p\n", q, p));
	*(ns1__getTasks*)p = *(ns1__getTasks*)q;
}

void ns1__reassignTasksResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->ns1__reassignTasksResponse::result);
}

void ns1__reassignTasksResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__reassignTasksResponse::result, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__reassignTasksResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__reassignTasksResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__reassignTasksResponse(struct soap *soap, const char *tag, int id, const ns1__reassignTasksResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__reassignTasksResponse), "ns1:reassignTasksResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_int(soap, "result", -1, &(a->ns1__reassignTasksResponse::result), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__reassignTasksResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__reassignTasksResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__reassignTasksResponse * SOAP_FMAC4 soap_in_ns1__reassignTasksResponse(struct soap *soap, const char *tag, ns1__reassignTasksResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__reassignTasksResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__reassignTasksResponse, sizeof(ns1__reassignTasksResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__reassignTasksResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__reassignTasksResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &(a->ns1__reassignTasksResponse::result), "xsd:int"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__reassignTasksResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__reassignTasksResponse, 0, sizeof(ns1__reassignTasksResponse), 0, soap_copy_ns1__reassignTasksResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__reassignTasksResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__reassignTasksResponse);
	if (this->soap_out(soap, tag?tag:"ns1:reassignTasksResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__reassignTasksResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__reassignTasksResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__reassignTasksResponse * SOAP_FMAC4 soap_get_ns1__reassignTasksResponse(struct soap *soap, ns1__reassignTasksResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__reassignTasksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__reassignTasksResponse * SOAP_FMAC2 soap_instantiate_ns1__reassignTasksResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__reassignTasksResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__reassignTasksResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__reassignTasksResponse);
		if (size)
			*size = sizeof(ns1__reassignTasksResponse);
		((ns1__reassignTasksResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__reassignTasksResponse, n);
		if (size)
			*size = n * sizeof(ns1__reassignTasksResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__reassignTasksResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__reassignTasksResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__reassignTasksResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__reassignTasksResponse %p -> %p\n", q, p));
	*(ns1__reassignTasksResponse*)p = *(ns1__reassignTasksResponse*)q;
}

void ns1__reassignTasks::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__reassignTasks::user = NULL;
	this->ns1__reassignTasks::batchPresentation = NULL;
}

void ns1__reassignTasks::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__reassignTasks::user);
	soap_serialize_PointerTons1__batchPresentation(soap, &this->ns1__reassignTasks::batchPresentation);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__reassignTasks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__reassignTasks(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__reassignTasks(struct soap *soap, const char *tag, int id, const ns1__reassignTasks *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__reassignTasks), "ns1:reassignTasks"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__reassignTasks::user), ""))
		return soap->error;
	if (soap_out_PointerTons1__batchPresentation(soap, "batchPresentation", -1, &(a->ns1__reassignTasks::batchPresentation), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__reassignTasks::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__reassignTasks(soap, tag, this, type);
}

SOAP_FMAC3 ns1__reassignTasks * SOAP_FMAC4 soap_in_ns1__reassignTasks(struct soap *soap, const char *tag, ns1__reassignTasks *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__reassignTasks *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__reassignTasks, sizeof(ns1__reassignTasks), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__reassignTasks)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__reassignTasks *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_batchPresentation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__reassignTasks::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_batchPresentation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__batchPresentation(soap, "batchPresentation", &(a->ns1__reassignTasks::batchPresentation), "ns1:batchPresentation"))
				{	soap_flag_batchPresentation1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__reassignTasks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__reassignTasks, 0, sizeof(ns1__reassignTasks), 0, soap_copy_ns1__reassignTasks);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__reassignTasks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__reassignTasks);
	if (this->soap_out(soap, tag?tag:"ns1:reassignTasks", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__reassignTasks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__reassignTasks(soap, this, tag, type);
}

SOAP_FMAC3 ns1__reassignTasks * SOAP_FMAC4 soap_get_ns1__reassignTasks(struct soap *soap, ns1__reassignTasks *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__reassignTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__reassignTasks * SOAP_FMAC2 soap_instantiate_ns1__reassignTasks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__reassignTasks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__reassignTasks, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__reassignTasks);
		if (size)
			*size = sizeof(ns1__reassignTasks);
		((ns1__reassignTasks*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__reassignTasks, n);
		if (size)
			*size = n * sizeof(ns1__reassignTasks);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__reassignTasks*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__reassignTasks*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__reassignTasks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__reassignTasks %p -> %p\n", q, p));
	*(ns1__reassignTasks*)p = *(ns1__reassignTasks*)q;
}

void ns1__reassignTaskResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void ns1__reassignTaskResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__reassignTaskResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__reassignTaskResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__reassignTaskResponse(struct soap *soap, const char *tag, int id, const ns1__reassignTaskResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:reassignTaskResponse");
}

void *ns1__reassignTaskResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__reassignTaskResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__reassignTaskResponse * SOAP_FMAC4 soap_in_ns1__reassignTaskResponse(struct soap *soap, const char *tag, ns1__reassignTaskResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__reassignTaskResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__reassignTaskResponse, sizeof(ns1__reassignTaskResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__reassignTaskResponse)
			return (ns1__reassignTaskResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__reassignTaskResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__reassignTaskResponse);
	if (this->soap_out(soap, tag?tag:"ns1:reassignTaskResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__reassignTaskResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__reassignTaskResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__reassignTaskResponse * SOAP_FMAC4 soap_get_ns1__reassignTaskResponse(struct soap *soap, ns1__reassignTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__reassignTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__reassignTaskResponse * SOAP_FMAC2 soap_instantiate_ns1__reassignTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__reassignTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__reassignTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__reassignTaskResponse);
		if (size)
			*size = sizeof(ns1__reassignTaskResponse);
		((ns1__reassignTaskResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__reassignTaskResponse, n);
		if (size)
			*size = n * sizeof(ns1__reassignTaskResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__reassignTaskResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__reassignTaskResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__reassignTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__reassignTaskResponse %p -> %p\n", q, p));
	*(ns1__reassignTaskResponse*)p = *(ns1__reassignTaskResponse*)q;
}

void ns1__reassignTask::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__reassignTask::user = NULL;
	this->ns1__reassignTask::batchPresentation = NULL;
}

void ns1__reassignTask::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__reassignTask::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__reassignTask::batchPresentation);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__reassignTask::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__reassignTask(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__reassignTask(struct soap *soap, const char *tag, int id, const ns1__reassignTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__reassignTask), "ns1:reassignTask"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__reassignTask::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "batchPresentation", -1, &(a->ns1__reassignTask::batchPresentation), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__reassignTask::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__reassignTask(soap, tag, this, type);
}

SOAP_FMAC3 ns1__reassignTask * SOAP_FMAC4 soap_in_ns1__reassignTask(struct soap *soap, const char *tag, ns1__reassignTask *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__reassignTask *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__reassignTask, sizeof(ns1__reassignTask), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__reassignTask)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__reassignTask *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_batchPresentation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__reassignTask::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_batchPresentation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "batchPresentation", &(a->ns1__reassignTask::batchPresentation), "xsd:long"))
				{	soap_flag_batchPresentation1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__reassignTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__reassignTask, 0, sizeof(ns1__reassignTask), 0, soap_copy_ns1__reassignTask);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__reassignTask::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__reassignTask);
	if (this->soap_out(soap, tag?tag:"ns1:reassignTask", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__reassignTask::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__reassignTask(soap, this, tag, type);
}

SOAP_FMAC3 ns1__reassignTask * SOAP_FMAC4 soap_get_ns1__reassignTask(struct soap *soap, ns1__reassignTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__reassignTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__reassignTask * SOAP_FMAC2 soap_instantiate_ns1__reassignTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__reassignTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__reassignTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__reassignTask);
		if (size)
			*size = sizeof(ns1__reassignTask);
		((ns1__reassignTask*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__reassignTask, n);
		if (size)
			*size = n * sizeof(ns1__reassignTask);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__reassignTask*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__reassignTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__reassignTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__reassignTask %p -> %p\n", q, p));
	*(ns1__reassignTask*)p = *(ns1__reassignTask*)q;
}

void ns1__markTaskOpenedResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void ns1__markTaskOpenedResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__markTaskOpenedResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__markTaskOpenedResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__markTaskOpenedResponse(struct soap *soap, const char *tag, int id, const ns1__markTaskOpenedResponse *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:markTaskOpenedResponse");
}

void *ns1__markTaskOpenedResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__markTaskOpenedResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__markTaskOpenedResponse * SOAP_FMAC4 soap_in_ns1__markTaskOpenedResponse(struct soap *soap, const char *tag, ns1__markTaskOpenedResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__markTaskOpenedResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__markTaskOpenedResponse, sizeof(ns1__markTaskOpenedResponse), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__markTaskOpenedResponse)
			return (ns1__markTaskOpenedResponse *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__markTaskOpenedResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__markTaskOpenedResponse);
	if (this->soap_out(soap, tag?tag:"ns1:markTaskOpenedResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__markTaskOpenedResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__markTaskOpenedResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__markTaskOpenedResponse * SOAP_FMAC4 soap_get_ns1__markTaskOpenedResponse(struct soap *soap, ns1__markTaskOpenedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__markTaskOpenedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__markTaskOpenedResponse * SOAP_FMAC2 soap_instantiate_ns1__markTaskOpenedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__markTaskOpenedResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__markTaskOpenedResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__markTaskOpenedResponse);
		if (size)
			*size = sizeof(ns1__markTaskOpenedResponse);
		((ns1__markTaskOpenedResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__markTaskOpenedResponse, n);
		if (size)
			*size = n * sizeof(ns1__markTaskOpenedResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__markTaskOpenedResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__markTaskOpenedResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__markTaskOpenedResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__markTaskOpenedResponse %p -> %p\n", q, p));
	*(ns1__markTaskOpenedResponse*)p = *(ns1__markTaskOpenedResponse*)q;
}

void ns1__markTaskOpened::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__markTaskOpened::user = NULL;
	this->ns1__markTaskOpened::taskId = NULL;
}

void ns1__markTaskOpened::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__markTaskOpened::user);
	soap_serialize_PointerToLONG64(soap, &this->ns1__markTaskOpened::taskId);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__markTaskOpened::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__markTaskOpened(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__markTaskOpened(struct soap *soap, const char *tag, int id, const ns1__markTaskOpened *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__markTaskOpened), "ns1:markTaskOpened"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__markTaskOpened::user), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "taskId", -1, &(a->ns1__markTaskOpened::taskId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__markTaskOpened::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__markTaskOpened(soap, tag, this, type);
}

SOAP_FMAC3 ns1__markTaskOpened * SOAP_FMAC4 soap_in_ns1__markTaskOpened(struct soap *soap, const char *tag, ns1__markTaskOpened *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__markTaskOpened *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__markTaskOpened, sizeof(ns1__markTaskOpened), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__markTaskOpened)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__markTaskOpened *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_taskId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__markTaskOpened::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_taskId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "taskId", &(a->ns1__markTaskOpened::taskId), "xsd:long"))
				{	soap_flag_taskId1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__markTaskOpened *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__markTaskOpened, 0, sizeof(ns1__markTaskOpened), 0, soap_copy_ns1__markTaskOpened);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__markTaskOpened::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__markTaskOpened);
	if (this->soap_out(soap, tag?tag:"ns1:markTaskOpened", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__markTaskOpened::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__markTaskOpened(soap, this, tag, type);
}

SOAP_FMAC3 ns1__markTaskOpened * SOAP_FMAC4 soap_get_ns1__markTaskOpened(struct soap *soap, ns1__markTaskOpened *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__markTaskOpened(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__markTaskOpened * SOAP_FMAC2 soap_instantiate_ns1__markTaskOpened(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__markTaskOpened(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__markTaskOpened, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__markTaskOpened);
		if (size)
			*size = sizeof(ns1__markTaskOpened);
		((ns1__markTaskOpened*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__markTaskOpened, n);
		if (size)
			*size = n * sizeof(ns1__markTaskOpened);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__markTaskOpened*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__markTaskOpened*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__markTaskOpened(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__markTaskOpened %p -> %p\n", q, p));
	*(ns1__markTaskOpened*)p = *(ns1__markTaskOpened*)q;
}

void ns1__variableFormat::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void ns1__variableFormat::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__variableFormat::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__variableFormat(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__variableFormat(struct soap *soap, const char *tag, int id, const ns1__variableFormat *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:variableFormat");
}

void *ns1__variableFormat::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__variableFormat(soap, tag, this, type);
}

SOAP_FMAC3 ns1__variableFormat * SOAP_FMAC4 soap_in_ns1__variableFormat(struct soap *soap, const char *tag, ns1__variableFormat *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__variableFormat *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__variableFormat, sizeof(ns1__variableFormat), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__variableFormat)
			return (ns1__variableFormat *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__variableFormat::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__variableFormat);
	if (this->soap_out(soap, tag?tag:"ns1:variableFormat", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__variableFormat::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__variableFormat(soap, this, tag, type);
}

SOAP_FMAC3 ns1__variableFormat * SOAP_FMAC4 soap_get_ns1__variableFormat(struct soap *soap, ns1__variableFormat *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__variableFormat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__variableFormat * SOAP_FMAC2 soap_instantiate_ns1__variableFormat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__variableFormat(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__variableFormat, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__variableFormat);
		if (size)
			*size = sizeof(ns1__variableFormat);
		((ns1__variableFormat*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__variableFormat, n);
		if (size)
			*size = n * sizeof(ns1__variableFormat);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__variableFormat*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__variableFormat*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__variableFormat(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__variableFormat %p -> %p\n", q, p));
	*(ns1__variableFormat*)p = *(ns1__variableFormat*)q;
}

void ns1__userType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__userType::name = NULL;
	this->ns1__userType::__sizeattributes = 0;
	this->ns1__userType::attributes = NULL;
	this->ns1__userType::attributesMap._ns1__userType_attributesMap::soap_default(soap);
}

void ns1__userType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__userType::name);
	if (this->ns1__userType::attributes)
	{	int i;
		for (i = 0; i < this->ns1__userType::__sizeattributes; i++)
		{
			soap_serialize_PointerTons1__variableDefinition(soap, this->ns1__userType::attributes + i);
		}
	}
	this->ns1__userType::attributesMap.soap_serialize(soap);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__userType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__userType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__userType(struct soap *soap, const char *tag, int id, const ns1__userType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__userType), "ns1:userType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__userType::name), ""))
		return soap->error;
	if (a->ns1__userType::attributes)
	{	int i;
		for (i = 0; i < a->ns1__userType::__sizeattributes; i++)
			if (soap_out_PointerTons1__variableDefinition(soap, "attributes", -1, a->ns1__userType::attributes + i, ""))
				return soap->error;
	}
	if ((a->ns1__userType::attributesMap).soap_out(soap, "attributesMap", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__userType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__userType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__userType * SOAP_FMAC4 soap_in_ns1__userType(struct soap *soap, const char *tag, ns1__userType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__userType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__userType, sizeof(ns1__userType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__userType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__userType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_name1 = 1;
	struct soap_blist *soap_blist_attributes1 = NULL;
	size_t soap_flag_attributesMap1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__userType::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "attributes", 1, NULL))
			{	if (a->ns1__userType::attributes == NULL)
				{	if (soap_blist_attributes1 == NULL)
						soap_blist_attributes1 = soap_new_block(soap);
					a->ns1__userType::attributes = (ns1__variableDefinition **)soap_push_block(soap, soap_blist_attributes1, sizeof(ns1__variableDefinition *));
					if (a->ns1__userType::attributes == NULL)
						return NULL;
					*a->ns1__userType::attributes = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__variableDefinition(soap, "attributes", a->ns1__userType::attributes, "ns1:variableDefinition"))
				{	a->ns1__userType::__sizeattributes++;
					a->ns1__userType::attributes = NULL;
					continue;
				}
			}
			if (soap_flag_attributesMap1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns1__userType::attributesMap).soap_in(soap, "attributesMap", ""))
				{	soap_flag_attributesMap1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__userType::attributes)
			soap_pop_block(soap, soap_blist_attributes1);
		if (a->ns1__userType::__sizeattributes)
			a->ns1__userType::attributes = (ns1__variableDefinition **)soap_save_block(soap, soap_blist_attributes1, NULL, 1);
		else
		{	a->ns1__userType::attributes = NULL;
			if (soap_blist_attributes1)
				soap_end_block(soap, soap_blist_attributes1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__userType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__userType, 0, sizeof(ns1__userType), 0, soap_copy_ns1__userType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_attributesMap1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__userType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__userType);
	if (this->soap_out(soap, tag?tag:"ns1:userType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__userType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__userType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__userType * SOAP_FMAC4 soap_get_ns1__userType(struct soap *soap, ns1__userType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__userType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__userType * SOAP_FMAC2 soap_instantiate_ns1__userType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__userType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__userType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__userType);
		if (size)
			*size = sizeof(ns1__userType);
		((ns1__userType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__userType, n);
		if (size)
			*size = n * sizeof(ns1__userType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__userType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__userType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__userType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__userType %p -> %p\n", q, p));
	*(ns1__userType*)p = *(ns1__userType*)q;
}

void ns1__variableDefinition::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->ns1__variableDefinition::synthetic);
	this->ns1__variableDefinition::name = NULL;
	this->ns1__variableDefinition::scriptingName = NULL;
	this->ns1__variableDefinition::description = NULL;
	this->ns1__variableDefinition::format = NULL;
	this->ns1__variableDefinition::formatLabel = NULL;
	this->ns1__variableDefinition::userType = NULL;
	this->ns1__variableDefinition::__sizeformatComponentUserTypes = 0;
	this->ns1__variableDefinition::formatComponentUserTypes = NULL;
	soap_default_bool(soap, &this->ns1__variableDefinition::publicAccess);
	this->ns1__variableDefinition::defaultValue = NULL;
}

void ns1__variableDefinition::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__variableDefinition::name);
	soap_serialize_wstring(soap, &this->ns1__variableDefinition::scriptingName);
	soap_serialize_wstring(soap, &this->ns1__variableDefinition::description);
	soap_serialize_wstring(soap, &this->ns1__variableDefinition::format);
	soap_serialize_wstring(soap, &this->ns1__variableDefinition::formatLabel);
	soap_serialize_PointerTons1__userType(soap, &this->ns1__variableDefinition::userType);
	if (this->ns1__variableDefinition::formatComponentUserTypes)
	{	int i;
		for (i = 0; i < this->ns1__variableDefinition::__sizeformatComponentUserTypes; i++)
		{
			soap_serialize_PointerTons1__userType(soap, this->ns1__variableDefinition::formatComponentUserTypes + i);
		}
	}
	soap_serialize_PointerToxsd__anyType(soap, &this->ns1__variableDefinition::defaultValue);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__variableDefinition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__variableDefinition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__variableDefinition(struct soap *soap, const char *tag, int id, const ns1__variableDefinition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__variableDefinition), "ns1:variableDefinition"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_bool(soap, "synthetic", -1, &(a->ns1__variableDefinition::synthetic), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__variableDefinition::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "scriptingName", -1, &(a->ns1__variableDefinition::scriptingName), ""))
		return soap->error;
	if (soap_out_wstring(soap, "description", -1, &(a->ns1__variableDefinition::description), ""))
		return soap->error;
	if (soap_out_wstring(soap, "format", -1, &(a->ns1__variableDefinition::format), ""))
		return soap->error;
	if (soap_out_wstring(soap, "formatLabel", -1, &(a->ns1__variableDefinition::formatLabel), ""))
		return soap->error;
	if (soap_out_PointerTons1__userType(soap, "userType", -1, &(a->ns1__variableDefinition::userType), ""))
		return soap->error;
	if (a->ns1__variableDefinition::formatComponentUserTypes)
	{	int i;
		for (i = 0; i < a->ns1__variableDefinition::__sizeformatComponentUserTypes; i++)
			if (soap_out_PointerTons1__userType(soap, "formatComponentUserTypes", -1, a->ns1__variableDefinition::formatComponentUserTypes + i, ""))
				return soap->error;
	}
	if (soap_out_bool(soap, "publicAccess", -1, &(a->ns1__variableDefinition::publicAccess), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "defaultValue", -1, &(a->ns1__variableDefinition::defaultValue), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__variableDefinition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__variableDefinition(soap, tag, this, type);
}

SOAP_FMAC3 ns1__variableDefinition * SOAP_FMAC4 soap_in_ns1__variableDefinition(struct soap *soap, const char *tag, ns1__variableDefinition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__variableDefinition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__variableDefinition, sizeof(ns1__variableDefinition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__variableDefinition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__variableDefinition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_synthetic1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_scriptingName1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_format1 = 1;
	size_t soap_flag_formatLabel1 = 1;
	size_t soap_flag_userType1 = 1;
	struct soap_blist *soap_blist_formatComponentUserTypes1 = NULL;
	size_t soap_flag_publicAccess1 = 1;
	size_t soap_flag_defaultValue1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_synthetic1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "synthetic", &(a->ns1__variableDefinition::synthetic), "xsd:boolean"))
				{	soap_flag_synthetic1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__variableDefinition::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_scriptingName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "scriptingName", &(a->ns1__variableDefinition::scriptingName), "xsd:string"))
				{	soap_flag_scriptingName1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "description", &(a->ns1__variableDefinition::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_format1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "format", &(a->ns1__variableDefinition::format), "xsd:string"))
				{	soap_flag_format1--;
					continue;
				}
			if (soap_flag_formatLabel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "formatLabel", &(a->ns1__variableDefinition::formatLabel), "xsd:string"))
				{	soap_flag_formatLabel1--;
					continue;
				}
			if (soap_flag_userType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__userType(soap, "userType", &(a->ns1__variableDefinition::userType), "ns1:userType"))
				{	soap_flag_userType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "formatComponentUserTypes", 1, NULL))
			{	if (a->ns1__variableDefinition::formatComponentUserTypes == NULL)
				{	if (soap_blist_formatComponentUserTypes1 == NULL)
						soap_blist_formatComponentUserTypes1 = soap_new_block(soap);
					a->ns1__variableDefinition::formatComponentUserTypes = (ns1__userType **)soap_push_block(soap, soap_blist_formatComponentUserTypes1, sizeof(ns1__userType *));
					if (a->ns1__variableDefinition::formatComponentUserTypes == NULL)
						return NULL;
					*a->ns1__variableDefinition::formatComponentUserTypes = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__userType(soap, "formatComponentUserTypes", a->ns1__variableDefinition::formatComponentUserTypes, "ns1:userType"))
				{	a->ns1__variableDefinition::__sizeformatComponentUserTypes++;
					a->ns1__variableDefinition::formatComponentUserTypes = NULL;
					continue;
				}
			}
			if (soap_flag_publicAccess1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "publicAccess", &(a->ns1__variableDefinition::publicAccess), "xsd:boolean"))
				{	soap_flag_publicAccess1--;
					continue;
				}
			if (soap_flag_defaultValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "defaultValue", &(a->ns1__variableDefinition::defaultValue), "xsd:anyType"))
				{	soap_flag_defaultValue1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__variableDefinition::formatComponentUserTypes)
			soap_pop_block(soap, soap_blist_formatComponentUserTypes1);
		if (a->ns1__variableDefinition::__sizeformatComponentUserTypes)
			a->ns1__variableDefinition::formatComponentUserTypes = (ns1__userType **)soap_save_block(soap, soap_blist_formatComponentUserTypes1, NULL, 1);
		else
		{	a->ns1__variableDefinition::formatComponentUserTypes = NULL;
			if (soap_blist_formatComponentUserTypes1)
				soap_end_block(soap, soap_blist_formatComponentUserTypes1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__variableDefinition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__variableDefinition, 0, sizeof(ns1__variableDefinition), 0, soap_copy_ns1__variableDefinition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_synthetic1 > 0 || soap_flag_publicAccess1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__variableDefinition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__variableDefinition);
	if (this->soap_out(soap, tag?tag:"ns1:variableDefinition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__variableDefinition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__variableDefinition(soap, this, tag, type);
}

SOAP_FMAC3 ns1__variableDefinition * SOAP_FMAC4 soap_get_ns1__variableDefinition(struct soap *soap, ns1__variableDefinition *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__variableDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__variableDefinition * SOAP_FMAC2 soap_instantiate_ns1__variableDefinition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__variableDefinition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__variableDefinition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__variableDefinition);
		if (size)
			*size = sizeof(ns1__variableDefinition);
		((ns1__variableDefinition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__variableDefinition, n);
		if (size)
			*size = n * sizeof(ns1__variableDefinition);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__variableDefinition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__variableDefinition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__variableDefinition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__variableDefinition %p -> %p\n", q, p));
	*(ns1__variableDefinition*)p = *(ns1__variableDefinition*)q;
}

void ns1__wfTask::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__wfTask::id = NULL;
	this->ns1__wfTask::name = NULL;
	this->ns1__wfTask::nodeId = NULL;
	this->ns1__wfTask::description = NULL;
	this->ns1__wfTask::swimlaneName = NULL;
	this->ns1__wfTask::owner = NULL;
	this->ns1__wfTask::targetActor = NULL;
	this->ns1__wfTask::definitionId = NULL;
	this->ns1__wfTask::definitionName = NULL;
	this->ns1__wfTask::processId = NULL;
	this->ns1__wfTask::processHierarchyIds = NULL;
	this->ns1__wfTask::creationDate = NULL;
	this->ns1__wfTask::deadlineDate = NULL;
	this->ns1__wfTask::deadlineWarningDate = NULL;
	soap_default_bool(soap, &this->ns1__wfTask::escalated);
	soap_default_bool(soap, &this->ns1__wfTask::firstOpen);
	soap_default_bool(soap, &this->ns1__wfTask::acquiredBySubstitution);
	this->ns1__wfTask::multitaskIndex = NULL;
	this->ns1__wfTask::__sizevariables = 0;
	this->ns1__wfTask::variables = NULL;
}

void ns1__wfTask::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->ns1__wfTask::id);
	soap_serialize_wstring(soap, &this->ns1__wfTask::name);
	soap_serialize_wstring(soap, &this->ns1__wfTask::nodeId);
	soap_serialize_wstring(soap, &this->ns1__wfTask::description);
	soap_serialize_wstring(soap, &this->ns1__wfTask::swimlaneName);
	soap_serialize_PointerTons1__wfExecutor(soap, &this->ns1__wfTask::owner);
	soap_serialize_PointerTons1__actor(soap, &this->ns1__wfTask::targetActor);
	soap_serialize_PointerToLONG64(soap, &this->ns1__wfTask::definitionId);
	soap_serialize_wstring(soap, &this->ns1__wfTask::definitionName);
	soap_serialize_PointerToLONG64(soap, &this->ns1__wfTask::processId);
	soap_serialize_wstring(soap, &this->ns1__wfTask::processHierarchyIds);
	soap_serialize_PointerTotime(soap, &this->ns1__wfTask::creationDate);
	soap_serialize_PointerTotime(soap, &this->ns1__wfTask::deadlineDate);
	soap_serialize_PointerTotime(soap, &this->ns1__wfTask::deadlineWarningDate);
	soap_serialize_PointerToint(soap, &this->ns1__wfTask::multitaskIndex);
	if (this->ns1__wfTask::variables)
	{	int i;
		for (i = 0; i < this->ns1__wfTask::__sizevariables; i++)
		{
			soap_serialize_PointerTons2__wfVariableStub(soap, this->ns1__wfTask::variables + i);
		}
	}
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__wfTask::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__wfTask(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__wfTask(struct soap *soap, const char *tag, int id, const ns1__wfTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__wfTask), "ns1:wfTask"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__wfTask::id), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__wfTask::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "nodeId", -1, &(a->ns1__wfTask::nodeId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "description", -1, &(a->ns1__wfTask::description), ""))
		return soap->error;
	if (soap_out_wstring(soap, "swimlaneName", -1, &(a->ns1__wfTask::swimlaneName), ""))
		return soap->error;
	if (soap_out_PointerTons1__wfExecutor(soap, "owner", -1, &(a->ns1__wfTask::owner), ""))
		return soap->error;
	if (soap_out_PointerTons1__actor(soap, "targetActor", -1, &(a->ns1__wfTask::targetActor), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "definitionId", -1, &(a->ns1__wfTask::definitionId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "definitionName", -1, &(a->ns1__wfTask::definitionName), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "processId", -1, &(a->ns1__wfTask::processId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "processHierarchyIds", -1, &(a->ns1__wfTask::processHierarchyIds), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "creationDate", -1, &(a->ns1__wfTask::creationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "deadlineDate", -1, &(a->ns1__wfTask::deadlineDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "deadlineWarningDate", -1, &(a->ns1__wfTask::deadlineWarningDate), ""))
		return soap->error;
	if (soap_out_bool(soap, "escalated", -1, &(a->ns1__wfTask::escalated), ""))
		return soap->error;
	if (soap_out_bool(soap, "firstOpen", -1, &(a->ns1__wfTask::firstOpen), ""))
		return soap->error;
	if (soap_out_bool(soap, "acquiredBySubstitution", -1, &(a->ns1__wfTask::acquiredBySubstitution), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "multitaskIndex", -1, &(a->ns1__wfTask::multitaskIndex), ""))
		return soap->error;
	if (a->ns1__wfTask::variables)
	{	int i;
		for (i = 0; i < a->ns1__wfTask::__sizevariables; i++)
			if (soap_out_PointerTons2__wfVariableStub(soap, "variables", -1, a->ns1__wfTask::variables + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__wfTask::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__wfTask(soap, tag, this, type);
}

SOAP_FMAC3 ns1__wfTask * SOAP_FMAC4 soap_in_ns1__wfTask(struct soap *soap, const char *tag, ns1__wfTask *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__wfTask *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__wfTask, sizeof(ns1__wfTask), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__wfTask)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__wfTask *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_nodeId1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_swimlaneName1 = 1;
	size_t soap_flag_owner1 = 1;
	size_t soap_flag_targetActor1 = 1;
	size_t soap_flag_definitionId1 = 1;
	size_t soap_flag_definitionName1 = 1;
	size_t soap_flag_processId1 = 1;
	size_t soap_flag_processHierarchyIds1 = 1;
	size_t soap_flag_creationDate1 = 1;
	size_t soap_flag_deadlineDate1 = 1;
	size_t soap_flag_deadlineWarningDate1 = 1;
	size_t soap_flag_escalated1 = 1;
	size_t soap_flag_firstOpen1 = 1;
	size_t soap_flag_acquiredBySubstitution1 = 1;
	size_t soap_flag_multitaskIndex1 = 1;
	struct soap_blist *soap_blist_variables1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__wfTask::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__wfTask::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_nodeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "nodeId", &(a->ns1__wfTask::nodeId), "xsd:string"))
				{	soap_flag_nodeId1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "description", &(a->ns1__wfTask::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_swimlaneName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "swimlaneName", &(a->ns1__wfTask::swimlaneName), "xsd:string"))
				{	soap_flag_swimlaneName1--;
					continue;
				}
			if (soap_flag_owner1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__wfExecutor(soap, "owner", &(a->ns1__wfTask::owner), "ns1:wfExecutor"))
				{	soap_flag_owner1--;
					continue;
				}
			if (soap_flag_targetActor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__actor(soap, "targetActor", &(a->ns1__wfTask::targetActor), "ns1:actor"))
				{	soap_flag_targetActor1--;
					continue;
				}
			if (soap_flag_definitionId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "definitionId", &(a->ns1__wfTask::definitionId), "xsd:long"))
				{	soap_flag_definitionId1--;
					continue;
				}
			if (soap_flag_definitionName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "definitionName", &(a->ns1__wfTask::definitionName), "xsd:string"))
				{	soap_flag_definitionName1--;
					continue;
				}
			if (soap_flag_processId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "processId", &(a->ns1__wfTask::processId), "xsd:long"))
				{	soap_flag_processId1--;
					continue;
				}
			if (soap_flag_processHierarchyIds1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "processHierarchyIds", &(a->ns1__wfTask::processHierarchyIds), "xsd:string"))
				{	soap_flag_processHierarchyIds1--;
					continue;
				}
			if (soap_flag_creationDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "creationDate", &(a->ns1__wfTask::creationDate), "xsd:dateTime"))
				{	soap_flag_creationDate1--;
					continue;
				}
			if (soap_flag_deadlineDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "deadlineDate", &(a->ns1__wfTask::deadlineDate), "xsd:dateTime"))
				{	soap_flag_deadlineDate1--;
					continue;
				}
			if (soap_flag_deadlineWarningDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "deadlineWarningDate", &(a->ns1__wfTask::deadlineWarningDate), "xsd:dateTime"))
				{	soap_flag_deadlineWarningDate1--;
					continue;
				}
			if (soap_flag_escalated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "escalated", &(a->ns1__wfTask::escalated), "xsd:boolean"))
				{	soap_flag_escalated1--;
					continue;
				}
			if (soap_flag_firstOpen1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "firstOpen", &(a->ns1__wfTask::firstOpen), "xsd:boolean"))
				{	soap_flag_firstOpen1--;
					continue;
				}
			if (soap_flag_acquiredBySubstitution1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "acquiredBySubstitution", &(a->ns1__wfTask::acquiredBySubstitution), "xsd:boolean"))
				{	soap_flag_acquiredBySubstitution1--;
					continue;
				}
			if (soap_flag_multitaskIndex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "multitaskIndex", &(a->ns1__wfTask::multitaskIndex), "xsd:int"))
				{	soap_flag_multitaskIndex1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "variables", 1, NULL))
			{	if (a->ns1__wfTask::variables == NULL)
				{	if (soap_blist_variables1 == NULL)
						soap_blist_variables1 = soap_new_block(soap);
					a->ns1__wfTask::variables = (ns2__wfVariableStub **)soap_push_block(soap, soap_blist_variables1, sizeof(ns2__wfVariableStub *));
					if (a->ns1__wfTask::variables == NULL)
						return NULL;
					*a->ns1__wfTask::variables = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons2__wfVariableStub(soap, "variables", a->ns1__wfTask::variables, "ns2:wfVariableStub"))
				{	a->ns1__wfTask::__sizevariables++;
					a->ns1__wfTask::variables = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__wfTask::variables)
			soap_pop_block(soap, soap_blist_variables1);
		if (a->ns1__wfTask::__sizevariables)
			a->ns1__wfTask::variables = (ns2__wfVariableStub **)soap_save_block(soap, soap_blist_variables1, NULL, 1);
		else
		{	a->ns1__wfTask::variables = NULL;
			if (soap_blist_variables1)
				soap_end_block(soap, soap_blist_variables1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__wfTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__wfTask, 0, sizeof(ns1__wfTask), 0, soap_copy_ns1__wfTask);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_escalated1 > 0 || soap_flag_firstOpen1 > 0 || soap_flag_acquiredBySubstitution1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__wfTask::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__wfTask);
	if (this->soap_out(soap, tag?tag:"ns1:wfTask", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__wfTask::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__wfTask(soap, this, tag, type);
}

SOAP_FMAC3 ns1__wfTask * SOAP_FMAC4 soap_get_ns1__wfTask(struct soap *soap, ns1__wfTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__wfTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__wfTask * SOAP_FMAC2 soap_instantiate_ns1__wfTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__wfTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__wfTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__wfTask);
		if (size)
			*size = sizeof(ns1__wfTask);
		((ns1__wfTask*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wfTask, n);
		if (size)
			*size = n * sizeof(ns1__wfTask);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__wfTask*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__wfTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__wfTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__wfTask %p -> %p\n", q, p));
	*(ns1__wfTask*)p = *(ns1__wfTask*)q;
}

void ns1__getMyTasksResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getMyTasksResponse::__sizeresult = 0;
	this->ns1__getMyTasksResponse::result = NULL;
}

void ns1__getMyTasksResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->ns1__getMyTasksResponse::result)
	{	int i;
		for (i = 0; i < this->ns1__getMyTasksResponse::__sizeresult; i++)
		{
			soap_serialize_PointerTons1__wfTask(soap, this->ns1__getMyTasksResponse::result + i);
		}
	}
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getMyTasksResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getMyTasksResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getMyTasksResponse(struct soap *soap, const char *tag, int id, const ns1__getMyTasksResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getMyTasksResponse), "ns1:getMyTasksResponse"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns1__getMyTasksResponse::result)
	{	int i;
		for (i = 0; i < a->ns1__getMyTasksResponse::__sizeresult; i++)
			if (soap_out_PointerTons1__wfTask(soap, "result", -1, a->ns1__getMyTasksResponse::result + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns1__getMyTasksResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getMyTasksResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getMyTasksResponse * SOAP_FMAC4 soap_in_ns1__getMyTasksResponse(struct soap *soap, const char *tag, ns1__getMyTasksResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getMyTasksResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getMyTasksResponse, sizeof(ns1__getMyTasksResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getMyTasksResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getMyTasksResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_result1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "result", 1, NULL))
			{	if (a->ns1__getMyTasksResponse::result == NULL)
				{	if (soap_blist_result1 == NULL)
						soap_blist_result1 = soap_new_block(soap);
					a->ns1__getMyTasksResponse::result = (ns1__wfTask **)soap_push_block(soap, soap_blist_result1, sizeof(ns1__wfTask *));
					if (a->ns1__getMyTasksResponse::result == NULL)
						return NULL;
					*a->ns1__getMyTasksResponse::result = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTons1__wfTask(soap, "result", a->ns1__getMyTasksResponse::result, "ns1:wfTask"))
				{	a->ns1__getMyTasksResponse::__sizeresult++;
					a->ns1__getMyTasksResponse::result = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns1__getMyTasksResponse::result)
			soap_pop_block(soap, soap_blist_result1);
		if (a->ns1__getMyTasksResponse::__sizeresult)
			a->ns1__getMyTasksResponse::result = (ns1__wfTask **)soap_save_block(soap, soap_blist_result1, NULL, 1);
		else
		{	a->ns1__getMyTasksResponse::result = NULL;
			if (soap_blist_result1)
				soap_end_block(soap, soap_blist_result1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getMyTasksResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getMyTasksResponse, 0, sizeof(ns1__getMyTasksResponse), 0, soap_copy_ns1__getMyTasksResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getMyTasksResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getMyTasksResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getMyTasksResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getMyTasksResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getMyTasksResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getMyTasksResponse * SOAP_FMAC4 soap_get_ns1__getMyTasksResponse(struct soap *soap, ns1__getMyTasksResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getMyTasksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getMyTasksResponse * SOAP_FMAC2 soap_instantiate_ns1__getMyTasksResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getMyTasksResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getMyTasksResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getMyTasksResponse);
		if (size)
			*size = sizeof(ns1__getMyTasksResponse);
		((ns1__getMyTasksResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getMyTasksResponse, n);
		if (size)
			*size = n * sizeof(ns1__getMyTasksResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getMyTasksResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getMyTasksResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getMyTasksResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getMyTasksResponse %p -> %p\n", q, p));
	*(ns1__getMyTasksResponse*)p = *(ns1__getMyTasksResponse*)q;
}

void ns1__batchPresentation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__batchPresentation::id = NULL;
	this->ns1__batchPresentation::version = NULL;
	this->ns1__batchPresentation::type = NULL;
	this->ns1__batchPresentation::category = NULL;
	this->ns1__batchPresentation::name = NULL;
	soap_default_bool(soap, &this->ns1__batchPresentation::active);
	soap_default_int(soap, &this->ns1__batchPresentation::rangeSize);
	soap_default_int(soap, &this->ns1__batchPresentation::pageNumber);
	this->ns1__batchPresentation::fieldsData = NULL;
	this->ns1__batchPresentation::createDate = NULL;
	soap_default_bool(soap, &this->ns1__batchPresentation::shared);
}

void ns1__batchPresentation::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->ns1__batchPresentation::id);
	soap_serialize_PointerToLONG64(soap, &this->ns1__batchPresentation::version);
	soap_serialize_PointerTons1__classPresentationType(soap, &this->ns1__batchPresentation::type);
	soap_serialize_wstring(soap, &this->ns1__batchPresentation::category);
	soap_serialize_wstring(soap, &this->ns1__batchPresentation::name);
	soap_embedded(soap, &this->ns1__batchPresentation::rangeSize, SOAP_TYPE_int);
	soap_embedded(soap, &this->ns1__batchPresentation::pageNumber, SOAP_TYPE_int);
	soap_serialize_PointerToxsd__base64Binary(soap, &this->ns1__batchPresentation::fieldsData);
	soap_serialize_PointerTotime(soap, &this->ns1__batchPresentation::createDate);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__batchPresentation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__batchPresentation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__batchPresentation(struct soap *soap, const char *tag, int id, const ns1__batchPresentation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__batchPresentation), "ns1:batchPresentation"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__batchPresentation::id), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "version", -1, &(a->ns1__batchPresentation::version), ""))
		return soap->error;
	if (soap_out_PointerTons1__classPresentationType(soap, "type", -1, &(a->ns1__batchPresentation::type), ""))
		return soap->error;
	if (soap_out_wstring(soap, "category", -1, &(a->ns1__batchPresentation::category), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__batchPresentation::name), ""))
		return soap->error;
	if (soap_out_bool(soap, "active", -1, &(a->ns1__batchPresentation::active), ""))
		return soap->error;
	if (soap_out_int(soap, "rangeSize", -1, &(a->ns1__batchPresentation::rangeSize), ""))
		return soap->error;
	if (soap_out_int(soap, "pageNumber", -1, &(a->ns1__batchPresentation::pageNumber), ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "fieldsData", -1, &(a->ns1__batchPresentation::fieldsData), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "createDate", -1, &(a->ns1__batchPresentation::createDate), ""))
		return soap->error;
	if (soap_out_bool(soap, "shared", -1, &(a->ns1__batchPresentation::shared), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__batchPresentation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__batchPresentation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__batchPresentation * SOAP_FMAC4 soap_in_ns1__batchPresentation(struct soap *soap, const char *tag, ns1__batchPresentation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__batchPresentation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__batchPresentation, sizeof(ns1__batchPresentation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__batchPresentation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__batchPresentation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_version1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_category1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_active1 = 1;
	size_t soap_flag_rangeSize1 = 1;
	size_t soap_flag_pageNumber1 = 1;
	size_t soap_flag_fieldsData1 = 1;
	size_t soap_flag_createDate1 = 1;
	size_t soap_flag_shared1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__batchPresentation::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_version1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "version", &(a->ns1__batchPresentation::version), "xsd:long"))
				{	soap_flag_version1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__classPresentationType(soap, "type", &(a->ns1__batchPresentation::type), "ns1:classPresentationType"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_category1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "category", &(a->ns1__batchPresentation::category), "xsd:string"))
				{	soap_flag_category1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__batchPresentation::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_active1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "active", &(a->ns1__batchPresentation::active), "xsd:boolean"))
				{	soap_flag_active1--;
					continue;
				}
			if (soap_flag_rangeSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "rangeSize", &(a->ns1__batchPresentation::rangeSize), "xsd:int"))
				{	soap_flag_rangeSize1--;
					continue;
				}
			if (soap_flag_pageNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "pageNumber", &(a->ns1__batchPresentation::pageNumber), "xsd:int"))
				{	soap_flag_pageNumber1--;
					continue;
				}
			if (soap_flag_fieldsData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "fieldsData", &(a->ns1__batchPresentation::fieldsData), "xsd:base64Binary"))
				{	soap_flag_fieldsData1--;
					continue;
				}
			if (soap_flag_createDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "createDate", &(a->ns1__batchPresentation::createDate), "xsd:dateTime"))
				{	soap_flag_createDate1--;
					continue;
				}
			if (soap_flag_shared1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "shared", &(a->ns1__batchPresentation::shared), "xsd:boolean"))
				{	soap_flag_shared1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__batchPresentation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__batchPresentation, 0, sizeof(ns1__batchPresentation), 0, soap_copy_ns1__batchPresentation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_active1 > 0 || soap_flag_rangeSize1 > 0 || soap_flag_pageNumber1 > 0 || soap_flag_shared1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__batchPresentation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__batchPresentation);
	if (this->soap_out(soap, tag?tag:"ns1:batchPresentation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__batchPresentation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__batchPresentation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__batchPresentation * SOAP_FMAC4 soap_get_ns1__batchPresentation(struct soap *soap, ns1__batchPresentation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__batchPresentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__batchPresentation * SOAP_FMAC2 soap_instantiate_ns1__batchPresentation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__batchPresentation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__batchPresentation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__batchPresentation);
		if (size)
			*size = sizeof(ns1__batchPresentation);
		((ns1__batchPresentation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__batchPresentation, n);
		if (size)
			*size = n * sizeof(ns1__batchPresentation);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__batchPresentation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__batchPresentation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__batchPresentation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__batchPresentation %p -> %p\n", q, p));
	*(ns1__batchPresentation*)p = *(ns1__batchPresentation*)q;
}

void ns1__getMyTasks::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__getMyTasks::user = NULL;
	this->ns1__getMyTasks::batchPresentation = NULL;
}

void ns1__getMyTasks::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__getMyTasks::user);
	soap_serialize_PointerTons1__batchPresentation(soap, &this->ns1__getMyTasks::batchPresentation);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__getMyTasks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getMyTasks(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getMyTasks(struct soap *soap, const char *tag, int id, const ns1__getMyTasks *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getMyTasks), "ns1:getMyTasks"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "user", -1, &(a->ns1__getMyTasks::user), ""))
		return soap->error;
	if (soap_out_PointerTons1__batchPresentation(soap, "batchPresentation", -1, &(a->ns1__getMyTasks::batchPresentation), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__getMyTasks::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getMyTasks(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getMyTasks * SOAP_FMAC4 soap_in_ns1__getMyTasks(struct soap *soap, const char *tag, ns1__getMyTasks *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getMyTasks *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getMyTasks, sizeof(ns1__getMyTasks), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getMyTasks)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getMyTasks *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_batchPresentation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "user", &(a->ns1__getMyTasks::user), "ns1:user"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_batchPresentation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__batchPresentation(soap, "batchPresentation", &(a->ns1__getMyTasks::batchPresentation), "ns1:batchPresentation"))
				{	soap_flag_batchPresentation1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getMyTasks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getMyTasks, 0, sizeof(ns1__getMyTasks), 0, soap_copy_ns1__getMyTasks);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getMyTasks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getMyTasks);
	if (this->soap_out(soap, tag?tag:"ns1:getMyTasks", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getMyTasks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getMyTasks(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getMyTasks * SOAP_FMAC4 soap_get_ns1__getMyTasks(struct soap *soap, ns1__getMyTasks *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getMyTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getMyTasks * SOAP_FMAC2 soap_instantiate_ns1__getMyTasks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getMyTasks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getMyTasks, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getMyTasks);
		if (size)
			*size = sizeof(ns1__getMyTasks);
		((ns1__getMyTasks*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getMyTasks, n);
		if (size)
			*size = n * sizeof(ns1__getMyTasks);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getMyTasks*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getMyTasks*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getMyTasks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getMyTasks %p -> %p\n", q, p));
	*(ns1__getMyTasks*)p = *(ns1__getMyTasks*)q;
}

void ns1__authenticateByCallerPrincipalResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__authenticateByCallerPrincipalResponse::result = NULL;
}

void ns1__authenticateByCallerPrincipalResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__authenticateByCallerPrincipalResponse::result);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__authenticateByCallerPrincipalResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__authenticateByCallerPrincipalResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__authenticateByCallerPrincipalResponse(struct soap *soap, const char *tag, int id, const ns1__authenticateByCallerPrincipalResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse), "ns1:authenticateByCallerPrincipalResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "result", -1, &(a->ns1__authenticateByCallerPrincipalResponse::result), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__authenticateByCallerPrincipalResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__authenticateByCallerPrincipalResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__authenticateByCallerPrincipalResponse * SOAP_FMAC4 soap_in_ns1__authenticateByCallerPrincipalResponse(struct soap *soap, const char *tag, ns1__authenticateByCallerPrincipalResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__authenticateByCallerPrincipalResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse, sizeof(ns1__authenticateByCallerPrincipalResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__authenticateByCallerPrincipalResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "result", &(a->ns1__authenticateByCallerPrincipalResponse::result), "ns1:user"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__authenticateByCallerPrincipalResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse, 0, sizeof(ns1__authenticateByCallerPrincipalResponse), 0, soap_copy_ns1__authenticateByCallerPrincipalResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__authenticateByCallerPrincipalResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse);
	if (this->soap_out(soap, tag?tag:"ns1:authenticateByCallerPrincipalResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__authenticateByCallerPrincipalResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__authenticateByCallerPrincipalResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__authenticateByCallerPrincipalResponse * SOAP_FMAC4 soap_get_ns1__authenticateByCallerPrincipalResponse(struct soap *soap, ns1__authenticateByCallerPrincipalResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__authenticateByCallerPrincipalResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__authenticateByCallerPrincipalResponse * SOAP_FMAC2 soap_instantiate_ns1__authenticateByCallerPrincipalResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__authenticateByCallerPrincipalResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByCallerPrincipalResponse);
		if (size)
			*size = sizeof(ns1__authenticateByCallerPrincipalResponse);
		((ns1__authenticateByCallerPrincipalResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByCallerPrincipalResponse, n);
		if (size)
			*size = n * sizeof(ns1__authenticateByCallerPrincipalResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__authenticateByCallerPrincipalResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__authenticateByCallerPrincipalResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__authenticateByCallerPrincipalResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__authenticateByCallerPrincipalResponse %p -> %p\n", q, p));
	*(ns1__authenticateByCallerPrincipalResponse*)p = *(ns1__authenticateByCallerPrincipalResponse*)q;
}

void ns1__authenticateByCallerPrincipal::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void ns1__authenticateByCallerPrincipal::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__authenticateByCallerPrincipal::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__authenticateByCallerPrincipal(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__authenticateByCallerPrincipal(struct soap *soap, const char *tag, int id, const ns1__authenticateByCallerPrincipal *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:authenticateByCallerPrincipal");
}

void *ns1__authenticateByCallerPrincipal::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__authenticateByCallerPrincipal(soap, tag, this, type);
}

SOAP_FMAC3 ns1__authenticateByCallerPrincipal * SOAP_FMAC4 soap_in_ns1__authenticateByCallerPrincipal(struct soap *soap, const char *tag, ns1__authenticateByCallerPrincipal *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__authenticateByCallerPrincipal *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__authenticateByCallerPrincipal, sizeof(ns1__authenticateByCallerPrincipal), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__authenticateByCallerPrincipal)
			return (ns1__authenticateByCallerPrincipal *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__authenticateByCallerPrincipal::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__authenticateByCallerPrincipal);
	if (this->soap_out(soap, tag?tag:"ns1:authenticateByCallerPrincipal", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__authenticateByCallerPrincipal::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__authenticateByCallerPrincipal(soap, this, tag, type);
}

SOAP_FMAC3 ns1__authenticateByCallerPrincipal * SOAP_FMAC4 soap_get_ns1__authenticateByCallerPrincipal(struct soap *soap, ns1__authenticateByCallerPrincipal *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__authenticateByCallerPrincipal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__authenticateByCallerPrincipal * SOAP_FMAC2 soap_instantiate_ns1__authenticateByCallerPrincipal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__authenticateByCallerPrincipal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__authenticateByCallerPrincipal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByCallerPrincipal);
		if (size)
			*size = sizeof(ns1__authenticateByCallerPrincipal);
		((ns1__authenticateByCallerPrincipal*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByCallerPrincipal, n);
		if (size)
			*size = n * sizeof(ns1__authenticateByCallerPrincipal);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__authenticateByCallerPrincipal*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__authenticateByCallerPrincipal*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__authenticateByCallerPrincipal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__authenticateByCallerPrincipal %p -> %p\n", q, p));
	*(ns1__authenticateByCallerPrincipal*)p = *(ns1__authenticateByCallerPrincipal*)q;
}

void ns1__authenticateByTrustedPrincipalResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__authenticateByTrustedPrincipalResponse::result = NULL;
}

void ns1__authenticateByTrustedPrincipalResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__authenticateByTrustedPrincipalResponse::result);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__authenticateByTrustedPrincipalResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__authenticateByTrustedPrincipalResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__authenticateByTrustedPrincipalResponse(struct soap *soap, const char *tag, int id, const ns1__authenticateByTrustedPrincipalResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse), "ns1:authenticateByTrustedPrincipalResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "result", -1, &(a->ns1__authenticateByTrustedPrincipalResponse::result), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__authenticateByTrustedPrincipalResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__authenticateByTrustedPrincipalResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__authenticateByTrustedPrincipalResponse * SOAP_FMAC4 soap_in_ns1__authenticateByTrustedPrincipalResponse(struct soap *soap, const char *tag, ns1__authenticateByTrustedPrincipalResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__authenticateByTrustedPrincipalResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse, sizeof(ns1__authenticateByTrustedPrincipalResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__authenticateByTrustedPrincipalResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "result", &(a->ns1__authenticateByTrustedPrincipalResponse::result), "ns1:user"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__authenticateByTrustedPrincipalResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse, 0, sizeof(ns1__authenticateByTrustedPrincipalResponse), 0, soap_copy_ns1__authenticateByTrustedPrincipalResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__authenticateByTrustedPrincipalResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse);
	if (this->soap_out(soap, tag?tag:"ns1:authenticateByTrustedPrincipalResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__authenticateByTrustedPrincipalResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__authenticateByTrustedPrincipalResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__authenticateByTrustedPrincipalResponse * SOAP_FMAC4 soap_get_ns1__authenticateByTrustedPrincipalResponse(struct soap *soap, ns1__authenticateByTrustedPrincipalResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__authenticateByTrustedPrincipalResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__authenticateByTrustedPrincipalResponse * SOAP_FMAC2 soap_instantiate_ns1__authenticateByTrustedPrincipalResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__authenticateByTrustedPrincipalResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByTrustedPrincipalResponse);
		if (size)
			*size = sizeof(ns1__authenticateByTrustedPrincipalResponse);
		((ns1__authenticateByTrustedPrincipalResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByTrustedPrincipalResponse, n);
		if (size)
			*size = n * sizeof(ns1__authenticateByTrustedPrincipalResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__authenticateByTrustedPrincipalResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__authenticateByTrustedPrincipalResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__authenticateByTrustedPrincipalResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__authenticateByTrustedPrincipalResponse %p -> %p\n", q, p));
	*(ns1__authenticateByTrustedPrincipalResponse*)p = *(ns1__authenticateByTrustedPrincipalResponse*)q;
}

void ns1__authenticateByTrustedPrincipal::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__authenticateByTrustedPrincipal::serviceUser = NULL;
	this->ns1__authenticateByTrustedPrincipal::login = NULL;
}

void ns1__authenticateByTrustedPrincipal::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__authenticateByTrustedPrincipal::serviceUser);
	soap_serialize_wstring(soap, &this->ns1__authenticateByTrustedPrincipal::login);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__authenticateByTrustedPrincipal::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__authenticateByTrustedPrincipal(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__authenticateByTrustedPrincipal(struct soap *soap, const char *tag, int id, const ns1__authenticateByTrustedPrincipal *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__authenticateByTrustedPrincipal), "ns1:authenticateByTrustedPrincipal"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "serviceUser", -1, &(a->ns1__authenticateByTrustedPrincipal::serviceUser), ""))
		return soap->error;
	if (soap_out_wstring(soap, "login", -1, &(a->ns1__authenticateByTrustedPrincipal::login), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__authenticateByTrustedPrincipal::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__authenticateByTrustedPrincipal(soap, tag, this, type);
}

SOAP_FMAC3 ns1__authenticateByTrustedPrincipal * SOAP_FMAC4 soap_in_ns1__authenticateByTrustedPrincipal(struct soap *soap, const char *tag, ns1__authenticateByTrustedPrincipal *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__authenticateByTrustedPrincipal *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__authenticateByTrustedPrincipal, sizeof(ns1__authenticateByTrustedPrincipal), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__authenticateByTrustedPrincipal)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__authenticateByTrustedPrincipal *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_serviceUser1 = 1;
	size_t soap_flag_login1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_serviceUser1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "serviceUser", &(a->ns1__authenticateByTrustedPrincipal::serviceUser), "ns1:user"))
				{	soap_flag_serviceUser1--;
					continue;
				}
			if (soap_flag_login1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "login", &(a->ns1__authenticateByTrustedPrincipal::login), "xsd:string"))
				{	soap_flag_login1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__authenticateByTrustedPrincipal *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__authenticateByTrustedPrincipal, 0, sizeof(ns1__authenticateByTrustedPrincipal), 0, soap_copy_ns1__authenticateByTrustedPrincipal);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__authenticateByTrustedPrincipal::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__authenticateByTrustedPrincipal);
	if (this->soap_out(soap, tag?tag:"ns1:authenticateByTrustedPrincipal", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__authenticateByTrustedPrincipal::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__authenticateByTrustedPrincipal(soap, this, tag, type);
}

SOAP_FMAC3 ns1__authenticateByTrustedPrincipal * SOAP_FMAC4 soap_get_ns1__authenticateByTrustedPrincipal(struct soap *soap, ns1__authenticateByTrustedPrincipal *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__authenticateByTrustedPrincipal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__authenticateByTrustedPrincipal * SOAP_FMAC2 soap_instantiate_ns1__authenticateByTrustedPrincipal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__authenticateByTrustedPrincipal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__authenticateByTrustedPrincipal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByTrustedPrincipal);
		if (size)
			*size = sizeof(ns1__authenticateByTrustedPrincipal);
		((ns1__authenticateByTrustedPrincipal*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByTrustedPrincipal, n);
		if (size)
			*size = n * sizeof(ns1__authenticateByTrustedPrincipal);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__authenticateByTrustedPrincipal*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__authenticateByTrustedPrincipal*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__authenticateByTrustedPrincipal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__authenticateByTrustedPrincipal %p -> %p\n", q, p));
	*(ns1__authenticateByTrustedPrincipal*)p = *(ns1__authenticateByTrustedPrincipal*)q;
}

void ns1__authenticateByLoginPasswordResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__authenticateByLoginPasswordResponse::result = NULL;
}

void ns1__authenticateByLoginPasswordResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__authenticateByLoginPasswordResponse::result);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__authenticateByLoginPasswordResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__authenticateByLoginPasswordResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__authenticateByLoginPasswordResponse(struct soap *soap, const char *tag, int id, const ns1__authenticateByLoginPasswordResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__authenticateByLoginPasswordResponse), "ns1:authenticateByLoginPasswordResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "result", -1, &(a->ns1__authenticateByLoginPasswordResponse::result), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__authenticateByLoginPasswordResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__authenticateByLoginPasswordResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__authenticateByLoginPasswordResponse * SOAP_FMAC4 soap_in_ns1__authenticateByLoginPasswordResponse(struct soap *soap, const char *tag, ns1__authenticateByLoginPasswordResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__authenticateByLoginPasswordResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__authenticateByLoginPasswordResponse, sizeof(ns1__authenticateByLoginPasswordResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__authenticateByLoginPasswordResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__authenticateByLoginPasswordResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "result", &(a->ns1__authenticateByLoginPasswordResponse::result), "ns1:user"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__authenticateByLoginPasswordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__authenticateByLoginPasswordResponse, 0, sizeof(ns1__authenticateByLoginPasswordResponse), 0, soap_copy_ns1__authenticateByLoginPasswordResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__authenticateByLoginPasswordResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__authenticateByLoginPasswordResponse);
	if (this->soap_out(soap, tag?tag:"ns1:authenticateByLoginPasswordResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__authenticateByLoginPasswordResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__authenticateByLoginPasswordResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__authenticateByLoginPasswordResponse * SOAP_FMAC4 soap_get_ns1__authenticateByLoginPasswordResponse(struct soap *soap, ns1__authenticateByLoginPasswordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__authenticateByLoginPasswordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__authenticateByLoginPasswordResponse * SOAP_FMAC2 soap_instantiate_ns1__authenticateByLoginPasswordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__authenticateByLoginPasswordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__authenticateByLoginPasswordResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByLoginPasswordResponse);
		if (size)
			*size = sizeof(ns1__authenticateByLoginPasswordResponse);
		((ns1__authenticateByLoginPasswordResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByLoginPasswordResponse, n);
		if (size)
			*size = n * sizeof(ns1__authenticateByLoginPasswordResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__authenticateByLoginPasswordResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__authenticateByLoginPasswordResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__authenticateByLoginPasswordResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__authenticateByLoginPasswordResponse %p -> %p\n", q, p));
	*(ns1__authenticateByLoginPasswordResponse*)p = *(ns1__authenticateByLoginPasswordResponse*)q;
}

void ns1__authenticateByLoginPassword::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__authenticateByLoginPassword::name = NULL;
	this->ns1__authenticateByLoginPassword::password = NULL;
}

void ns1__authenticateByLoginPassword::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__authenticateByLoginPassword::name);
	soap_serialize_wstring(soap, &this->ns1__authenticateByLoginPassword::password);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__authenticateByLoginPassword::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__authenticateByLoginPassword(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__authenticateByLoginPassword(struct soap *soap, const char *tag, int id, const ns1__authenticateByLoginPassword *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__authenticateByLoginPassword), "ns1:authenticateByLoginPassword"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__authenticateByLoginPassword::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "password", -1, &(a->ns1__authenticateByLoginPassword::password), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__authenticateByLoginPassword::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__authenticateByLoginPassword(soap, tag, this, type);
}

SOAP_FMAC3 ns1__authenticateByLoginPassword * SOAP_FMAC4 soap_in_ns1__authenticateByLoginPassword(struct soap *soap, const char *tag, ns1__authenticateByLoginPassword *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__authenticateByLoginPassword *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__authenticateByLoginPassword, sizeof(ns1__authenticateByLoginPassword), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__authenticateByLoginPassword)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__authenticateByLoginPassword *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__authenticateByLoginPassword::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "password", &(a->ns1__authenticateByLoginPassword::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__authenticateByLoginPassword *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__authenticateByLoginPassword, 0, sizeof(ns1__authenticateByLoginPassword), 0, soap_copy_ns1__authenticateByLoginPassword);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__authenticateByLoginPassword::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__authenticateByLoginPassword);
	if (this->soap_out(soap, tag?tag:"ns1:authenticateByLoginPassword", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__authenticateByLoginPassword::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__authenticateByLoginPassword(soap, this, tag, type);
}

SOAP_FMAC3 ns1__authenticateByLoginPassword * SOAP_FMAC4 soap_get_ns1__authenticateByLoginPassword(struct soap *soap, ns1__authenticateByLoginPassword *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__authenticateByLoginPassword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__authenticateByLoginPassword * SOAP_FMAC2 soap_instantiate_ns1__authenticateByLoginPassword(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__authenticateByLoginPassword(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__authenticateByLoginPassword, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByLoginPassword);
		if (size)
			*size = sizeof(ns1__authenticateByLoginPassword);
		((ns1__authenticateByLoginPassword*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByLoginPassword, n);
		if (size)
			*size = n * sizeof(ns1__authenticateByLoginPassword);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__authenticateByLoginPassword*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__authenticateByLoginPassword*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__authenticateByLoginPassword(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__authenticateByLoginPassword %p -> %p\n", q, p));
	*(ns1__authenticateByLoginPassword*)p = *(ns1__authenticateByLoginPassword*)q;
}

void ns1__wfExecutor::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__executor::soap_default(soap);
	this->ns1__wfExecutor::executorClassName = NULL;
}

void ns1__wfExecutor::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__wfExecutor::executorClassName);
	this->ns1__executor::soap_serialize(soap);
#endif
}

int ns1__wfExecutor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__wfExecutor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__wfExecutor(struct soap *soap, const char *tag, int id, const ns1__wfExecutor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__wfExecutor), "ns1:wfExecutor"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__executor::id), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "version", -1, &(a->ns1__executor::version), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__executor::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "description", -1, &(a->ns1__executor::description), ""))
		return soap->error;
	if (soap_out_wstring(soap, "fullName", -1, &(a->ns1__executor::fullName), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "createDate", -1, &(a->ns1__executor::createDate), ""))
		return soap->error;
	if (soap_out_wstring(soap, "executorClassName", -1, &(a->ns1__wfExecutor::executorClassName), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__wfExecutor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__wfExecutor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__wfExecutor * SOAP_FMAC4 soap_in_ns1__wfExecutor(struct soap *soap, const char *tag, ns1__wfExecutor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__wfExecutor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__wfExecutor, sizeof(ns1__wfExecutor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__wfExecutor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__wfExecutor *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item5 = 1;
	size_t soap_flag_id2 = 1;
	size_t soap_flag_version2 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_description2 = 1;
	size_t soap_flag_fullName2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_executorClassName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__executor::id), "xsd:long"))
				{	soap_flag_id2--;
					continue;
				}
			if (soap_flag_version2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "version", &(a->ns1__executor::version), "xsd:long"))
				{	soap_flag_version2--;
					continue;
				}
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__executor::name), "xsd:string"))
				{	soap_flag_name2--;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "description", &(a->ns1__executor::description), "xsd:string"))
				{	soap_flag_description2--;
					continue;
				}
			if (soap_flag_fullName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "fullName", &(a->ns1__executor::fullName), "xsd:string"))
				{	soap_flag_fullName2--;
					continue;
				}
			if (soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "createDate", &(a->ns1__executor::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if (soap_flag_executorClassName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "executorClassName", &(a->ns1__wfExecutor::executorClassName), "xsd:string"))
				{	soap_flag_executorClassName1--;
					continue;
				}
			if (soap_flag___item5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item5--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__wfExecutor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__wfExecutor, 0, sizeof(ns1__wfExecutor), 0, soap_copy_ns1__wfExecutor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__wfExecutor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__wfExecutor);
	if (this->soap_out(soap, tag?tag:"ns1:wfExecutor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__wfExecutor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__wfExecutor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__wfExecutor * SOAP_FMAC4 soap_get_ns1__wfExecutor(struct soap *soap, ns1__wfExecutor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__wfExecutor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__wfExecutor * SOAP_FMAC2 soap_instantiate_ns1__wfExecutor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__wfExecutor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__wfExecutor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__wfExecutor);
		if (size)
			*size = sizeof(ns1__wfExecutor);
		((ns1__wfExecutor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wfExecutor, n);
		if (size)
			*size = n * sizeof(ns1__wfExecutor);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__wfExecutor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__wfExecutor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__wfExecutor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__wfExecutor %p -> %p\n", q, p));
	*(ns1__wfExecutor*)p = *(ns1__wfExecutor*)q;
}

void ns1__identifiable::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void ns1__identifiable::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__identifiable::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__identifiable(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__identifiable(struct soap *soap, const char *tag, int id, const ns1__identifiable *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:identifiable");
}

void *ns1__identifiable::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__identifiable(soap, tag, this, type);
}

SOAP_FMAC3 ns1__identifiable * SOAP_FMAC4 soap_in_ns1__identifiable(struct soap *soap, const char *tag, ns1__identifiable *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__identifiable *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__identifiable, sizeof(ns1__identifiable), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__identifiable)
			return (ns1__identifiable *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__identifiable::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__identifiable);
	if (this->soap_out(soap, tag?tag:"ns1:identifiable", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__identifiable::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__identifiable(soap, this, tag, type);
}

SOAP_FMAC3 ns1__identifiable * SOAP_FMAC4 soap_get_ns1__identifiable(struct soap *soap, ns1__identifiable *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__identifiable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__identifiable * SOAP_FMAC2 soap_instantiate_ns1__identifiable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__identifiable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__identifiable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:identifiableBase"))
	{	cp->type = SOAP_TYPE_ns1__identifiableBase;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__identifiableBase);
			if (size)
				*size = sizeof(ns1__identifiableBase);
			((ns1__identifiableBase*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__identifiableBase, n);
			if (size)
				*size = n * sizeof(ns1__identifiableBase);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__identifiableBase*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__identifiableBase*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:executor"))
	{	cp->type = SOAP_TYPE_ns1__executor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__executor);
			if (size)
				*size = sizeof(ns1__executor);
			((ns1__executor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__executor, n);
			if (size)
				*size = n * sizeof(ns1__executor);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__executor*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__executor*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:actor"))
	{	cp->type = SOAP_TYPE_ns1__actor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__actor);
			if (size)
				*size = sizeof(ns1__actor);
			((ns1__actor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__actor, n);
			if (size)
				*size = n * sizeof(ns1__actor);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__actor*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__actor*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:wfExecutor"))
	{	cp->type = SOAP_TYPE_ns1__wfExecutor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__wfExecutor);
			if (size)
				*size = sizeof(ns1__wfExecutor);
			((ns1__wfExecutor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wfExecutor, n);
			if (size)
				*size = n * sizeof(ns1__wfExecutor);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__wfExecutor*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__wfExecutor*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__identifiable);
		if (size)
			*size = sizeof(ns1__identifiable);
		((ns1__identifiable*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__identifiable, n);
		if (size)
			*size = n * sizeof(ns1__identifiable);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__identifiable*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__identifiable*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__identifiable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__identifiable %p -> %p\n", q, p));
	*(ns1__identifiable*)p = *(ns1__identifiable*)q;
}

void ns1__identifiableBase::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__identifiable::soap_default(soap);
}

void ns1__identifiableBase::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns1__identifiable::soap_serialize(soap);
#endif
}

int ns1__identifiableBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__identifiableBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__identifiableBase(struct soap *soap, const char *tag, int id, const ns1__identifiableBase *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns1:identifiableBase");
}

void *ns1__identifiableBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__identifiableBase(soap, tag, this, type);
}

SOAP_FMAC3 ns1__identifiableBase * SOAP_FMAC4 soap_in_ns1__identifiableBase(struct soap *soap, const char *tag, ns1__identifiableBase *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__identifiableBase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__identifiableBase, sizeof(ns1__identifiableBase), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__identifiableBase)
			return (ns1__identifiableBase *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns1__identifiableBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__identifiableBase);
	if (this->soap_out(soap, tag?tag:"ns1:identifiableBase", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__identifiableBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__identifiableBase(soap, this, tag, type);
}

SOAP_FMAC3 ns1__identifiableBase * SOAP_FMAC4 soap_get_ns1__identifiableBase(struct soap *soap, ns1__identifiableBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__identifiableBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__identifiableBase * SOAP_FMAC2 soap_instantiate_ns1__identifiableBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__identifiableBase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__identifiableBase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:executor"))
	{	cp->type = SOAP_TYPE_ns1__executor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__executor);
			if (size)
				*size = sizeof(ns1__executor);
			((ns1__executor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__executor, n);
			if (size)
				*size = n * sizeof(ns1__executor);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__executor*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__executor*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:actor"))
	{	cp->type = SOAP_TYPE_ns1__actor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__actor);
			if (size)
				*size = sizeof(ns1__actor);
			((ns1__actor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__actor, n);
			if (size)
				*size = n * sizeof(ns1__actor);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__actor*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__actor*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:wfExecutor"))
	{	cp->type = SOAP_TYPE_ns1__wfExecutor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__wfExecutor);
			if (size)
				*size = sizeof(ns1__wfExecutor);
			((ns1__wfExecutor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wfExecutor, n);
			if (size)
				*size = n * sizeof(ns1__wfExecutor);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__wfExecutor*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__wfExecutor*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__identifiableBase);
		if (size)
			*size = sizeof(ns1__identifiableBase);
		((ns1__identifiableBase*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__identifiableBase, n);
		if (size)
			*size = n * sizeof(ns1__identifiableBase);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__identifiableBase*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__identifiableBase*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__identifiableBase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__identifiableBase %p -> %p\n", q, p));
	*(ns1__identifiableBase*)p = *(ns1__identifiableBase*)q;
}

void ns1__executor::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__identifiableBase::soap_default(soap);
	this->ns1__executor::id = NULL;
	this->ns1__executor::version = NULL;
	this->ns1__executor::name = NULL;
	this->ns1__executor::description = NULL;
	this->ns1__executor::fullName = NULL;
	this->ns1__executor::createDate = NULL;
}

void ns1__executor::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->ns1__executor::id);
	soap_serialize_PointerToLONG64(soap, &this->ns1__executor::version);
	soap_serialize_wstring(soap, &this->ns1__executor::name);
	soap_serialize_wstring(soap, &this->ns1__executor::description);
	soap_serialize_wstring(soap, &this->ns1__executor::fullName);
	soap_serialize_PointerTotime(soap, &this->ns1__executor::createDate);
	this->ns1__identifiableBase::soap_serialize(soap);
#endif
}

int ns1__executor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__executor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__executor(struct soap *soap, const char *tag, int id, const ns1__executor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__executor), "ns1:executor"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__executor::id), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "version", -1, &(a->ns1__executor::version), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__executor::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "description", -1, &(a->ns1__executor::description), ""))
		return soap->error;
	if (soap_out_wstring(soap, "fullName", -1, &(a->ns1__executor::fullName), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "createDate", -1, &(a->ns1__executor::createDate), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__executor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__executor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__executor * SOAP_FMAC4 soap_in_ns1__executor(struct soap *soap, const char *tag, ns1__executor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__executor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__executor, sizeof(ns1__executor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__executor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__executor *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item4 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_version1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_fullName1 = 1;
	size_t soap_flag_createDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__executor::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_version1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "version", &(a->ns1__executor::version), "xsd:long"))
				{	soap_flag_version1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__executor::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "description", &(a->ns1__executor::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_fullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "fullName", &(a->ns1__executor::fullName), "xsd:string"))
				{	soap_flag_fullName1--;
					continue;
				}
			if (soap_flag_createDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "createDate", &(a->ns1__executor::createDate), "xsd:dateTime"))
				{	soap_flag_createDate1--;
					continue;
				}
			if (soap_flag___item4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item4--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__executor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__executor, 0, sizeof(ns1__executor), 0, soap_copy_ns1__executor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__executor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__executor);
	if (this->soap_out(soap, tag?tag:"ns1:executor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__executor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__executor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__executor * SOAP_FMAC4 soap_get_ns1__executor(struct soap *soap, ns1__executor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__executor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__executor * SOAP_FMAC2 soap_instantiate_ns1__executor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__executor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__executor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:actor"))
	{	cp->type = SOAP_TYPE_ns1__actor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__actor);
			if (size)
				*size = sizeof(ns1__actor);
			((ns1__actor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__actor, n);
			if (size)
				*size = n * sizeof(ns1__actor);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__actor*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__actor*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:wfExecutor"))
	{	cp->type = SOAP_TYPE_ns1__wfExecutor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__wfExecutor);
			if (size)
				*size = sizeof(ns1__wfExecutor);
			((ns1__wfExecutor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wfExecutor, n);
			if (size)
				*size = n * sizeof(ns1__wfExecutor);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__wfExecutor*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__wfExecutor*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__executor);
		if (size)
			*size = sizeof(ns1__executor);
		((ns1__executor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__executor, n);
		if (size)
			*size = n * sizeof(ns1__executor);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__executor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__executor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__executor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__executor %p -> %p\n", q, p));
	*(ns1__executor*)p = *(ns1__executor*)q;
}

void ns1__actor::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__executor::soap_default(soap);
	this->ns1__actor::code = NULL;
	soap_default_bool(soap, &this->ns1__actor::active);
	this->ns1__actor::email = NULL;
	this->ns1__actor::phone = NULL;
}

void ns1__actor::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->ns1__actor::code);
	soap_serialize_wstring(soap, &this->ns1__actor::email);
	soap_serialize_wstring(soap, &this->ns1__actor::phone);
	this->ns1__executor::soap_serialize(soap);
#endif
}

int ns1__actor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__actor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__actor(struct soap *soap, const char *tag, int id, const ns1__actor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__actor), "ns1:actor"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToLONG64(soap, "id", -1, &(a->ns1__executor::id), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "version", -1, &(a->ns1__executor::version), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__executor::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "description", -1, &(a->ns1__executor::description), ""))
		return soap->error;
	if (soap_out_wstring(soap, "fullName", -1, &(a->ns1__executor::fullName), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "createDate", -1, &(a->ns1__executor::createDate), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "code", -1, &(a->ns1__actor::code), ""))
		return soap->error;
	if (soap_out_bool(soap, "active", -1, &(a->ns1__actor::active), ""))
		return soap->error;
	if (soap_out_wstring(soap, "email", -1, &(a->ns1__actor::email), ""))
		return soap->error;
	if (soap_out_wstring(soap, "phone", -1, &(a->ns1__actor::phone), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__actor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__actor(soap, tag, this, type);
}

SOAP_FMAC3 ns1__actor * SOAP_FMAC4 soap_in_ns1__actor(struct soap *soap, const char *tag, ns1__actor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__actor *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__actor, sizeof(ns1__actor), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__actor)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__actor *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item5 = 1;
	size_t soap_flag_id2 = 1;
	size_t soap_flag_version2 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_description2 = 1;
	size_t soap_flag_fullName2 = 1;
	size_t soap_flag_createDate2 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_active1 = 1;
	size_t soap_flag_email1 = 1;
	size_t soap_flag_phone1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_id2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "id", &(a->ns1__executor::id), "xsd:long"))
				{	soap_flag_id2--;
					continue;
				}
			if (soap_flag_version2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "version", &(a->ns1__executor::version), "xsd:long"))
				{	soap_flag_version2--;
					continue;
				}
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__executor::name), "xsd:string"))
				{	soap_flag_name2--;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "description", &(a->ns1__executor::description), "xsd:string"))
				{	soap_flag_description2--;
					continue;
				}
			if (soap_flag_fullName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "fullName", &(a->ns1__executor::fullName), "xsd:string"))
				{	soap_flag_fullName2--;
					continue;
				}
			if (soap_flag_createDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "createDate", &(a->ns1__executor::createDate), "xsd:dateTime"))
				{	soap_flag_createDate2--;
					continue;
				}
			if (soap_flag_code1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "code", &(a->ns1__actor::code), "xsd:long"))
				{	soap_flag_code1--;
					continue;
				}
			if (soap_flag_active1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "active", &(a->ns1__actor::active), "xsd:boolean"))
				{	soap_flag_active1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "email", &(a->ns1__actor::email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			if (soap_flag_phone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "phone", &(a->ns1__actor::phone), "xsd:string"))
				{	soap_flag_phone1--;
					continue;
				}
			if (soap_flag___item5 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item5--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__actor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__actor, 0, sizeof(ns1__actor), 0, soap_copy_ns1__actor);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_active1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__actor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__actor);
	if (this->soap_out(soap, tag?tag:"ns1:actor", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__actor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__actor(soap, this, tag, type);
}

SOAP_FMAC3 ns1__actor * SOAP_FMAC4 soap_get_ns1__actor(struct soap *soap, ns1__actor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__actor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__actor * SOAP_FMAC2 soap_instantiate_ns1__actor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__actor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__actor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__actor);
		if (size)
			*size = sizeof(ns1__actor);
		((ns1__actor*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__actor, n);
		if (size)
			*size = n * sizeof(ns1__actor);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__actor*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__actor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__actor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__actor %p -> %p\n", q, p));
	*(ns1__actor*)p = *(ns1__actor*)q;
}

void ns1__user::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__user::actor = NULL;
	this->ns1__user::securedKey = NULL;
}

void ns1__user::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__actor(soap, &this->ns1__user::actor);
	soap_serialize_PointerToxsd__base64Binary(soap, &this->ns1__user::securedKey);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__user::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__user(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__user(struct soap *soap, const char *tag, int id, const ns1__user *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__user), "ns1:user"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__actor(soap, "actor", -1, &(a->ns1__user::actor), ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "securedKey", -1, &(a->ns1__user::securedKey), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__user::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__user(soap, tag, this, type);
}

SOAP_FMAC3 ns1__user * SOAP_FMAC4 soap_in_ns1__user(struct soap *soap, const char *tag, ns1__user *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__user *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__user, sizeof(ns1__user), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__user)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__user *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_actor1 = 1;
	size_t soap_flag_securedKey1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_actor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__actor(soap, "actor", &(a->ns1__user::actor), "ns1:actor"))
				{	soap_flag_actor1--;
					continue;
				}
			if (soap_flag_securedKey1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "securedKey", &(a->ns1__user::securedKey), "xsd:base64Binary"))
				{	soap_flag_securedKey1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__user *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__user, 0, sizeof(ns1__user), 0, soap_copy_ns1__user);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__user::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__user);
	if (this->soap_out(soap, tag?tag:"ns1:user", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__user::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__user(soap, this, tag, type);
}

SOAP_FMAC3 ns1__user * SOAP_FMAC4 soap_get_ns1__user(struct soap *soap, ns1__user *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__user(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__user * SOAP_FMAC2 soap_instantiate_ns1__user(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__user(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__user, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__user);
		if (size)
			*size = sizeof(ns1__user);
		((ns1__user*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__user, n);
		if (size)
			*size = n * sizeof(ns1__user);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__user*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__user*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__user(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__user %p -> %p\n", q, p));
	*(ns1__user*)p = *(ns1__user*)q;
}

void ns1__authenticateByKerberosResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__authenticateByKerberosResponse::result = NULL;
}

void ns1__authenticateByKerberosResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user(soap, &this->ns1__authenticateByKerberosResponse::result);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__authenticateByKerberosResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__authenticateByKerberosResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__authenticateByKerberosResponse(struct soap *soap, const char *tag, int id, const ns1__authenticateByKerberosResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__authenticateByKerberosResponse), "ns1:authenticateByKerberosResponse"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__user(soap, "result", -1, &(a->ns1__authenticateByKerberosResponse::result), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__authenticateByKerberosResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__authenticateByKerberosResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__authenticateByKerberosResponse * SOAP_FMAC4 soap_in_ns1__authenticateByKerberosResponse(struct soap *soap, const char *tag, ns1__authenticateByKerberosResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__authenticateByKerberosResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__authenticateByKerberosResponse, sizeof(ns1__authenticateByKerberosResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__authenticateByKerberosResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__authenticateByKerberosResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user(soap, "result", &(a->ns1__authenticateByKerberosResponse::result), "ns1:user"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__authenticateByKerberosResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__authenticateByKerberosResponse, 0, sizeof(ns1__authenticateByKerberosResponse), 0, soap_copy_ns1__authenticateByKerberosResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__authenticateByKerberosResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__authenticateByKerberosResponse);
	if (this->soap_out(soap, tag?tag:"ns1:authenticateByKerberosResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__authenticateByKerberosResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__authenticateByKerberosResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__authenticateByKerberosResponse * SOAP_FMAC4 soap_get_ns1__authenticateByKerberosResponse(struct soap *soap, ns1__authenticateByKerberosResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__authenticateByKerberosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__authenticateByKerberosResponse * SOAP_FMAC2 soap_instantiate_ns1__authenticateByKerberosResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__authenticateByKerberosResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__authenticateByKerberosResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByKerberosResponse);
		if (size)
			*size = sizeof(ns1__authenticateByKerberosResponse);
		((ns1__authenticateByKerberosResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByKerberosResponse, n);
		if (size)
			*size = n * sizeof(ns1__authenticateByKerberosResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__authenticateByKerberosResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__authenticateByKerberosResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__authenticateByKerberosResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__authenticateByKerberosResponse %p -> %p\n", q, p));
	*(ns1__authenticateByKerberosResponse*)p = *(ns1__authenticateByKerberosResponse*)q;
}

void ns1__authenticateByKerberos::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns1__authenticateByKerberos::token = NULL;
}

void ns1__authenticateByKerberos::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &this->ns1__authenticateByKerberos::token);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns1__authenticateByKerberos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__authenticateByKerberos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__authenticateByKerberos(struct soap *soap, const char *tag, int id, const ns1__authenticateByKerberos *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__authenticateByKerberos), "ns1:authenticateByKerberos"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToxsd__base64Binary(soap, "token", -1, &(a->ns1__authenticateByKerberos::token), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__authenticateByKerberos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__authenticateByKerberos(soap, tag, this, type);
}

SOAP_FMAC3 ns1__authenticateByKerberos * SOAP_FMAC4 soap_in_ns1__authenticateByKerberos(struct soap *soap, const char *tag, ns1__authenticateByKerberos *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__authenticateByKerberos *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__authenticateByKerberos, sizeof(ns1__authenticateByKerberos), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__authenticateByKerberos)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__authenticateByKerberos *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_token1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_token1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "token", &(a->ns1__authenticateByKerberos::token), "xsd:base64Binary"))
				{	soap_flag_token1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__authenticateByKerberos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__authenticateByKerberos, 0, sizeof(ns1__authenticateByKerberos), 0, soap_copy_ns1__authenticateByKerberos);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__authenticateByKerberos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__authenticateByKerberos);
	if (this->soap_out(soap, tag?tag:"ns1:authenticateByKerberos", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__authenticateByKerberos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__authenticateByKerberos(soap, this, tag, type);
}

SOAP_FMAC3 ns1__authenticateByKerberos * SOAP_FMAC4 soap_get_ns1__authenticateByKerberos(struct soap *soap, ns1__authenticateByKerberos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__authenticateByKerberos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__authenticateByKerberos * SOAP_FMAC2 soap_instantiate_ns1__authenticateByKerberos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__authenticateByKerberos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__authenticateByKerberos, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByKerberos);
		if (size)
			*size = sizeof(ns1__authenticateByKerberos);
		((ns1__authenticateByKerberos*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByKerberos, n);
		if (size)
			*size = n * sizeof(ns1__authenticateByKerberos);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__authenticateByKerberos*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__authenticateByKerberos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__authenticateByKerberos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__authenticateByKerberos %p -> %p\n", q, p));
	*(ns1__authenticateByKerberos*)p = *(ns1__authenticateByKerberos*)q;
}

void xsd__string::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->xsd__string::__item = NULL;
}

void xsd__string::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->xsd__string::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__string::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__string(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, const xsd__string *a, const char *type)
{
	return soap_out_wstring(soap, tag, id, &(a->xsd__string::__item), "xsd:string");
}

void *xsd__string::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__string(soap, tag, this, type);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, xsd__string *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__string *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__string, sizeof(xsd__string), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__string)
			return (xsd__string *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_wstring(soap, tag, &(a->xsd__string::__item), "xsd:string"))
		return NULL;
	return a;
}

int xsd__string::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__string);
	if (this->soap_out(soap, tag?tag:"xsd:string", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__string::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__string(soap, this, tag, type);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, xsd__string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__string * SOAP_FMAC2 soap_instantiate_xsd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__string);
		if (size)
			*size = sizeof(xsd__string);
		((xsd__string*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__string, n);
		if (size)
			*size = n * sizeof(xsd__string);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__string*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__string %p -> %p\n", q, p));
	*(xsd__string*)p = *(xsd__string*)q;
}

void xsd__long::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_LONG64(soap, &this->xsd__long::__item);
}

void xsd__long::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__long::__item, SOAP_TYPE_LONG64);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__long::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__long(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__long(struct soap *soap, const char *tag, int id, const xsd__long *a, const char *type)
{
	return soap_out_LONG64(soap, tag, id, &(a->xsd__long::__item), "xsd:long");
}

void *xsd__long::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__long(soap, tag, this, type);
}

SOAP_FMAC3 xsd__long * SOAP_FMAC4 soap_in_xsd__long(struct soap *soap, const char *tag, xsd__long *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__long *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__long, sizeof(xsd__long), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__long)
			return (xsd__long *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_LONG64(soap, tag, &(a->xsd__long::__item), "xsd:long"))
		return NULL;
	return a;
}

int xsd__long::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__long);
	if (this->soap_out(soap, tag?tag:"xsd:long", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__long::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__long(soap, this, tag, type);
}

SOAP_FMAC3 xsd__long * SOAP_FMAC4 soap_get_xsd__long(struct soap *soap, xsd__long *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__long(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__long * SOAP_FMAC2 soap_instantiate_xsd__long(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__long(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__long, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__long);
		if (size)
			*size = sizeof(xsd__long);
		((xsd__long*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__long, n);
		if (size)
			*size = n * sizeof(xsd__long);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__long*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__long*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__long(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__long %p -> %p\n", q, p));
	*(xsd__long*)p = *(xsd__long*)q;
}

void xsd__int::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->xsd__int::__item);
}

void xsd__int::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__int::__item, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__int::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__int(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int(struct soap *soap, const char *tag, int id, const xsd__int *a, const char *type)
{
	return soap_out_int(soap, tag, id, &(a->xsd__int::__item), "xsd:int");
}

void *xsd__int::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__int(soap, tag, this, type);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_in_xsd__int(struct soap *soap, const char *tag, xsd__int *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__int *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__int, sizeof(xsd__int), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__int)
			return (xsd__int *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_int(soap, tag, &(a->xsd__int::__item), "xsd:int"))
		return NULL;
	return a;
}

int xsd__int::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__int);
	if (this->soap_out(soap, tag?tag:"xsd:int", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__int::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__int(soap, this, tag, type);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_get_xsd__int(struct soap *soap, xsd__int *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__int * SOAP_FMAC2 soap_instantiate_xsd__int(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__int(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__int, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__int);
		if (size)
			*size = sizeof(xsd__int);
		((xsd__int*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__int, n);
		if (size)
			*size = n * sizeof(xsd__int);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__int*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__int*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__int(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__int %p -> %p\n", q, p));
	*(xsd__int*)p = *(xsd__int*)q;
}

void xsd__dateTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_time(soap, &this->xsd__dateTime::__item);
}

void xsd__dateTime::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__dateTime::__item, SOAP_TYPE_time);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__dateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__dateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__dateTime(struct soap *soap, const char *tag, int id, const xsd__dateTime *a, const char *type)
{
	return soap_out_time(soap, tag, id, &(a->xsd__dateTime::__item), "xsd:dateTime");
}

void *xsd__dateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__dateTime(soap, tag, this, type);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_in_xsd__dateTime(struct soap *soap, const char *tag, xsd__dateTime *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__dateTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__dateTime, sizeof(xsd__dateTime), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__dateTime)
			return (xsd__dateTime *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_time(soap, tag, &(a->xsd__dateTime::__item), "xsd:dateTime"))
		return NULL;
	return a;
}

int xsd__dateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__dateTime);
	if (this->soap_out(soap, tag?tag:"xsd:dateTime", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__dateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__dateTime(soap, this, tag, type);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_get_xsd__dateTime(struct soap *soap, xsd__dateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__dateTime * SOAP_FMAC2 soap_instantiate_xsd__dateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__dateTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__dateTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__dateTime);
		if (size)
			*size = sizeof(xsd__dateTime);
		((xsd__dateTime*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__dateTime, n);
		if (size)
			*size = n * sizeof(xsd__dateTime);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__dateTime*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__dateTime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__dateTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__dateTime %p -> %p\n", q, p));
	*(xsd__dateTime*)p = *(xsd__dateTime*)q;
}

void xsd__boolean::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->xsd__boolean::__item);
}

void xsd__boolean::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__boolean::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__boolean(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const xsd__boolean *a, const char *type)
{
	return soap_out_bool(soap, tag, id, &(a->xsd__boolean::__item), "xsd:boolean");
}

void *xsd__boolean::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__boolean(soap, tag, this, type);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, xsd__boolean *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__boolean *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(xsd__boolean), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__boolean)
			return (xsd__boolean *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_bool(soap, tag, &(a->xsd__boolean::__item), "xsd:boolean"))
		return NULL;
	return a;
}

int xsd__boolean::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (this->soap_out(soap, tag?tag:"xsd:boolean", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__boolean::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__boolean(soap, this, tag, type);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__boolean * SOAP_FMAC2 soap_instantiate_xsd__boolean(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__boolean(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__boolean, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__boolean);
		if (size)
			*size = sizeof(xsd__boolean);
		((xsd__boolean*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__boolean, n);
		if (size)
			*size = n * sizeof(xsd__boolean);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__boolean*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__boolean*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__boolean(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__boolean %p -> %p\n", q, p));
	*(xsd__boolean*)p = *(xsd__boolean*)q;
}

void xsd__base64Binary_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->xsd__base64Binary_::__item.xsd__base64Binary::soap_default(soap);
}

void xsd__base64Binary_::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__base64Binary_::__item, SOAP_TYPE_xsd__base64Binary);
	this->xsd__base64Binary_::__item.soap_serialize(soap);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__base64Binary_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__base64Binary_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary_(struct soap *soap, const char *tag, int id, const xsd__base64Binary_ *a, const char *type)
{
	return (a->xsd__base64Binary_::__item).soap_out(soap, tag, id, "xsd:base64Binary");
}

void *xsd__base64Binary_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary_ * SOAP_FMAC4 soap_in_xsd__base64Binary_(struct soap *soap, const char *tag, xsd__base64Binary_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__base64Binary_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary_, sizeof(xsd__base64Binary_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__base64Binary_)
			return (xsd__base64Binary_ *)a->soap_in(soap, tag, type);
	}
	if (!(a->xsd__base64Binary_::__item).soap_in(soap, tag, "xsd:base64Binary"))
		return NULL;
	return a;
}

int xsd__base64Binary_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__base64Binary_);
	if (this->soap_out(soap, tag?tag:"xsd:base64Binary", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary_ * SOAP_FMAC4 soap_get_xsd__base64Binary_(struct soap *soap, xsd__base64Binary_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__base64Binary_ * SOAP_FMAC2 soap_instantiate_xsd__base64Binary_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__base64Binary_);
		if (size)
			*size = sizeof(xsd__base64Binary_);
		((xsd__base64Binary_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__base64Binary_, n);
		if (size)
			*size = n * sizeof(xsd__base64Binary_);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__base64Binary_*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__base64Binary_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary_ %p -> %p\n", q, p));
	*(xsd__base64Binary_*)p = *(xsd__base64Binary_*)q;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if (this->id || this->type)
			soap->mode |= SOAP_ENC_DIME;
#endif
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (this->soap_out(soap, tag?tag:"xsd:base64Binary", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__base64Binary);
		if (size)
			*size = sizeof(xsd__base64Binary);
		((xsd__base64Binary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__base64Binary, n);
		if (size)
			*size = n * sizeof(xsd__base64Binary);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__base64Binary*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__base64Binary*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
}

void xsd__anyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__anyType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int xsd__anyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyType(struct soap *soap, const char *tag, int id, const xsd__anyType *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), NULL);
}

void *xsd__anyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__anyType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_in_xsd__anyType(struct soap *soap, const char *tag, xsd__anyType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__anyType)
			return (xsd__anyType *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int xsd__anyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__anyType);
	if (this->soap_out(soap, tag?tag:"xsd:anyType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__anyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, xsd__anyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:base64Binary"))
	{	cp->type = SOAP_TYPE_xsd__base64Binary_;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__base64Binary_);
			if (size)
				*size = sizeof(xsd__base64Binary_);
			((xsd__base64Binary_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__base64Binary_, n);
			if (size)
				*size = n * sizeof(xsd__base64Binary_);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__base64Binary_*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__base64Binary_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:boolean"))
	{	cp->type = SOAP_TYPE_xsd__boolean;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__boolean);
			if (size)
				*size = sizeof(xsd__boolean);
			((xsd__boolean*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__boolean, n);
			if (size)
				*size = n * sizeof(xsd__boolean);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__boolean*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__boolean*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:dateTime"))
	{	cp->type = SOAP_TYPE_xsd__dateTime;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__dateTime);
			if (size)
				*size = sizeof(xsd__dateTime);
			((xsd__dateTime*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__dateTime, n);
			if (size)
				*size = n * sizeof(xsd__dateTime);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__dateTime*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__dateTime*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:int"))
	{	cp->type = SOAP_TYPE_xsd__int;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__int);
			if (size)
				*size = sizeof(xsd__int);
			((xsd__int*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__int, n);
			if (size)
				*size = n * sizeof(xsd__int);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__int*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__int*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:long"))
	{	cp->type = SOAP_TYPE_xsd__long;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__long);
			if (size)
				*size = sizeof(xsd__long);
			((xsd__long*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__long, n);
			if (size)
				*size = n * sizeof(xsd__long);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__long*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__long*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:string"))
	{	cp->type = SOAP_TYPE_xsd__string;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__string);
			if (size)
				*size = sizeof(xsd__string);
			((xsd__string*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__string, n);
			if (size)
				*size = n * sizeof(xsd__string);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__string*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__string*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:classPresentationType"))
	{	cp->type = SOAP_TYPE_ns1__classPresentationType_;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__classPresentationType_);
			if (size)
				*size = sizeof(ns1__classPresentationType_);
			((ns1__classPresentationType_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__classPresentationType_, n);
			if (size)
				*size = n * sizeof(ns1__classPresentationType_);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__classPresentationType_*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__classPresentationType_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:authenticateByKerberos"))
	{	cp->type = SOAP_TYPE_ns1__authenticateByKerberos;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByKerberos);
			if (size)
				*size = sizeof(ns1__authenticateByKerberos);
			((ns1__authenticateByKerberos*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByKerberos, n);
			if (size)
				*size = n * sizeof(ns1__authenticateByKerberos);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__authenticateByKerberos*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__authenticateByKerberos*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:authenticateByKerberosResponse"))
	{	cp->type = SOAP_TYPE_ns1__authenticateByKerberosResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByKerberosResponse);
			if (size)
				*size = sizeof(ns1__authenticateByKerberosResponse);
			((ns1__authenticateByKerberosResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByKerberosResponse, n);
			if (size)
				*size = n * sizeof(ns1__authenticateByKerberosResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__authenticateByKerberosResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__authenticateByKerberosResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:user"))
	{	cp->type = SOAP_TYPE_ns1__user;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__user);
			if (size)
				*size = sizeof(ns1__user);
			((ns1__user*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__user, n);
			if (size)
				*size = n * sizeof(ns1__user);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__user*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__user*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:identifiable"))
	{	cp->type = SOAP_TYPE_ns1__identifiable;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__identifiable);
			if (size)
				*size = sizeof(ns1__identifiable);
			((ns1__identifiable*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__identifiable, n);
			if (size)
				*size = n * sizeof(ns1__identifiable);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__identifiable*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__identifiable*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:authenticateByLoginPassword"))
	{	cp->type = SOAP_TYPE_ns1__authenticateByLoginPassword;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByLoginPassword);
			if (size)
				*size = sizeof(ns1__authenticateByLoginPassword);
			((ns1__authenticateByLoginPassword*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByLoginPassword, n);
			if (size)
				*size = n * sizeof(ns1__authenticateByLoginPassword);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__authenticateByLoginPassword*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__authenticateByLoginPassword*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:authenticateByLoginPasswordResponse"))
	{	cp->type = SOAP_TYPE_ns1__authenticateByLoginPasswordResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByLoginPasswordResponse);
			if (size)
				*size = sizeof(ns1__authenticateByLoginPasswordResponse);
			((ns1__authenticateByLoginPasswordResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByLoginPasswordResponse, n);
			if (size)
				*size = n * sizeof(ns1__authenticateByLoginPasswordResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__authenticateByLoginPasswordResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__authenticateByLoginPasswordResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:authenticateByTrustedPrincipal"))
	{	cp->type = SOAP_TYPE_ns1__authenticateByTrustedPrincipal;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByTrustedPrincipal);
			if (size)
				*size = sizeof(ns1__authenticateByTrustedPrincipal);
			((ns1__authenticateByTrustedPrincipal*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByTrustedPrincipal, n);
			if (size)
				*size = n * sizeof(ns1__authenticateByTrustedPrincipal);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__authenticateByTrustedPrincipal*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__authenticateByTrustedPrincipal*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:authenticateByTrustedPrincipalResponse"))
	{	cp->type = SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByTrustedPrincipalResponse);
			if (size)
				*size = sizeof(ns1__authenticateByTrustedPrincipalResponse);
			((ns1__authenticateByTrustedPrincipalResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByTrustedPrincipalResponse, n);
			if (size)
				*size = n * sizeof(ns1__authenticateByTrustedPrincipalResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__authenticateByTrustedPrincipalResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__authenticateByTrustedPrincipalResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:authenticateByCallerPrincipal"))
	{	cp->type = SOAP_TYPE_ns1__authenticateByCallerPrincipal;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByCallerPrincipal);
			if (size)
				*size = sizeof(ns1__authenticateByCallerPrincipal);
			((ns1__authenticateByCallerPrincipal*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByCallerPrincipal, n);
			if (size)
				*size = n * sizeof(ns1__authenticateByCallerPrincipal);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__authenticateByCallerPrincipal*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__authenticateByCallerPrincipal*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:authenticateByCallerPrincipalResponse"))
	{	cp->type = SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__authenticateByCallerPrincipalResponse);
			if (size)
				*size = sizeof(ns1__authenticateByCallerPrincipalResponse);
			((ns1__authenticateByCallerPrincipalResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__authenticateByCallerPrincipalResponse, n);
			if (size)
				*size = n * sizeof(ns1__authenticateByCallerPrincipalResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__authenticateByCallerPrincipalResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__authenticateByCallerPrincipalResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getMyTasks"))
	{	cp->type = SOAP_TYPE_ns1__getMyTasks;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getMyTasks);
			if (size)
				*size = sizeof(ns1__getMyTasks);
			((ns1__getMyTasks*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getMyTasks, n);
			if (size)
				*size = n * sizeof(ns1__getMyTasks);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getMyTasks*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getMyTasks*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:batchPresentation"))
	{	cp->type = SOAP_TYPE_ns1__batchPresentation;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__batchPresentation);
			if (size)
				*size = sizeof(ns1__batchPresentation);
			((ns1__batchPresentation*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__batchPresentation, n);
			if (size)
				*size = n * sizeof(ns1__batchPresentation);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__batchPresentation*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__batchPresentation*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getMyTasksResponse"))
	{	cp->type = SOAP_TYPE_ns1__getMyTasksResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getMyTasksResponse);
			if (size)
				*size = sizeof(ns1__getMyTasksResponse);
			((ns1__getMyTasksResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getMyTasksResponse, n);
			if (size)
				*size = n * sizeof(ns1__getMyTasksResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getMyTasksResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getMyTasksResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:wfTask"))
	{	cp->type = SOAP_TYPE_ns1__wfTask;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__wfTask);
			if (size)
				*size = sizeof(ns1__wfTask);
			((ns1__wfTask*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wfTask, n);
			if (size)
				*size = n * sizeof(ns1__wfTask);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__wfTask*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__wfTask*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:variableDefinition"))
	{	cp->type = SOAP_TYPE_ns1__variableDefinition;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__variableDefinition);
			if (size)
				*size = sizeof(ns1__variableDefinition);
			((ns1__variableDefinition*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__variableDefinition, n);
			if (size)
				*size = n * sizeof(ns1__variableDefinition);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__variableDefinition*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__variableDefinition*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:userType"))
	{	cp->type = SOAP_TYPE_ns1__userType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__userType);
			if (size)
				*size = sizeof(ns1__userType);
			((ns1__userType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__userType, n);
			if (size)
				*size = n * sizeof(ns1__userType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__userType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__userType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:variableFormat"))
	{	cp->type = SOAP_TYPE_ns1__variableFormat;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__variableFormat);
			if (size)
				*size = sizeof(ns1__variableFormat);
			((ns1__variableFormat*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__variableFormat, n);
			if (size)
				*size = n * sizeof(ns1__variableFormat);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__variableFormat*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__variableFormat*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:markTaskOpened"))
	{	cp->type = SOAP_TYPE_ns1__markTaskOpened;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__markTaskOpened);
			if (size)
				*size = sizeof(ns1__markTaskOpened);
			((ns1__markTaskOpened*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__markTaskOpened, n);
			if (size)
				*size = n * sizeof(ns1__markTaskOpened);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__markTaskOpened*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__markTaskOpened*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:markTaskOpenedResponse"))
	{	cp->type = SOAP_TYPE_ns1__markTaskOpenedResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__markTaskOpenedResponse);
			if (size)
				*size = sizeof(ns1__markTaskOpenedResponse);
			((ns1__markTaskOpenedResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__markTaskOpenedResponse, n);
			if (size)
				*size = n * sizeof(ns1__markTaskOpenedResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__markTaskOpenedResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__markTaskOpenedResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:reassignTask"))
	{	cp->type = SOAP_TYPE_ns1__reassignTask;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__reassignTask);
			if (size)
				*size = sizeof(ns1__reassignTask);
			((ns1__reassignTask*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__reassignTask, n);
			if (size)
				*size = n * sizeof(ns1__reassignTask);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__reassignTask*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__reassignTask*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:reassignTaskResponse"))
	{	cp->type = SOAP_TYPE_ns1__reassignTaskResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__reassignTaskResponse);
			if (size)
				*size = sizeof(ns1__reassignTaskResponse);
			((ns1__reassignTaskResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__reassignTaskResponse, n);
			if (size)
				*size = n * sizeof(ns1__reassignTaskResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__reassignTaskResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__reassignTaskResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:reassignTasks"))
	{	cp->type = SOAP_TYPE_ns1__reassignTasks;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__reassignTasks);
			if (size)
				*size = sizeof(ns1__reassignTasks);
			((ns1__reassignTasks*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__reassignTasks, n);
			if (size)
				*size = n * sizeof(ns1__reassignTasks);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__reassignTasks*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__reassignTasks*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:reassignTasksResponse"))
	{	cp->type = SOAP_TYPE_ns1__reassignTasksResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__reassignTasksResponse);
			if (size)
				*size = sizeof(ns1__reassignTasksResponse);
			((ns1__reassignTasksResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__reassignTasksResponse, n);
			if (size)
				*size = n * sizeof(ns1__reassignTasksResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__reassignTasksResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__reassignTasksResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getTasks"))
	{	cp->type = SOAP_TYPE_ns1__getTasks;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getTasks);
			if (size)
				*size = sizeof(ns1__getTasks);
			((ns1__getTasks*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getTasks, n);
			if (size)
				*size = n * sizeof(ns1__getTasks);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getTasks*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getTasks*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getTasksResponse"))
	{	cp->type = SOAP_TYPE_ns1__getTasksResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getTasksResponse);
			if (size)
				*size = sizeof(ns1__getTasksResponse);
			((ns1__getTasksResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getTasksResponse, n);
			if (size)
				*size = n * sizeof(ns1__getTasksResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getTasksResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getTasksResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:completeTaskWS"))
	{	cp->type = SOAP_TYPE_ns1__completeTaskWS;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__completeTaskWS);
			if (size)
				*size = sizeof(ns1__completeTaskWS);
			((ns1__completeTaskWS*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__completeTaskWS, n);
			if (size)
				*size = n * sizeof(ns1__completeTaskWS);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__completeTaskWS*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__completeTaskWS*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:variable"))
	{	cp->type = SOAP_TYPE_ns1__variable;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__variable);
			if (size)
				*size = sizeof(ns1__variable);
			((ns1__variable*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__variable, n);
			if (size)
				*size = n * sizeof(ns1__variable);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__variable*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__variable*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:completeTaskWSResponse"))
	{	cp->type = SOAP_TYPE_ns1__completeTaskWSResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__completeTaskWSResponse);
			if (size)
				*size = sizeof(ns1__completeTaskWSResponse);
			((ns1__completeTaskWSResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__completeTaskWSResponse, n);
			if (size)
				*size = n * sizeof(ns1__completeTaskWSResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__completeTaskWSResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__completeTaskWSResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getProcessTasks"))
	{	cp->type = SOAP_TYPE_ns1__getProcessTasks;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessTasks);
			if (size)
				*size = sizeof(ns1__getProcessTasks);
			((ns1__getProcessTasks*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessTasks, n);
			if (size)
				*size = n * sizeof(ns1__getProcessTasks);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getProcessTasks*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getProcessTasks*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getProcessTasksResponse"))
	{	cp->type = SOAP_TYPE_ns1__getProcessTasksResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getProcessTasksResponse);
			if (size)
				*size = sizeof(ns1__getProcessTasksResponse);
			((ns1__getProcessTasksResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getProcessTasksResponse, n);
			if (size)
				*size = n * sizeof(ns1__getProcessTasksResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getProcessTasksResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getProcessTasksResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getTask"))
	{	cp->type = SOAP_TYPE_ns1__getTask;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getTask);
			if (size)
				*size = sizeof(ns1__getTask);
			((ns1__getTask*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getTask, n);
			if (size)
				*size = n * sizeof(ns1__getTask);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getTask*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getTask*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:getTaskResponse"))
	{	cp->type = SOAP_TYPE_ns1__getTaskResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__getTaskResponse);
			if (size)
				*size = sizeof(ns1__getTaskResponse);
			((ns1__getTaskResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getTaskResponse, n);
			if (size)
				*size = n * sizeof(ns1__getTaskResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__getTaskResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__getTaskResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:assignTask"))
	{	cp->type = SOAP_TYPE_ns1__assignTask;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__assignTask);
			if (size)
				*size = sizeof(ns1__assignTask);
			((ns1__assignTask*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__assignTask, n);
			if (size)
				*size = n * sizeof(ns1__assignTask);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__assignTask*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__assignTask*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:assignTaskResponse"))
	{	cp->type = SOAP_TYPE_ns1__assignTaskResponse;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__assignTaskResponse);
			if (size)
				*size = sizeof(ns1__assignTaskResponse);
			((ns1__assignTaskResponse*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__assignTaskResponse, n);
			if (size)
				*size = n * sizeof(ns1__assignTaskResponse);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__assignTaskResponse*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__assignTaskResponse*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:wfVariableStub"))
	{	cp->type = SOAP_TYPE_ns2__wfVariableStub;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__wfVariableStub);
			if (size)
				*size = sizeof(ns2__wfVariableStub);
			((ns2__wfVariableStub*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__wfVariableStub, n);
			if (size)
				*size = n * sizeof(ns2__wfVariableStub);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns2__wfVariableStub*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns2__wfVariableStub*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:identifiableBase"))
	{	cp->type = SOAP_TYPE_ns1__identifiableBase;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__identifiableBase);
			if (size)
				*size = sizeof(ns1__identifiableBase);
			((ns1__identifiableBase*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__identifiableBase, n);
			if (size)
				*size = n * sizeof(ns1__identifiableBase);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__identifiableBase*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__identifiableBase*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:executor"))
	{	cp->type = SOAP_TYPE_ns1__executor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__executor);
			if (size)
				*size = sizeof(ns1__executor);
			((ns1__executor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__executor, n);
			if (size)
				*size = n * sizeof(ns1__executor);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__executor*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__executor*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:actor"))
	{	cp->type = SOAP_TYPE_ns1__actor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__actor);
			if (size)
				*size = sizeof(ns1__actor);
			((ns1__actor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__actor, n);
			if (size)
				*size = n * sizeof(ns1__actor);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__actor*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__actor*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:wfExecutor"))
	{	cp->type = SOAP_TYPE_ns1__wfExecutor;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__wfExecutor);
			if (size)
				*size = sizeof(ns1__wfExecutor);
			((ns1__wfExecutor*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__wfExecutor, n);
			if (size)
				*size = n * sizeof(ns1__wfExecutor);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__wfExecutor*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__wfExecutor*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__anyType);
		if (size)
			*size = sizeof(xsd__anyType);
		((xsd__anyType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__anyType, n);
		if (size)
			*size = n * sizeof(xsd__anyType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__anyType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__anyType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anyType %p -> %p\n", q, p));
	*(xsd__anyType*)p = *(xsd__anyType*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getTask(struct soap *soap, struct __ns1__getTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getTask_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getTask(struct soap *soap, const struct __ns1__getTask *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getTask(soap, &a->ns1__getTask_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getTask(struct soap *soap, const char *tag, int id, const struct __ns1__getTask *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getTask(soap, "ns1:getTask", -1, &a->ns1__getTask_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTask * SOAP_FMAC4 soap_in___ns1__getTask(struct soap *soap, const char *tag, struct __ns1__getTask *a, const char *type)
{
	size_t soap_flag_ns1__getTask_ = 1;
	short soap_flag;
	a = (struct __ns1__getTask *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getTask, sizeof(struct __ns1__getTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getTask(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getTask_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getTask(soap, "ns1:getTask", &a->ns1__getTask_, "ns1:getTask"))
				{	soap_flag_ns1__getTask_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getTask(struct soap *soap, const struct __ns1__getTask *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getTask(soap, tag?tag:"-ns1:getTask", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTask * SOAP_FMAC4 soap_get___ns1__getTask(struct soap *soap, struct __ns1__getTask *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getTask * SOAP_FMAC2 soap_instantiate___ns1__getTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTask);
		if (size)
			*size = sizeof(struct __ns1__getTask);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getTask, n);
		if (size)
			*size = n * sizeof(struct __ns1__getTask);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getTask %p -> %p\n", q, p));
	*(struct __ns1__getTask*)p = *(struct __ns1__getTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__assignTask(struct soap *soap, struct __ns1__assignTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__assignTask_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__assignTask(struct soap *soap, const struct __ns1__assignTask *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__assignTask(soap, &a->ns1__assignTask_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__assignTask(struct soap *soap, const char *tag, int id, const struct __ns1__assignTask *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__assignTask(soap, "ns1:assignTask", -1, &a->ns1__assignTask_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__assignTask * SOAP_FMAC4 soap_in___ns1__assignTask(struct soap *soap, const char *tag, struct __ns1__assignTask *a, const char *type)
{
	size_t soap_flag_ns1__assignTask_ = 1;
	short soap_flag;
	a = (struct __ns1__assignTask *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__assignTask, sizeof(struct __ns1__assignTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__assignTask(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__assignTask_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__assignTask(soap, "ns1:assignTask", &a->ns1__assignTask_, "ns1:assignTask"))
				{	soap_flag_ns1__assignTask_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__assignTask(struct soap *soap, const struct __ns1__assignTask *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__assignTask(soap, tag?tag:"-ns1:assignTask", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__assignTask * SOAP_FMAC4 soap_get___ns1__assignTask(struct soap *soap, struct __ns1__assignTask *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__assignTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__assignTask * SOAP_FMAC2 soap_instantiate___ns1__assignTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__assignTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__assignTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__assignTask);
		if (size)
			*size = sizeof(struct __ns1__assignTask);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__assignTask, n);
		if (size)
			*size = n * sizeof(struct __ns1__assignTask);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__assignTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__assignTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__assignTask %p -> %p\n", q, p));
	*(struct __ns1__assignTask*)p = *(struct __ns1__assignTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__assignTaskResponse(struct soap *soap, struct __ns1__assignTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__assignTaskResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__assignTaskResponse(struct soap *soap, const struct __ns1__assignTaskResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__assignTaskResponse(soap, &a->ns1__assignTaskResponse_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__assignTaskResponse(struct soap *soap, const char *tag, int id, const struct __ns1__assignTaskResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (a->ns1__assignTaskResponse_)
		soap_element_result(soap, "ns1:assignTaskResponse");
	if (soap_out_PointerTons1__assignTaskResponse(soap, "ns1:assignTaskResponse", -1, &a->ns1__assignTaskResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__assignTaskResponse * SOAP_FMAC4 soap_in___ns1__assignTaskResponse(struct soap *soap, const char *tag, struct __ns1__assignTaskResponse *a, const char *type)
{
	size_t soap_flag_ns1__assignTaskResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__assignTaskResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__assignTaskResponse, sizeof(struct __ns1__assignTaskResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__assignTaskResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__assignTaskResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__assignTaskResponse(soap, "ns1:assignTaskResponse", &a->ns1__assignTaskResponse_, "ns1:assignTaskResponse"))
				{	soap_flag_ns1__assignTaskResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:assignTaskResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__assignTaskResponse(struct soap *soap, const struct __ns1__assignTaskResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__assignTaskResponse(soap, tag?tag:"-ns1:assignTaskResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__assignTaskResponse * SOAP_FMAC4 soap_get___ns1__assignTaskResponse(struct soap *soap, struct __ns1__assignTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__assignTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__assignTaskResponse * SOAP_FMAC2 soap_instantiate___ns1__assignTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__assignTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__assignTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__assignTaskResponse);
		if (size)
			*size = sizeof(struct __ns1__assignTaskResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__assignTaskResponse, n);
		if (size)
			*size = n * sizeof(struct __ns1__assignTaskResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__assignTaskResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__assignTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__assignTaskResponse %p -> %p\n", q, p));
	*(struct __ns1__assignTaskResponse*)p = *(struct __ns1__assignTaskResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getProcessTasks(struct soap *soap, struct __ns1__getProcessTasks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getProcessTasks_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getProcessTasks(struct soap *soap, const struct __ns1__getProcessTasks *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getProcessTasks(soap, &a->ns1__getProcessTasks_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getProcessTasks(struct soap *soap, const char *tag, int id, const struct __ns1__getProcessTasks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getProcessTasks(soap, "ns1:getProcessTasks", -1, &a->ns1__getProcessTasks_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcessTasks * SOAP_FMAC4 soap_in___ns1__getProcessTasks(struct soap *soap, const char *tag, struct __ns1__getProcessTasks *a, const char *type)
{
	size_t soap_flag_ns1__getProcessTasks_ = 1;
	short soap_flag;
	a = (struct __ns1__getProcessTasks *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getProcessTasks, sizeof(struct __ns1__getProcessTasks), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getProcessTasks(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getProcessTasks_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getProcessTasks(soap, "ns1:getProcessTasks", &a->ns1__getProcessTasks_, "ns1:getProcessTasks"))
				{	soap_flag_ns1__getProcessTasks_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getProcessTasks(struct soap *soap, const struct __ns1__getProcessTasks *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getProcessTasks(soap, tag?tag:"-ns1:getProcessTasks", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getProcessTasks * SOAP_FMAC4 soap_get___ns1__getProcessTasks(struct soap *soap, struct __ns1__getProcessTasks *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getProcessTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getProcessTasks * SOAP_FMAC2 soap_instantiate___ns1__getProcessTasks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getProcessTasks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getProcessTasks, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getProcessTasks);
		if (size)
			*size = sizeof(struct __ns1__getProcessTasks);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getProcessTasks, n);
		if (size)
			*size = n * sizeof(struct __ns1__getProcessTasks);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getProcessTasks*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getProcessTasks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getProcessTasks %p -> %p\n", q, p));
	*(struct __ns1__getProcessTasks*)p = *(struct __ns1__getProcessTasks*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__completeTaskWS(struct soap *soap, struct __ns1__completeTaskWS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__completeTaskWS_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__completeTaskWS(struct soap *soap, const struct __ns1__completeTaskWS *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__completeTaskWS(soap, &a->ns1__completeTaskWS_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__completeTaskWS(struct soap *soap, const char *tag, int id, const struct __ns1__completeTaskWS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__completeTaskWS(soap, "ns1:completeTaskWS", -1, &a->ns1__completeTaskWS_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__completeTaskWS * SOAP_FMAC4 soap_in___ns1__completeTaskWS(struct soap *soap, const char *tag, struct __ns1__completeTaskWS *a, const char *type)
{
	size_t soap_flag_ns1__completeTaskWS_ = 1;
	short soap_flag;
	a = (struct __ns1__completeTaskWS *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__completeTaskWS, sizeof(struct __ns1__completeTaskWS), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__completeTaskWS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__completeTaskWS_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__completeTaskWS(soap, "ns1:completeTaskWS", &a->ns1__completeTaskWS_, "ns1:completeTaskWS"))
				{	soap_flag_ns1__completeTaskWS_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__completeTaskWS(struct soap *soap, const struct __ns1__completeTaskWS *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__completeTaskWS(soap, tag?tag:"-ns1:completeTaskWS", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__completeTaskWS * SOAP_FMAC4 soap_get___ns1__completeTaskWS(struct soap *soap, struct __ns1__completeTaskWS *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__completeTaskWS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__completeTaskWS * SOAP_FMAC2 soap_instantiate___ns1__completeTaskWS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__completeTaskWS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__completeTaskWS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__completeTaskWS);
		if (size)
			*size = sizeof(struct __ns1__completeTaskWS);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__completeTaskWS, n);
		if (size)
			*size = n * sizeof(struct __ns1__completeTaskWS);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__completeTaskWS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__completeTaskWS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__completeTaskWS %p -> %p\n", q, p));
	*(struct __ns1__completeTaskWS*)p = *(struct __ns1__completeTaskWS*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__completeTaskWSResponse(struct soap *soap, struct __ns1__completeTaskWSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__completeTaskWSResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__completeTaskWSResponse(struct soap *soap, const struct __ns1__completeTaskWSResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__completeTaskWSResponse(soap, &a->ns1__completeTaskWSResponse_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__completeTaskWSResponse(struct soap *soap, const char *tag, int id, const struct __ns1__completeTaskWSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (a->ns1__completeTaskWSResponse_)
		soap_element_result(soap, "ns1:completeTaskWSResponse");
	if (soap_out_PointerTons1__completeTaskWSResponse(soap, "ns1:completeTaskWSResponse", -1, &a->ns1__completeTaskWSResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__completeTaskWSResponse * SOAP_FMAC4 soap_in___ns1__completeTaskWSResponse(struct soap *soap, const char *tag, struct __ns1__completeTaskWSResponse *a, const char *type)
{
	size_t soap_flag_ns1__completeTaskWSResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__completeTaskWSResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__completeTaskWSResponse, sizeof(struct __ns1__completeTaskWSResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__completeTaskWSResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__completeTaskWSResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__completeTaskWSResponse(soap, "ns1:completeTaskWSResponse", &a->ns1__completeTaskWSResponse_, "ns1:completeTaskWSResponse"))
				{	soap_flag_ns1__completeTaskWSResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:completeTaskWSResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__completeTaskWSResponse(struct soap *soap, const struct __ns1__completeTaskWSResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__completeTaskWSResponse(soap, tag?tag:"-ns1:completeTaskWSResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__completeTaskWSResponse * SOAP_FMAC4 soap_get___ns1__completeTaskWSResponse(struct soap *soap, struct __ns1__completeTaskWSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__completeTaskWSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__completeTaskWSResponse * SOAP_FMAC2 soap_instantiate___ns1__completeTaskWSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__completeTaskWSResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__completeTaskWSResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__completeTaskWSResponse);
		if (size)
			*size = sizeof(struct __ns1__completeTaskWSResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__completeTaskWSResponse, n);
		if (size)
			*size = n * sizeof(struct __ns1__completeTaskWSResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__completeTaskWSResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__completeTaskWSResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__completeTaskWSResponse %p -> %p\n", q, p));
	*(struct __ns1__completeTaskWSResponse*)p = *(struct __ns1__completeTaskWSResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getTasks(struct soap *soap, struct __ns1__getTasks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getTasks_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getTasks(struct soap *soap, const struct __ns1__getTasks *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getTasks(soap, &a->ns1__getTasks_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getTasks(struct soap *soap, const char *tag, int id, const struct __ns1__getTasks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getTasks(soap, "ns1:getTasks", -1, &a->ns1__getTasks_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTasks * SOAP_FMAC4 soap_in___ns1__getTasks(struct soap *soap, const char *tag, struct __ns1__getTasks *a, const char *type)
{
	size_t soap_flag_ns1__getTasks_ = 1;
	short soap_flag;
	a = (struct __ns1__getTasks *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getTasks, sizeof(struct __ns1__getTasks), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getTasks(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getTasks_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getTasks(soap, "ns1:getTasks", &a->ns1__getTasks_, "ns1:getTasks"))
				{	soap_flag_ns1__getTasks_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getTasks(struct soap *soap, const struct __ns1__getTasks *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getTasks(soap, tag?tag:"-ns1:getTasks", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTasks * SOAP_FMAC4 soap_get___ns1__getTasks(struct soap *soap, struct __ns1__getTasks *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getTasks * SOAP_FMAC2 soap_instantiate___ns1__getTasks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getTasks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getTasks, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTasks);
		if (size)
			*size = sizeof(struct __ns1__getTasks);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getTasks, n);
		if (size)
			*size = n * sizeof(struct __ns1__getTasks);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getTasks*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getTasks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getTasks %p -> %p\n", q, p));
	*(struct __ns1__getTasks*)p = *(struct __ns1__getTasks*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__reassignTasks(struct soap *soap, struct __ns1__reassignTasks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__reassignTasks_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__reassignTasks(struct soap *soap, const struct __ns1__reassignTasks *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__reassignTasks(soap, &a->ns1__reassignTasks_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__reassignTasks(struct soap *soap, const char *tag, int id, const struct __ns1__reassignTasks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__reassignTasks(soap, "ns1:reassignTasks", -1, &a->ns1__reassignTasks_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__reassignTasks * SOAP_FMAC4 soap_in___ns1__reassignTasks(struct soap *soap, const char *tag, struct __ns1__reassignTasks *a, const char *type)
{
	size_t soap_flag_ns1__reassignTasks_ = 1;
	short soap_flag;
	a = (struct __ns1__reassignTasks *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__reassignTasks, sizeof(struct __ns1__reassignTasks), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__reassignTasks(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__reassignTasks_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__reassignTasks(soap, "ns1:reassignTasks", &a->ns1__reassignTasks_, "ns1:reassignTasks"))
				{	soap_flag_ns1__reassignTasks_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__reassignTasks(struct soap *soap, const struct __ns1__reassignTasks *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__reassignTasks(soap, tag?tag:"-ns1:reassignTasks", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__reassignTasks * SOAP_FMAC4 soap_get___ns1__reassignTasks(struct soap *soap, struct __ns1__reassignTasks *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__reassignTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__reassignTasks * SOAP_FMAC2 soap_instantiate___ns1__reassignTasks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__reassignTasks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__reassignTasks, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__reassignTasks);
		if (size)
			*size = sizeof(struct __ns1__reassignTasks);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__reassignTasks, n);
		if (size)
			*size = n * sizeof(struct __ns1__reassignTasks);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__reassignTasks*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__reassignTasks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__reassignTasks %p -> %p\n", q, p));
	*(struct __ns1__reassignTasks*)p = *(struct __ns1__reassignTasks*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__reassignTask(struct soap *soap, struct __ns1__reassignTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__reassignTask_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__reassignTask(struct soap *soap, const struct __ns1__reassignTask *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__reassignTask(soap, &a->ns1__reassignTask_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__reassignTask(struct soap *soap, const char *tag, int id, const struct __ns1__reassignTask *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__reassignTask(soap, "ns1:reassignTask", -1, &a->ns1__reassignTask_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__reassignTask * SOAP_FMAC4 soap_in___ns1__reassignTask(struct soap *soap, const char *tag, struct __ns1__reassignTask *a, const char *type)
{
	size_t soap_flag_ns1__reassignTask_ = 1;
	short soap_flag;
	a = (struct __ns1__reassignTask *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__reassignTask, sizeof(struct __ns1__reassignTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__reassignTask(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__reassignTask_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__reassignTask(soap, "ns1:reassignTask", &a->ns1__reassignTask_, "ns1:reassignTask"))
				{	soap_flag_ns1__reassignTask_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__reassignTask(struct soap *soap, const struct __ns1__reassignTask *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__reassignTask(soap, tag?tag:"-ns1:reassignTask", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__reassignTask * SOAP_FMAC4 soap_get___ns1__reassignTask(struct soap *soap, struct __ns1__reassignTask *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__reassignTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__reassignTask * SOAP_FMAC2 soap_instantiate___ns1__reassignTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__reassignTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__reassignTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__reassignTask);
		if (size)
			*size = sizeof(struct __ns1__reassignTask);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__reassignTask, n);
		if (size)
			*size = n * sizeof(struct __ns1__reassignTask);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__reassignTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__reassignTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__reassignTask %p -> %p\n", q, p));
	*(struct __ns1__reassignTask*)p = *(struct __ns1__reassignTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__reassignTaskResponse(struct soap *soap, struct __ns1__reassignTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__reassignTaskResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__reassignTaskResponse(struct soap *soap, const struct __ns1__reassignTaskResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__reassignTaskResponse(soap, &a->ns1__reassignTaskResponse_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__reassignTaskResponse(struct soap *soap, const char *tag, int id, const struct __ns1__reassignTaskResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (a->ns1__reassignTaskResponse_)
		soap_element_result(soap, "ns1:reassignTaskResponse");
	if (soap_out_PointerTons1__reassignTaskResponse(soap, "ns1:reassignTaskResponse", -1, &a->ns1__reassignTaskResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__reassignTaskResponse * SOAP_FMAC4 soap_in___ns1__reassignTaskResponse(struct soap *soap, const char *tag, struct __ns1__reassignTaskResponse *a, const char *type)
{
	size_t soap_flag_ns1__reassignTaskResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__reassignTaskResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__reassignTaskResponse, sizeof(struct __ns1__reassignTaskResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__reassignTaskResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__reassignTaskResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__reassignTaskResponse(soap, "ns1:reassignTaskResponse", &a->ns1__reassignTaskResponse_, "ns1:reassignTaskResponse"))
				{	soap_flag_ns1__reassignTaskResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:reassignTaskResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__reassignTaskResponse(struct soap *soap, const struct __ns1__reassignTaskResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__reassignTaskResponse(soap, tag?tag:"-ns1:reassignTaskResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__reassignTaskResponse * SOAP_FMAC4 soap_get___ns1__reassignTaskResponse(struct soap *soap, struct __ns1__reassignTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__reassignTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__reassignTaskResponse * SOAP_FMAC2 soap_instantiate___ns1__reassignTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__reassignTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__reassignTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__reassignTaskResponse);
		if (size)
			*size = sizeof(struct __ns1__reassignTaskResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__reassignTaskResponse, n);
		if (size)
			*size = n * sizeof(struct __ns1__reassignTaskResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__reassignTaskResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__reassignTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__reassignTaskResponse %p -> %p\n", q, p));
	*(struct __ns1__reassignTaskResponse*)p = *(struct __ns1__reassignTaskResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__markTaskOpened(struct soap *soap, struct __ns1__markTaskOpened *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__markTaskOpened_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__markTaskOpened(struct soap *soap, const struct __ns1__markTaskOpened *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__markTaskOpened(soap, &a->ns1__markTaskOpened_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__markTaskOpened(struct soap *soap, const char *tag, int id, const struct __ns1__markTaskOpened *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__markTaskOpened(soap, "ns1:markTaskOpened", -1, &a->ns1__markTaskOpened_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__markTaskOpened * SOAP_FMAC4 soap_in___ns1__markTaskOpened(struct soap *soap, const char *tag, struct __ns1__markTaskOpened *a, const char *type)
{
	size_t soap_flag_ns1__markTaskOpened_ = 1;
	short soap_flag;
	a = (struct __ns1__markTaskOpened *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__markTaskOpened, sizeof(struct __ns1__markTaskOpened), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__markTaskOpened(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__markTaskOpened_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__markTaskOpened(soap, "ns1:markTaskOpened", &a->ns1__markTaskOpened_, "ns1:markTaskOpened"))
				{	soap_flag_ns1__markTaskOpened_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__markTaskOpened(struct soap *soap, const struct __ns1__markTaskOpened *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__markTaskOpened(soap, tag?tag:"-ns1:markTaskOpened", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__markTaskOpened * SOAP_FMAC4 soap_get___ns1__markTaskOpened(struct soap *soap, struct __ns1__markTaskOpened *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__markTaskOpened(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__markTaskOpened * SOAP_FMAC2 soap_instantiate___ns1__markTaskOpened(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__markTaskOpened(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__markTaskOpened, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__markTaskOpened);
		if (size)
			*size = sizeof(struct __ns1__markTaskOpened);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__markTaskOpened, n);
		if (size)
			*size = n * sizeof(struct __ns1__markTaskOpened);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__markTaskOpened*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__markTaskOpened(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__markTaskOpened %p -> %p\n", q, p));
	*(struct __ns1__markTaskOpened*)p = *(struct __ns1__markTaskOpened*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__markTaskOpenedResponse(struct soap *soap, struct __ns1__markTaskOpenedResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__markTaskOpenedResponse_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__markTaskOpenedResponse(struct soap *soap, const struct __ns1__markTaskOpenedResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__markTaskOpenedResponse(soap, &a->ns1__markTaskOpenedResponse_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__markTaskOpenedResponse(struct soap *soap, const char *tag, int id, const struct __ns1__markTaskOpenedResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (a->ns1__markTaskOpenedResponse_)
		soap_element_result(soap, "ns1:markTaskOpenedResponse");
	if (soap_out_PointerTons1__markTaskOpenedResponse(soap, "ns1:markTaskOpenedResponse", -1, &a->ns1__markTaskOpenedResponse_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__markTaskOpenedResponse * SOAP_FMAC4 soap_in___ns1__markTaskOpenedResponse(struct soap *soap, const char *tag, struct __ns1__markTaskOpenedResponse *a, const char *type)
{
	size_t soap_flag_ns1__markTaskOpenedResponse_ = 1;
	short soap_flag;
	a = (struct __ns1__markTaskOpenedResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__markTaskOpenedResponse, sizeof(struct __ns1__markTaskOpenedResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__markTaskOpenedResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__markTaskOpenedResponse_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__markTaskOpenedResponse(soap, "ns1:markTaskOpenedResponse", &a->ns1__markTaskOpenedResponse_, "ns1:markTaskOpenedResponse"))
				{	soap_flag_ns1__markTaskOpenedResponse_--;
					continue;
				}
			soap_check_result(soap, "ns1:markTaskOpenedResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__markTaskOpenedResponse(struct soap *soap, const struct __ns1__markTaskOpenedResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__markTaskOpenedResponse(soap, tag?tag:"-ns1:markTaskOpenedResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__markTaskOpenedResponse * SOAP_FMAC4 soap_get___ns1__markTaskOpenedResponse(struct soap *soap, struct __ns1__markTaskOpenedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__markTaskOpenedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__markTaskOpenedResponse * SOAP_FMAC2 soap_instantiate___ns1__markTaskOpenedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__markTaskOpenedResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__markTaskOpenedResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__markTaskOpenedResponse);
		if (size)
			*size = sizeof(struct __ns1__markTaskOpenedResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__markTaskOpenedResponse, n);
		if (size)
			*size = n * sizeof(struct __ns1__markTaskOpenedResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__markTaskOpenedResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__markTaskOpenedResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__markTaskOpenedResponse %p -> %p\n", q, p));
	*(struct __ns1__markTaskOpenedResponse*)p = *(struct __ns1__markTaskOpenedResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getMyTasks(struct soap *soap, struct __ns1__getMyTasks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getMyTasks_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getMyTasks(struct soap *soap, const struct __ns1__getMyTasks *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getMyTasks(soap, &a->ns1__getMyTasks_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getMyTasks(struct soap *soap, const char *tag, int id, const struct __ns1__getMyTasks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getMyTasks(soap, "ns1:getMyTasks", -1, &a->ns1__getMyTasks_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMyTasks * SOAP_FMAC4 soap_in___ns1__getMyTasks(struct soap *soap, const char *tag, struct __ns1__getMyTasks *a, const char *type)
{
	size_t soap_flag_ns1__getMyTasks_ = 1;
	short soap_flag;
	a = (struct __ns1__getMyTasks *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getMyTasks, sizeof(struct __ns1__getMyTasks), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getMyTasks(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getMyTasks_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getMyTasks(soap, "ns1:getMyTasks", &a->ns1__getMyTasks_, "ns1:getMyTasks"))
				{	soap_flag_ns1__getMyTasks_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getMyTasks(struct soap *soap, const struct __ns1__getMyTasks *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getMyTasks(soap, tag?tag:"-ns1:getMyTasks", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMyTasks * SOAP_FMAC4 soap_get___ns1__getMyTasks(struct soap *soap, struct __ns1__getMyTasks *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getMyTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getMyTasks * SOAP_FMAC2 soap_instantiate___ns1__getMyTasks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getMyTasks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getMyTasks, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getMyTasks);
		if (size)
			*size = sizeof(struct __ns1__getMyTasks);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getMyTasks, n);
		if (size)
			*size = n * sizeof(struct __ns1__getMyTasks);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getMyTasks*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getMyTasks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getMyTasks %p -> %p\n", q, p));
	*(struct __ns1__getMyTasks*)p = *(struct __ns1__getMyTasks*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__authenticateByCallerPrincipal(struct soap *soap, struct __ns1__authenticateByCallerPrincipal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__authenticateByCallerPrincipal_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__authenticateByCallerPrincipal(struct soap *soap, const struct __ns1__authenticateByCallerPrincipal *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__authenticateByCallerPrincipal(soap, &a->ns1__authenticateByCallerPrincipal_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__authenticateByCallerPrincipal(struct soap *soap, const char *tag, int id, const struct __ns1__authenticateByCallerPrincipal *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__authenticateByCallerPrincipal(soap, "ns1:authenticateByCallerPrincipal", -1, &a->ns1__authenticateByCallerPrincipal_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__authenticateByCallerPrincipal * SOAP_FMAC4 soap_in___ns1__authenticateByCallerPrincipal(struct soap *soap, const char *tag, struct __ns1__authenticateByCallerPrincipal *a, const char *type)
{
	size_t soap_flag_ns1__authenticateByCallerPrincipal_ = 1;
	short soap_flag;
	a = (struct __ns1__authenticateByCallerPrincipal *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__authenticateByCallerPrincipal, sizeof(struct __ns1__authenticateByCallerPrincipal), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__authenticateByCallerPrincipal(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__authenticateByCallerPrincipal_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__authenticateByCallerPrincipal(soap, "ns1:authenticateByCallerPrincipal", &a->ns1__authenticateByCallerPrincipal_, "ns1:authenticateByCallerPrincipal"))
				{	soap_flag_ns1__authenticateByCallerPrincipal_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__authenticateByCallerPrincipal(struct soap *soap, const struct __ns1__authenticateByCallerPrincipal *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__authenticateByCallerPrincipal(soap, tag?tag:"-ns1:authenticateByCallerPrincipal", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__authenticateByCallerPrincipal * SOAP_FMAC4 soap_get___ns1__authenticateByCallerPrincipal(struct soap *soap, struct __ns1__authenticateByCallerPrincipal *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__authenticateByCallerPrincipal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__authenticateByCallerPrincipal * SOAP_FMAC2 soap_instantiate___ns1__authenticateByCallerPrincipal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__authenticateByCallerPrincipal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__authenticateByCallerPrincipal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__authenticateByCallerPrincipal);
		if (size)
			*size = sizeof(struct __ns1__authenticateByCallerPrincipal);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__authenticateByCallerPrincipal, n);
		if (size)
			*size = n * sizeof(struct __ns1__authenticateByCallerPrincipal);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__authenticateByCallerPrincipal*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__authenticateByCallerPrincipal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__authenticateByCallerPrincipal %p -> %p\n", q, p));
	*(struct __ns1__authenticateByCallerPrincipal*)p = *(struct __ns1__authenticateByCallerPrincipal*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__authenticateByTrustedPrincipal(struct soap *soap, struct __ns1__authenticateByTrustedPrincipal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__authenticateByTrustedPrincipal_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__authenticateByTrustedPrincipal(struct soap *soap, const struct __ns1__authenticateByTrustedPrincipal *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__authenticateByTrustedPrincipal(soap, &a->ns1__authenticateByTrustedPrincipal_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__authenticateByTrustedPrincipal(struct soap *soap, const char *tag, int id, const struct __ns1__authenticateByTrustedPrincipal *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__authenticateByTrustedPrincipal(soap, "ns1:authenticateByTrustedPrincipal", -1, &a->ns1__authenticateByTrustedPrincipal_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__authenticateByTrustedPrincipal * SOAP_FMAC4 soap_in___ns1__authenticateByTrustedPrincipal(struct soap *soap, const char *tag, struct __ns1__authenticateByTrustedPrincipal *a, const char *type)
{
	size_t soap_flag_ns1__authenticateByTrustedPrincipal_ = 1;
	short soap_flag;
	a = (struct __ns1__authenticateByTrustedPrincipal *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__authenticateByTrustedPrincipal, sizeof(struct __ns1__authenticateByTrustedPrincipal), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__authenticateByTrustedPrincipal(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__authenticateByTrustedPrincipal_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__authenticateByTrustedPrincipal(soap, "ns1:authenticateByTrustedPrincipal", &a->ns1__authenticateByTrustedPrincipal_, "ns1:authenticateByTrustedPrincipal"))
				{	soap_flag_ns1__authenticateByTrustedPrincipal_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__authenticateByTrustedPrincipal(struct soap *soap, const struct __ns1__authenticateByTrustedPrincipal *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__authenticateByTrustedPrincipal(soap, tag?tag:"-ns1:authenticateByTrustedPrincipal", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__authenticateByTrustedPrincipal * SOAP_FMAC4 soap_get___ns1__authenticateByTrustedPrincipal(struct soap *soap, struct __ns1__authenticateByTrustedPrincipal *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__authenticateByTrustedPrincipal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__authenticateByTrustedPrincipal * SOAP_FMAC2 soap_instantiate___ns1__authenticateByTrustedPrincipal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__authenticateByTrustedPrincipal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__authenticateByTrustedPrincipal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__authenticateByTrustedPrincipal);
		if (size)
			*size = sizeof(struct __ns1__authenticateByTrustedPrincipal);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__authenticateByTrustedPrincipal, n);
		if (size)
			*size = n * sizeof(struct __ns1__authenticateByTrustedPrincipal);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__authenticateByTrustedPrincipal*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__authenticateByTrustedPrincipal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__authenticateByTrustedPrincipal %p -> %p\n", q, p));
	*(struct __ns1__authenticateByTrustedPrincipal*)p = *(struct __ns1__authenticateByTrustedPrincipal*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__authenticateByLoginPassword(struct soap *soap, struct __ns1__authenticateByLoginPassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__authenticateByLoginPassword_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__authenticateByLoginPassword(struct soap *soap, const struct __ns1__authenticateByLoginPassword *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__authenticateByLoginPassword(soap, &a->ns1__authenticateByLoginPassword_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__authenticateByLoginPassword(struct soap *soap, const char *tag, int id, const struct __ns1__authenticateByLoginPassword *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__authenticateByLoginPassword(soap, "ns1:authenticateByLoginPassword", -1, &a->ns1__authenticateByLoginPassword_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__authenticateByLoginPassword * SOAP_FMAC4 soap_in___ns1__authenticateByLoginPassword(struct soap *soap, const char *tag, struct __ns1__authenticateByLoginPassword *a, const char *type)
{
	size_t soap_flag_ns1__authenticateByLoginPassword_ = 1;
	short soap_flag;
	a = (struct __ns1__authenticateByLoginPassword *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__authenticateByLoginPassword, sizeof(struct __ns1__authenticateByLoginPassword), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__authenticateByLoginPassword(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__authenticateByLoginPassword_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__authenticateByLoginPassword(soap, "ns1:authenticateByLoginPassword", &a->ns1__authenticateByLoginPassword_, "ns1:authenticateByLoginPassword"))
				{	soap_flag_ns1__authenticateByLoginPassword_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__authenticateByLoginPassword(struct soap *soap, const struct __ns1__authenticateByLoginPassword *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__authenticateByLoginPassword(soap, tag?tag:"-ns1:authenticateByLoginPassword", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__authenticateByLoginPassword * SOAP_FMAC4 soap_get___ns1__authenticateByLoginPassword(struct soap *soap, struct __ns1__authenticateByLoginPassword *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__authenticateByLoginPassword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__authenticateByLoginPassword * SOAP_FMAC2 soap_instantiate___ns1__authenticateByLoginPassword(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__authenticateByLoginPassword(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__authenticateByLoginPassword, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__authenticateByLoginPassword);
		if (size)
			*size = sizeof(struct __ns1__authenticateByLoginPassword);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__authenticateByLoginPassword, n);
		if (size)
			*size = n * sizeof(struct __ns1__authenticateByLoginPassword);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__authenticateByLoginPassword*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__authenticateByLoginPassword(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__authenticateByLoginPassword %p -> %p\n", q, p));
	*(struct __ns1__authenticateByLoginPassword*)p = *(struct __ns1__authenticateByLoginPassword*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__authenticateByKerberos(struct soap *soap, struct __ns1__authenticateByKerberos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__authenticateByKerberos_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__authenticateByKerberos(struct soap *soap, const struct __ns1__authenticateByKerberos *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__authenticateByKerberos(soap, &a->ns1__authenticateByKerberos_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__authenticateByKerberos(struct soap *soap, const char *tag, int id, const struct __ns1__authenticateByKerberos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__authenticateByKerberos(soap, "ns1:authenticateByKerberos", -1, &a->ns1__authenticateByKerberos_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__authenticateByKerberos * SOAP_FMAC4 soap_in___ns1__authenticateByKerberos(struct soap *soap, const char *tag, struct __ns1__authenticateByKerberos *a, const char *type)
{
	size_t soap_flag_ns1__authenticateByKerberos_ = 1;
	short soap_flag;
	a = (struct __ns1__authenticateByKerberos *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__authenticateByKerberos, sizeof(struct __ns1__authenticateByKerberos), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__authenticateByKerberos(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__authenticateByKerberos_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__authenticateByKerberos(soap, "ns1:authenticateByKerberos", &a->ns1__authenticateByKerberos_, "ns1:authenticateByKerberos"))
				{	soap_flag_ns1__authenticateByKerberos_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__authenticateByKerberos(struct soap *soap, const struct __ns1__authenticateByKerberos *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__authenticateByKerberos(soap, tag?tag:"-ns1:authenticateByKerberos", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__authenticateByKerberos * SOAP_FMAC4 soap_get___ns1__authenticateByKerberos(struct soap *soap, struct __ns1__authenticateByKerberos *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__authenticateByKerberos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__authenticateByKerberos * SOAP_FMAC2 soap_instantiate___ns1__authenticateByKerberos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__authenticateByKerberos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__authenticateByKerberos, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__authenticateByKerberos);
		if (size)
			*size = sizeof(struct __ns1__authenticateByKerberos);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__authenticateByKerberos, n);
		if (size)
			*size = n * sizeof(struct __ns1__authenticateByKerberos);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__authenticateByKerberos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__authenticateByKerberos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__authenticateByKerberos %p -> %p\n", q, p));
	*(struct __ns1__authenticateByKerberos*)p = *(struct __ns1__authenticateByKerberos*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getTaskResponse(struct soap *soap, ns1__getTaskResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getTaskResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getTaskResponse(struct soap *soap, const char *tag, int id, ns1__getTaskResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getTaskResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getTaskResponse ** SOAP_FMAC4 soap_in_PointerTons1__getTaskResponse(struct soap *soap, const char *tag, ns1__getTaskResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getTaskResponse **)soap_malloc(soap, sizeof(ns1__getTaskResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getTaskResponse *)soap_instantiate_ns1__getTaskResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getTaskResponse ** p = (ns1__getTaskResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getTaskResponse, sizeof(ns1__getTaskResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getTaskResponse(struct soap *soap, ns1__getTaskResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getTaskResponse);
	if (soap_out_PointerTons1__getTaskResponse(soap, tag?tag:"ns1:getTaskResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getTaskResponse ** SOAP_FMAC4 soap_get_PointerTons1__getTaskResponse(struct soap *soap, ns1__getTaskResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getTask(struct soap *soap, ns1__getTask *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getTask))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getTask(struct soap *soap, const char *tag, int id, ns1__getTask *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getTask);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getTask ** SOAP_FMAC4 soap_in_PointerTons1__getTask(struct soap *soap, const char *tag, ns1__getTask **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getTask **)soap_malloc(soap, sizeof(ns1__getTask *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getTask *)soap_instantiate_ns1__getTask(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getTask ** p = (ns1__getTask **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getTask, sizeof(ns1__getTask), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getTask(struct soap *soap, ns1__getTask *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getTask);
	if (soap_out_PointerTons1__getTask(soap, tag?tag:"ns1:getTask", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getTask ** SOAP_FMAC4 soap_get_PointerTons1__getTask(struct soap *soap, ns1__getTask **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__assignTaskResponse(struct soap *soap, ns1__assignTaskResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__assignTaskResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__assignTaskResponse(struct soap *soap, const char *tag, int id, ns1__assignTaskResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__assignTaskResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__assignTaskResponse ** SOAP_FMAC4 soap_in_PointerTons1__assignTaskResponse(struct soap *soap, const char *tag, ns1__assignTaskResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__assignTaskResponse **)soap_malloc(soap, sizeof(ns1__assignTaskResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__assignTaskResponse *)soap_instantiate_ns1__assignTaskResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__assignTaskResponse ** p = (ns1__assignTaskResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__assignTaskResponse, sizeof(ns1__assignTaskResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__assignTaskResponse(struct soap *soap, ns1__assignTaskResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__assignTaskResponse);
	if (soap_out_PointerTons1__assignTaskResponse(soap, tag?tag:"ns1:assignTaskResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__assignTaskResponse ** SOAP_FMAC4 soap_get_PointerTons1__assignTaskResponse(struct soap *soap, ns1__assignTaskResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__assignTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__assignTask(struct soap *soap, ns1__assignTask *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__assignTask))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__assignTask(struct soap *soap, const char *tag, int id, ns1__assignTask *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__assignTask);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__assignTask ** SOAP_FMAC4 soap_in_PointerTons1__assignTask(struct soap *soap, const char *tag, ns1__assignTask **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__assignTask **)soap_malloc(soap, sizeof(ns1__assignTask *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__assignTask *)soap_instantiate_ns1__assignTask(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__assignTask ** p = (ns1__assignTask **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__assignTask, sizeof(ns1__assignTask), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__assignTask(struct soap *soap, ns1__assignTask *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__assignTask);
	if (soap_out_PointerTons1__assignTask(soap, tag?tag:"ns1:assignTask", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__assignTask ** SOAP_FMAC4 soap_get_PointerTons1__assignTask(struct soap *soap, ns1__assignTask **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__assignTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProcessTasksResponse(struct soap *soap, ns1__getProcessTasksResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getProcessTasksResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProcessTasksResponse(struct soap *soap, const char *tag, int id, ns1__getProcessTasksResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getProcessTasksResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProcessTasksResponse ** SOAP_FMAC4 soap_in_PointerTons1__getProcessTasksResponse(struct soap *soap, const char *tag, ns1__getProcessTasksResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getProcessTasksResponse **)soap_malloc(soap, sizeof(ns1__getProcessTasksResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getProcessTasksResponse *)soap_instantiate_ns1__getProcessTasksResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getProcessTasksResponse ** p = (ns1__getProcessTasksResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessTasksResponse, sizeof(ns1__getProcessTasksResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProcessTasksResponse(struct soap *soap, ns1__getProcessTasksResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getProcessTasksResponse);
	if (soap_out_PointerTons1__getProcessTasksResponse(soap, tag?tag:"ns1:getProcessTasksResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProcessTasksResponse ** SOAP_FMAC4 soap_get_PointerTons1__getProcessTasksResponse(struct soap *soap, ns1__getProcessTasksResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getProcessTasksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getProcessTasks(struct soap *soap, ns1__getProcessTasks *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getProcessTasks))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getProcessTasks(struct soap *soap, const char *tag, int id, ns1__getProcessTasks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getProcessTasks);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getProcessTasks ** SOAP_FMAC4 soap_in_PointerTons1__getProcessTasks(struct soap *soap, const char *tag, ns1__getProcessTasks **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getProcessTasks **)soap_malloc(soap, sizeof(ns1__getProcessTasks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getProcessTasks *)soap_instantiate_ns1__getProcessTasks(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getProcessTasks ** p = (ns1__getProcessTasks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessTasks, sizeof(ns1__getProcessTasks), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getProcessTasks(struct soap *soap, ns1__getProcessTasks *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getProcessTasks);
	if (soap_out_PointerTons1__getProcessTasks(soap, tag?tag:"ns1:getProcessTasks", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getProcessTasks ** SOAP_FMAC4 soap_get_PointerTons1__getProcessTasks(struct soap *soap, ns1__getProcessTasks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getProcessTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__completeTaskWSResponse(struct soap *soap, ns1__completeTaskWSResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__completeTaskWSResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__completeTaskWSResponse(struct soap *soap, const char *tag, int id, ns1__completeTaskWSResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__completeTaskWSResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__completeTaskWSResponse ** SOAP_FMAC4 soap_in_PointerTons1__completeTaskWSResponse(struct soap *soap, const char *tag, ns1__completeTaskWSResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__completeTaskWSResponse **)soap_malloc(soap, sizeof(ns1__completeTaskWSResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__completeTaskWSResponse *)soap_instantiate_ns1__completeTaskWSResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__completeTaskWSResponse ** p = (ns1__completeTaskWSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__completeTaskWSResponse, sizeof(ns1__completeTaskWSResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__completeTaskWSResponse(struct soap *soap, ns1__completeTaskWSResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__completeTaskWSResponse);
	if (soap_out_PointerTons1__completeTaskWSResponse(soap, tag?tag:"ns1:completeTaskWSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__completeTaskWSResponse ** SOAP_FMAC4 soap_get_PointerTons1__completeTaskWSResponse(struct soap *soap, ns1__completeTaskWSResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__completeTaskWSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__completeTaskWS(struct soap *soap, ns1__completeTaskWS *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__completeTaskWS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__completeTaskWS(struct soap *soap, const char *tag, int id, ns1__completeTaskWS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__completeTaskWS);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__completeTaskWS ** SOAP_FMAC4 soap_in_PointerTons1__completeTaskWS(struct soap *soap, const char *tag, ns1__completeTaskWS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__completeTaskWS **)soap_malloc(soap, sizeof(ns1__completeTaskWS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__completeTaskWS *)soap_instantiate_ns1__completeTaskWS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__completeTaskWS ** p = (ns1__completeTaskWS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__completeTaskWS, sizeof(ns1__completeTaskWS), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__completeTaskWS(struct soap *soap, ns1__completeTaskWS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__completeTaskWS);
	if (soap_out_PointerTons1__completeTaskWS(soap, tag?tag:"ns1:completeTaskWS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__completeTaskWS ** SOAP_FMAC4 soap_get_PointerTons1__completeTaskWS(struct soap *soap, ns1__completeTaskWS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__completeTaskWS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getTasksResponse(struct soap *soap, ns1__getTasksResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getTasksResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getTasksResponse(struct soap *soap, const char *tag, int id, ns1__getTasksResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getTasksResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getTasksResponse ** SOAP_FMAC4 soap_in_PointerTons1__getTasksResponse(struct soap *soap, const char *tag, ns1__getTasksResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getTasksResponse **)soap_malloc(soap, sizeof(ns1__getTasksResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getTasksResponse *)soap_instantiate_ns1__getTasksResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getTasksResponse ** p = (ns1__getTasksResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getTasksResponse, sizeof(ns1__getTasksResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getTasksResponse(struct soap *soap, ns1__getTasksResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getTasksResponse);
	if (soap_out_PointerTons1__getTasksResponse(soap, tag?tag:"ns1:getTasksResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getTasksResponse ** SOAP_FMAC4 soap_get_PointerTons1__getTasksResponse(struct soap *soap, ns1__getTasksResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getTasksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getTasks(struct soap *soap, ns1__getTasks *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getTasks))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getTasks(struct soap *soap, const char *tag, int id, ns1__getTasks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getTasks);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getTasks ** SOAP_FMAC4 soap_in_PointerTons1__getTasks(struct soap *soap, const char *tag, ns1__getTasks **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getTasks **)soap_malloc(soap, sizeof(ns1__getTasks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getTasks *)soap_instantiate_ns1__getTasks(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getTasks ** p = (ns1__getTasks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getTasks, sizeof(ns1__getTasks), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getTasks(struct soap *soap, ns1__getTasks *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getTasks);
	if (soap_out_PointerTons1__getTasks(soap, tag?tag:"ns1:getTasks", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getTasks ** SOAP_FMAC4 soap_get_PointerTons1__getTasks(struct soap *soap, ns1__getTasks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__reassignTasksResponse(struct soap *soap, ns1__reassignTasksResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__reassignTasksResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__reassignTasksResponse(struct soap *soap, const char *tag, int id, ns1__reassignTasksResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__reassignTasksResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__reassignTasksResponse ** SOAP_FMAC4 soap_in_PointerTons1__reassignTasksResponse(struct soap *soap, const char *tag, ns1__reassignTasksResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__reassignTasksResponse **)soap_malloc(soap, sizeof(ns1__reassignTasksResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__reassignTasksResponse *)soap_instantiate_ns1__reassignTasksResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__reassignTasksResponse ** p = (ns1__reassignTasksResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__reassignTasksResponse, sizeof(ns1__reassignTasksResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__reassignTasksResponse(struct soap *soap, ns1__reassignTasksResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__reassignTasksResponse);
	if (soap_out_PointerTons1__reassignTasksResponse(soap, tag?tag:"ns1:reassignTasksResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__reassignTasksResponse ** SOAP_FMAC4 soap_get_PointerTons1__reassignTasksResponse(struct soap *soap, ns1__reassignTasksResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__reassignTasksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__reassignTasks(struct soap *soap, ns1__reassignTasks *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__reassignTasks))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__reassignTasks(struct soap *soap, const char *tag, int id, ns1__reassignTasks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__reassignTasks);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__reassignTasks ** SOAP_FMAC4 soap_in_PointerTons1__reassignTasks(struct soap *soap, const char *tag, ns1__reassignTasks **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__reassignTasks **)soap_malloc(soap, sizeof(ns1__reassignTasks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__reassignTasks *)soap_instantiate_ns1__reassignTasks(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__reassignTasks ** p = (ns1__reassignTasks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__reassignTasks, sizeof(ns1__reassignTasks), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__reassignTasks(struct soap *soap, ns1__reassignTasks *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__reassignTasks);
	if (soap_out_PointerTons1__reassignTasks(soap, tag?tag:"ns1:reassignTasks", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__reassignTasks ** SOAP_FMAC4 soap_get_PointerTons1__reassignTasks(struct soap *soap, ns1__reassignTasks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__reassignTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__reassignTaskResponse(struct soap *soap, ns1__reassignTaskResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__reassignTaskResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__reassignTaskResponse(struct soap *soap, const char *tag, int id, ns1__reassignTaskResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__reassignTaskResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__reassignTaskResponse ** SOAP_FMAC4 soap_in_PointerTons1__reassignTaskResponse(struct soap *soap, const char *tag, ns1__reassignTaskResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__reassignTaskResponse **)soap_malloc(soap, sizeof(ns1__reassignTaskResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__reassignTaskResponse *)soap_instantiate_ns1__reassignTaskResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__reassignTaskResponse ** p = (ns1__reassignTaskResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__reassignTaskResponse, sizeof(ns1__reassignTaskResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__reassignTaskResponse(struct soap *soap, ns1__reassignTaskResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__reassignTaskResponse);
	if (soap_out_PointerTons1__reassignTaskResponse(soap, tag?tag:"ns1:reassignTaskResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__reassignTaskResponse ** SOAP_FMAC4 soap_get_PointerTons1__reassignTaskResponse(struct soap *soap, ns1__reassignTaskResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__reassignTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__reassignTask(struct soap *soap, ns1__reassignTask *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__reassignTask))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__reassignTask(struct soap *soap, const char *tag, int id, ns1__reassignTask *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__reassignTask);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__reassignTask ** SOAP_FMAC4 soap_in_PointerTons1__reassignTask(struct soap *soap, const char *tag, ns1__reassignTask **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__reassignTask **)soap_malloc(soap, sizeof(ns1__reassignTask *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__reassignTask *)soap_instantiate_ns1__reassignTask(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__reassignTask ** p = (ns1__reassignTask **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__reassignTask, sizeof(ns1__reassignTask), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__reassignTask(struct soap *soap, ns1__reassignTask *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__reassignTask);
	if (soap_out_PointerTons1__reassignTask(soap, tag?tag:"ns1:reassignTask", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__reassignTask ** SOAP_FMAC4 soap_get_PointerTons1__reassignTask(struct soap *soap, ns1__reassignTask **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__reassignTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__markTaskOpenedResponse(struct soap *soap, ns1__markTaskOpenedResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__markTaskOpenedResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__markTaskOpenedResponse(struct soap *soap, const char *tag, int id, ns1__markTaskOpenedResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__markTaskOpenedResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__markTaskOpenedResponse ** SOAP_FMAC4 soap_in_PointerTons1__markTaskOpenedResponse(struct soap *soap, const char *tag, ns1__markTaskOpenedResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__markTaskOpenedResponse **)soap_malloc(soap, sizeof(ns1__markTaskOpenedResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__markTaskOpenedResponse *)soap_instantiate_ns1__markTaskOpenedResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__markTaskOpenedResponse ** p = (ns1__markTaskOpenedResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__markTaskOpenedResponse, sizeof(ns1__markTaskOpenedResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__markTaskOpenedResponse(struct soap *soap, ns1__markTaskOpenedResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__markTaskOpenedResponse);
	if (soap_out_PointerTons1__markTaskOpenedResponse(soap, tag?tag:"ns1:markTaskOpenedResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__markTaskOpenedResponse ** SOAP_FMAC4 soap_get_PointerTons1__markTaskOpenedResponse(struct soap *soap, ns1__markTaskOpenedResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__markTaskOpenedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__markTaskOpened(struct soap *soap, ns1__markTaskOpened *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__markTaskOpened))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__markTaskOpened(struct soap *soap, const char *tag, int id, ns1__markTaskOpened *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__markTaskOpened);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__markTaskOpened ** SOAP_FMAC4 soap_in_PointerTons1__markTaskOpened(struct soap *soap, const char *tag, ns1__markTaskOpened **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__markTaskOpened **)soap_malloc(soap, sizeof(ns1__markTaskOpened *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__markTaskOpened *)soap_instantiate_ns1__markTaskOpened(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__markTaskOpened ** p = (ns1__markTaskOpened **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__markTaskOpened, sizeof(ns1__markTaskOpened), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__markTaskOpened(struct soap *soap, ns1__markTaskOpened *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__markTaskOpened);
	if (soap_out_PointerTons1__markTaskOpened(soap, tag?tag:"ns1:markTaskOpened", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__markTaskOpened ** SOAP_FMAC4 soap_get_PointerTons1__markTaskOpened(struct soap *soap, ns1__markTaskOpened **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__markTaskOpened(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getMyTasksResponse(struct soap *soap, ns1__getMyTasksResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getMyTasksResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getMyTasksResponse(struct soap *soap, const char *tag, int id, ns1__getMyTasksResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getMyTasksResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getMyTasksResponse ** SOAP_FMAC4 soap_in_PointerTons1__getMyTasksResponse(struct soap *soap, const char *tag, ns1__getMyTasksResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getMyTasksResponse **)soap_malloc(soap, sizeof(ns1__getMyTasksResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getMyTasksResponse *)soap_instantiate_ns1__getMyTasksResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getMyTasksResponse ** p = (ns1__getMyTasksResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getMyTasksResponse, sizeof(ns1__getMyTasksResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getMyTasksResponse(struct soap *soap, ns1__getMyTasksResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getMyTasksResponse);
	if (soap_out_PointerTons1__getMyTasksResponse(soap, tag?tag:"ns1:getMyTasksResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getMyTasksResponse ** SOAP_FMAC4 soap_get_PointerTons1__getMyTasksResponse(struct soap *soap, ns1__getMyTasksResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getMyTasksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getMyTasks(struct soap *soap, ns1__getMyTasks *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getMyTasks))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getMyTasks(struct soap *soap, const char *tag, int id, ns1__getMyTasks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getMyTasks);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getMyTasks ** SOAP_FMAC4 soap_in_PointerTons1__getMyTasks(struct soap *soap, const char *tag, ns1__getMyTasks **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getMyTasks **)soap_malloc(soap, sizeof(ns1__getMyTasks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getMyTasks *)soap_instantiate_ns1__getMyTasks(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getMyTasks ** p = (ns1__getMyTasks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getMyTasks, sizeof(ns1__getMyTasks), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getMyTasks(struct soap *soap, ns1__getMyTasks *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getMyTasks);
	if (soap_out_PointerTons1__getMyTasks(soap, tag?tag:"ns1:getMyTasks", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getMyTasks ** SOAP_FMAC4 soap_get_PointerTons1__getMyTasks(struct soap *soap, ns1__getMyTasks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getMyTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__authenticateByCallerPrincipalResponse(struct soap *soap, ns1__authenticateByCallerPrincipalResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__authenticateByCallerPrincipalResponse(struct soap *soap, const char *tag, int id, ns1__authenticateByCallerPrincipalResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__authenticateByCallerPrincipalResponse ** SOAP_FMAC4 soap_in_PointerTons1__authenticateByCallerPrincipalResponse(struct soap *soap, const char *tag, ns1__authenticateByCallerPrincipalResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__authenticateByCallerPrincipalResponse **)soap_malloc(soap, sizeof(ns1__authenticateByCallerPrincipalResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__authenticateByCallerPrincipalResponse *)soap_instantiate_ns1__authenticateByCallerPrincipalResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__authenticateByCallerPrincipalResponse ** p = (ns1__authenticateByCallerPrincipalResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse, sizeof(ns1__authenticateByCallerPrincipalResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__authenticateByCallerPrincipalResponse(struct soap *soap, ns1__authenticateByCallerPrincipalResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__authenticateByCallerPrincipalResponse);
	if (soap_out_PointerTons1__authenticateByCallerPrincipalResponse(soap, tag?tag:"ns1:authenticateByCallerPrincipalResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__authenticateByCallerPrincipalResponse ** SOAP_FMAC4 soap_get_PointerTons1__authenticateByCallerPrincipalResponse(struct soap *soap, ns1__authenticateByCallerPrincipalResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__authenticateByCallerPrincipalResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__authenticateByCallerPrincipal(struct soap *soap, ns1__authenticateByCallerPrincipal *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__authenticateByCallerPrincipal))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__authenticateByCallerPrincipal(struct soap *soap, const char *tag, int id, ns1__authenticateByCallerPrincipal *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__authenticateByCallerPrincipal);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__authenticateByCallerPrincipal ** SOAP_FMAC4 soap_in_PointerTons1__authenticateByCallerPrincipal(struct soap *soap, const char *tag, ns1__authenticateByCallerPrincipal **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__authenticateByCallerPrincipal **)soap_malloc(soap, sizeof(ns1__authenticateByCallerPrincipal *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__authenticateByCallerPrincipal *)soap_instantiate_ns1__authenticateByCallerPrincipal(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__authenticateByCallerPrincipal ** p = (ns1__authenticateByCallerPrincipal **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByCallerPrincipal, sizeof(ns1__authenticateByCallerPrincipal), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__authenticateByCallerPrincipal(struct soap *soap, ns1__authenticateByCallerPrincipal *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__authenticateByCallerPrincipal);
	if (soap_out_PointerTons1__authenticateByCallerPrincipal(soap, tag?tag:"ns1:authenticateByCallerPrincipal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__authenticateByCallerPrincipal ** SOAP_FMAC4 soap_get_PointerTons1__authenticateByCallerPrincipal(struct soap *soap, ns1__authenticateByCallerPrincipal **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__authenticateByCallerPrincipal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__authenticateByTrustedPrincipalResponse(struct soap *soap, ns1__authenticateByTrustedPrincipalResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__authenticateByTrustedPrincipalResponse(struct soap *soap, const char *tag, int id, ns1__authenticateByTrustedPrincipalResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__authenticateByTrustedPrincipalResponse ** SOAP_FMAC4 soap_in_PointerTons1__authenticateByTrustedPrincipalResponse(struct soap *soap, const char *tag, ns1__authenticateByTrustedPrincipalResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__authenticateByTrustedPrincipalResponse **)soap_malloc(soap, sizeof(ns1__authenticateByTrustedPrincipalResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__authenticateByTrustedPrincipalResponse *)soap_instantiate_ns1__authenticateByTrustedPrincipalResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__authenticateByTrustedPrincipalResponse ** p = (ns1__authenticateByTrustedPrincipalResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse, sizeof(ns1__authenticateByTrustedPrincipalResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__authenticateByTrustedPrincipalResponse(struct soap *soap, ns1__authenticateByTrustedPrincipalResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__authenticateByTrustedPrincipalResponse);
	if (soap_out_PointerTons1__authenticateByTrustedPrincipalResponse(soap, tag?tag:"ns1:authenticateByTrustedPrincipalResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__authenticateByTrustedPrincipalResponse ** SOAP_FMAC4 soap_get_PointerTons1__authenticateByTrustedPrincipalResponse(struct soap *soap, ns1__authenticateByTrustedPrincipalResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__authenticateByTrustedPrincipalResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__authenticateByTrustedPrincipal(struct soap *soap, ns1__authenticateByTrustedPrincipal *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__authenticateByTrustedPrincipal))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__authenticateByTrustedPrincipal(struct soap *soap, const char *tag, int id, ns1__authenticateByTrustedPrincipal *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__authenticateByTrustedPrincipal);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__authenticateByTrustedPrincipal ** SOAP_FMAC4 soap_in_PointerTons1__authenticateByTrustedPrincipal(struct soap *soap, const char *tag, ns1__authenticateByTrustedPrincipal **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__authenticateByTrustedPrincipal **)soap_malloc(soap, sizeof(ns1__authenticateByTrustedPrincipal *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__authenticateByTrustedPrincipal *)soap_instantiate_ns1__authenticateByTrustedPrincipal(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__authenticateByTrustedPrincipal ** p = (ns1__authenticateByTrustedPrincipal **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByTrustedPrincipal, sizeof(ns1__authenticateByTrustedPrincipal), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__authenticateByTrustedPrincipal(struct soap *soap, ns1__authenticateByTrustedPrincipal *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__authenticateByTrustedPrincipal);
	if (soap_out_PointerTons1__authenticateByTrustedPrincipal(soap, tag?tag:"ns1:authenticateByTrustedPrincipal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__authenticateByTrustedPrincipal ** SOAP_FMAC4 soap_get_PointerTons1__authenticateByTrustedPrincipal(struct soap *soap, ns1__authenticateByTrustedPrincipal **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__authenticateByTrustedPrincipal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__authenticateByLoginPasswordResponse(struct soap *soap, ns1__authenticateByLoginPasswordResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__authenticateByLoginPasswordResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__authenticateByLoginPasswordResponse(struct soap *soap, const char *tag, int id, ns1__authenticateByLoginPasswordResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__authenticateByLoginPasswordResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__authenticateByLoginPasswordResponse ** SOAP_FMAC4 soap_in_PointerTons1__authenticateByLoginPasswordResponse(struct soap *soap, const char *tag, ns1__authenticateByLoginPasswordResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__authenticateByLoginPasswordResponse **)soap_malloc(soap, sizeof(ns1__authenticateByLoginPasswordResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__authenticateByLoginPasswordResponse *)soap_instantiate_ns1__authenticateByLoginPasswordResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__authenticateByLoginPasswordResponse ** p = (ns1__authenticateByLoginPasswordResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByLoginPasswordResponse, sizeof(ns1__authenticateByLoginPasswordResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__authenticateByLoginPasswordResponse(struct soap *soap, ns1__authenticateByLoginPasswordResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__authenticateByLoginPasswordResponse);
	if (soap_out_PointerTons1__authenticateByLoginPasswordResponse(soap, tag?tag:"ns1:authenticateByLoginPasswordResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__authenticateByLoginPasswordResponse ** SOAP_FMAC4 soap_get_PointerTons1__authenticateByLoginPasswordResponse(struct soap *soap, ns1__authenticateByLoginPasswordResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__authenticateByLoginPasswordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__authenticateByLoginPassword(struct soap *soap, ns1__authenticateByLoginPassword *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__authenticateByLoginPassword))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__authenticateByLoginPassword(struct soap *soap, const char *tag, int id, ns1__authenticateByLoginPassword *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__authenticateByLoginPassword);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__authenticateByLoginPassword ** SOAP_FMAC4 soap_in_PointerTons1__authenticateByLoginPassword(struct soap *soap, const char *tag, ns1__authenticateByLoginPassword **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__authenticateByLoginPassword **)soap_malloc(soap, sizeof(ns1__authenticateByLoginPassword *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__authenticateByLoginPassword *)soap_instantiate_ns1__authenticateByLoginPassword(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__authenticateByLoginPassword ** p = (ns1__authenticateByLoginPassword **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByLoginPassword, sizeof(ns1__authenticateByLoginPassword), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__authenticateByLoginPassword(struct soap *soap, ns1__authenticateByLoginPassword *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__authenticateByLoginPassword);
	if (soap_out_PointerTons1__authenticateByLoginPassword(soap, tag?tag:"ns1:authenticateByLoginPassword", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__authenticateByLoginPassword ** SOAP_FMAC4 soap_get_PointerTons1__authenticateByLoginPassword(struct soap *soap, ns1__authenticateByLoginPassword **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__authenticateByLoginPassword(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__authenticateByKerberosResponse(struct soap *soap, ns1__authenticateByKerberosResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__authenticateByKerberosResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__authenticateByKerberosResponse(struct soap *soap, const char *tag, int id, ns1__authenticateByKerberosResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__authenticateByKerberosResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__authenticateByKerberosResponse ** SOAP_FMAC4 soap_in_PointerTons1__authenticateByKerberosResponse(struct soap *soap, const char *tag, ns1__authenticateByKerberosResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__authenticateByKerberosResponse **)soap_malloc(soap, sizeof(ns1__authenticateByKerberosResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__authenticateByKerberosResponse *)soap_instantiate_ns1__authenticateByKerberosResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__authenticateByKerberosResponse ** p = (ns1__authenticateByKerberosResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByKerberosResponse, sizeof(ns1__authenticateByKerberosResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__authenticateByKerberosResponse(struct soap *soap, ns1__authenticateByKerberosResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__authenticateByKerberosResponse);
	if (soap_out_PointerTons1__authenticateByKerberosResponse(soap, tag?tag:"ns1:authenticateByKerberosResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__authenticateByKerberosResponse ** SOAP_FMAC4 soap_get_PointerTons1__authenticateByKerberosResponse(struct soap *soap, ns1__authenticateByKerberosResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__authenticateByKerberosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__authenticateByKerberos(struct soap *soap, ns1__authenticateByKerberos *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__authenticateByKerberos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__authenticateByKerberos(struct soap *soap, const char *tag, int id, ns1__authenticateByKerberos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__authenticateByKerberos);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__authenticateByKerberos ** SOAP_FMAC4 soap_in_PointerTons1__authenticateByKerberos(struct soap *soap, const char *tag, ns1__authenticateByKerberos **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__authenticateByKerberos **)soap_malloc(soap, sizeof(ns1__authenticateByKerberos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__authenticateByKerberos *)soap_instantiate_ns1__authenticateByKerberos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__authenticateByKerberos ** p = (ns1__authenticateByKerberos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByKerberos, sizeof(ns1__authenticateByKerberos), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__authenticateByKerberos(struct soap *soap, ns1__authenticateByKerberos *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__authenticateByKerberos);
	if (soap_out_PointerTons1__authenticateByKerberos(soap, tag?tag:"ns1:authenticateByKerberos", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__authenticateByKerberos ** SOAP_FMAC4 soap_get_PointerTons1__authenticateByKerberos(struct soap *soap, ns1__authenticateByKerberos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__authenticateByKerberos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__variable(struct soap *soap, ns1__variable **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__variable))
		soap_serialize_PointerTons1__variable(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__variable(struct soap *soap, const char *tag, int id, ns1__variable **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__variable);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__variable(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__variable *** SOAP_FMAC4 soap_in_PointerToPointerTons1__variable(struct soap *soap, const char *tag, ns1__variable ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__variable ***)soap_malloc(soap, sizeof(ns1__variable **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__variable(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__variable ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__variable, sizeof(ns1__variable *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__variable(struct soap *soap, ns1__variable **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__variable);
	if (soap_out_PointerToPointerTons1__variable(soap, tag?tag:"ns1:variable", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__variable *** SOAP_FMAC4 soap_get_PointerToPointerTons1__variable(struct soap *soap, ns1__variable ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__variable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__variable(struct soap *soap, ns1__variable *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__variable))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__variable(struct soap *soap, const char *tag, int id, ns1__variable *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__variable);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__variable ** SOAP_FMAC4 soap_in_PointerTons1__variable(struct soap *soap, const char *tag, ns1__variable **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__variable **)soap_malloc(soap, sizeof(ns1__variable *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__variable *)soap_instantiate_ns1__variable(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__variable ** p = (ns1__variable **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__variable, sizeof(ns1__variable), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__variable(struct soap *soap, ns1__variable *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__variable);
	if (soap_out_PointerTons1__variable(soap, tag?tag:"ns1:variable", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__variable ** SOAP_FMAC4 soap_get_PointerTons1__variable(struct soap *soap, ns1__variable **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__variable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__userType_attributesMap_entry(struct soap *soap, _ns1__userType_attributesMap_entry *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__userType_attributesMap_entry))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__userType_attributesMap_entry(struct soap *soap, const char *tag, int id, _ns1__userType_attributesMap_entry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__userType_attributesMap_entry);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__userType_attributesMap_entry ** SOAP_FMAC4 soap_in_PointerTo_ns1__userType_attributesMap_entry(struct soap *soap, const char *tag, _ns1__userType_attributesMap_entry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__userType_attributesMap_entry **)soap_malloc(soap, sizeof(_ns1__userType_attributesMap_entry *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__userType_attributesMap_entry *)soap_instantiate__ns1__userType_attributesMap_entry(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__userType_attributesMap_entry ** p = (_ns1__userType_attributesMap_entry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__userType_attributesMap_entry, sizeof(_ns1__userType_attributesMap_entry), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__userType_attributesMap_entry(struct soap *soap, _ns1__userType_attributesMap_entry *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__userType_attributesMap_entry);
	if (soap_out_PointerTo_ns1__userType_attributesMap_entry(soap, tag?tag:"ns1:userType-attributesMap-entry", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__userType_attributesMap_entry ** SOAP_FMAC4 soap_get_PointerTo_ns1__userType_attributesMap_entry(struct soap *soap, _ns1__userType_attributesMap_entry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__userType_attributesMap_entry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__variableDefinition(struct soap *soap, ns1__variableDefinition **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__variableDefinition))
		soap_serialize_PointerTons1__variableDefinition(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__variableDefinition(struct soap *soap, const char *tag, int id, ns1__variableDefinition **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__variableDefinition);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__variableDefinition(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__variableDefinition *** SOAP_FMAC4 soap_in_PointerToPointerTons1__variableDefinition(struct soap *soap, const char *tag, ns1__variableDefinition ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__variableDefinition ***)soap_malloc(soap, sizeof(ns1__variableDefinition **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__variableDefinition(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__variableDefinition ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__variableDefinition, sizeof(ns1__variableDefinition *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__variableDefinition(struct soap *soap, ns1__variableDefinition **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__variableDefinition);
	if (soap_out_PointerToPointerTons1__variableDefinition(soap, tag?tag:"ns1:variableDefinition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__variableDefinition *** SOAP_FMAC4 soap_get_PointerToPointerTons1__variableDefinition(struct soap *soap, ns1__variableDefinition ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__variableDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__variableDefinition(struct soap *soap, ns1__variableDefinition *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__variableDefinition))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__variableDefinition(struct soap *soap, const char *tag, int id, ns1__variableDefinition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__variableDefinition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__variableDefinition ** SOAP_FMAC4 soap_in_PointerTons1__variableDefinition(struct soap *soap, const char *tag, ns1__variableDefinition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__variableDefinition **)soap_malloc(soap, sizeof(ns1__variableDefinition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__variableDefinition *)soap_instantiate_ns1__variableDefinition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__variableDefinition ** p = (ns1__variableDefinition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__variableDefinition, sizeof(ns1__variableDefinition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__variableDefinition(struct soap *soap, ns1__variableDefinition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__variableDefinition);
	if (soap_out_PointerTons1__variableDefinition(soap, tag?tag:"ns1:variableDefinition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__variableDefinition ** SOAP_FMAC4 soap_get_PointerTons1__variableDefinition(struct soap *soap, ns1__variableDefinition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__variableDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyType(struct soap *soap, const char *tag, int id, xsd__anyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_in_PointerToxsd__anyType(struct soap *soap, const char *tag, xsd__anyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__anyType **)soap_malloc(soap, sizeof(xsd__anyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__anyType *)soap_instantiate_xsd__anyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__anyType ** p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary_, sizeof(xsd__base64Binary_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(xsd__boolean), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__dateTime, sizeof(xsd__dateTime), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__int, sizeof(xsd__int), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__long, sizeof(xsd__long), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__string, sizeof(xsd__string), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__classPresentationType_, sizeof(ns1__classPresentationType_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByKerberos, sizeof(ns1__authenticateByKerberos), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByKerberosResponse, sizeof(ns1__authenticateByKerberosResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__user, sizeof(ns1__user), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__identifiable, sizeof(ns1__identifiable), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByLoginPassword, sizeof(ns1__authenticateByLoginPassword), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByLoginPasswordResponse, sizeof(ns1__authenticateByLoginPasswordResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByTrustedPrincipal, sizeof(ns1__authenticateByTrustedPrincipal), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse, sizeof(ns1__authenticateByTrustedPrincipalResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByCallerPrincipal, sizeof(ns1__authenticateByCallerPrincipal), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse, sizeof(ns1__authenticateByCallerPrincipalResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getMyTasks, sizeof(ns1__getMyTasks), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__batchPresentation, sizeof(ns1__batchPresentation), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getMyTasksResponse, sizeof(ns1__getMyTasksResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__wfTask, sizeof(ns1__wfTask), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__variableDefinition, sizeof(ns1__variableDefinition), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__userType, sizeof(ns1__userType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__variableFormat, sizeof(ns1__variableFormat), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__markTaskOpened, sizeof(ns1__markTaskOpened), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__markTaskOpenedResponse, sizeof(ns1__markTaskOpenedResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__reassignTask, sizeof(ns1__reassignTask), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__reassignTaskResponse, sizeof(ns1__reassignTaskResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__reassignTasks, sizeof(ns1__reassignTasks), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__reassignTasksResponse, sizeof(ns1__reassignTasksResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getTasks, sizeof(ns1__getTasks), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getTasksResponse, sizeof(ns1__getTasksResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__completeTaskWS, sizeof(ns1__completeTaskWS), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__variable, sizeof(ns1__variable), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__completeTaskWSResponse, sizeof(ns1__completeTaskWSResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessTasks, sizeof(ns1__getProcessTasks), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getProcessTasksResponse, sizeof(ns1__getProcessTasksResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getTask, sizeof(ns1__getTask), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getTaskResponse, sizeof(ns1__getTaskResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__assignTask, sizeof(ns1__assignTask), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__assignTaskResponse, sizeof(ns1__assignTaskResponse), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__wfVariableStub, sizeof(ns2__wfVariableStub), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__identifiableBase, sizeof(ns1__identifiableBase), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__executor, sizeof(ns1__executor), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__actor, sizeof(ns1__actor), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__wfExecutor, sizeof(ns1__wfExecutor), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyType);
	if (soap_out_PointerToxsd__anyType(soap, tag?tag:"xsd:anyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_get_PointerToxsd__anyType(struct soap *soap, xsd__anyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__userType(struct soap *soap, ns1__userType **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__userType))
		soap_serialize_PointerTons1__userType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__userType(struct soap *soap, const char *tag, int id, ns1__userType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__userType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__userType(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__userType *** SOAP_FMAC4 soap_in_PointerToPointerTons1__userType(struct soap *soap, const char *tag, ns1__userType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__userType ***)soap_malloc(soap, sizeof(ns1__userType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__userType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__userType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__userType, sizeof(ns1__userType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__userType(struct soap *soap, ns1__userType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__userType);
	if (soap_out_PointerToPointerTons1__userType(soap, tag?tag:"ns1:userType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__userType *** SOAP_FMAC4 soap_get_PointerToPointerTons1__userType(struct soap *soap, ns1__userType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__userType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__userType(struct soap *soap, ns1__userType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__userType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__userType(struct soap *soap, const char *tag, int id, ns1__userType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__userType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__userType ** SOAP_FMAC4 soap_in_PointerTons1__userType(struct soap *soap, const char *tag, ns1__userType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__userType **)soap_malloc(soap, sizeof(ns1__userType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__userType *)soap_instantiate_ns1__userType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__userType ** p = (ns1__userType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__userType, sizeof(ns1__userType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__userType(struct soap *soap, ns1__userType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__userType);
	if (soap_out_PointerTons1__userType(soap, tag?tag:"ns1:userType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__userType ** SOAP_FMAC4 soap_get_PointerTons1__userType(struct soap *soap, ns1__userType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__userType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons2__wfVariableStub(struct soap *soap, ns2__wfVariableStub **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons2__wfVariableStub))
		soap_serialize_PointerTons2__wfVariableStub(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons2__wfVariableStub(struct soap *soap, const char *tag, int id, ns2__wfVariableStub **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons2__wfVariableStub);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons2__wfVariableStub(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns2__wfVariableStub *** SOAP_FMAC4 soap_in_PointerToPointerTons2__wfVariableStub(struct soap *soap, const char *tag, ns2__wfVariableStub ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__wfVariableStub ***)soap_malloc(soap, sizeof(ns2__wfVariableStub **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons2__wfVariableStub(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns2__wfVariableStub ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons2__wfVariableStub, sizeof(ns2__wfVariableStub *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons2__wfVariableStub(struct soap *soap, ns2__wfVariableStub **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons2__wfVariableStub);
	if (soap_out_PointerToPointerTons2__wfVariableStub(soap, tag?tag:"ns2:wfVariableStub", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__wfVariableStub *** SOAP_FMAC4 soap_get_PointerToPointerTons2__wfVariableStub(struct soap *soap, ns2__wfVariableStub ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons2__wfVariableStub(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__wfVariableStub(struct soap *soap, ns2__wfVariableStub *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__wfVariableStub))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__wfVariableStub(struct soap *soap, const char *tag, int id, ns2__wfVariableStub *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__wfVariableStub);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__wfVariableStub ** SOAP_FMAC4 soap_in_PointerTons2__wfVariableStub(struct soap *soap, const char *tag, ns2__wfVariableStub **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__wfVariableStub **)soap_malloc(soap, sizeof(ns2__wfVariableStub *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__wfVariableStub *)soap_instantiate_ns2__wfVariableStub(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__wfVariableStub ** p = (ns2__wfVariableStub **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__wfVariableStub, sizeof(ns2__wfVariableStub), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__wfVariableStub(struct soap *soap, ns2__wfVariableStub *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__wfVariableStub);
	if (soap_out_PointerTons2__wfVariableStub(soap, tag?tag:"ns2:wfVariableStub", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__wfVariableStub ** SOAP_FMAC4 soap_get_PointerTons2__wfVariableStub(struct soap *soap, ns2__wfVariableStub **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__wfVariableStub(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__wfExecutor(struct soap *soap, ns1__wfExecutor *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__wfExecutor))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__wfExecutor(struct soap *soap, const char *tag, int id, ns1__wfExecutor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__wfExecutor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__wfExecutor ** SOAP_FMAC4 soap_in_PointerTons1__wfExecutor(struct soap *soap, const char *tag, ns1__wfExecutor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__wfExecutor **)soap_malloc(soap, sizeof(ns1__wfExecutor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__wfExecutor *)soap_instantiate_ns1__wfExecutor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__wfExecutor ** p = (ns1__wfExecutor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__wfExecutor, sizeof(ns1__wfExecutor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__wfExecutor(struct soap *soap, ns1__wfExecutor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__wfExecutor);
	if (soap_out_PointerTons1__wfExecutor(soap, tag?tag:"ns1:wfExecutor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__wfExecutor ** SOAP_FMAC4 soap_get_PointerTons1__wfExecutor(struct soap *soap, ns1__wfExecutor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__wfExecutor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__wfTask(struct soap *soap, ns1__wfTask **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__wfTask))
		soap_serialize_PointerTons1__wfTask(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__wfTask(struct soap *soap, const char *tag, int id, ns1__wfTask **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__wfTask);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__wfTask(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__wfTask *** SOAP_FMAC4 soap_in_PointerToPointerTons1__wfTask(struct soap *soap, const char *tag, ns1__wfTask ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__wfTask ***)soap_malloc(soap, sizeof(ns1__wfTask **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__wfTask(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__wfTask ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__wfTask, sizeof(ns1__wfTask *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__wfTask(struct soap *soap, ns1__wfTask **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__wfTask);
	if (soap_out_PointerToPointerTons1__wfTask(soap, tag?tag:"ns1:wfTask", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__wfTask *** SOAP_FMAC4 soap_get_PointerToPointerTons1__wfTask(struct soap *soap, ns1__wfTask ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__wfTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__wfTask(struct soap *soap, ns1__wfTask *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__wfTask))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__wfTask(struct soap *soap, const char *tag, int id, ns1__wfTask *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__wfTask);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__wfTask ** SOAP_FMAC4 soap_in_PointerTons1__wfTask(struct soap *soap, const char *tag, ns1__wfTask **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__wfTask **)soap_malloc(soap, sizeof(ns1__wfTask *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__wfTask *)soap_instantiate_ns1__wfTask(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__wfTask ** p = (ns1__wfTask **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__wfTask, sizeof(ns1__wfTask), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__wfTask(struct soap *soap, ns1__wfTask *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__wfTask);
	if (soap_out_PointerTons1__wfTask(soap, tag?tag:"ns1:wfTask", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__wfTask ** SOAP_FMAC4 soap_get_PointerTons1__wfTask(struct soap *soap, ns1__wfTask **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__wfTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_time);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__classPresentationType(struct soap *soap, enum ns1__classPresentationType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns1__classPresentationType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__classPresentationType(struct soap *soap, const char *tag, int id, enum ns1__classPresentationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__classPresentationType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__classPresentationType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__classPresentationType ** SOAP_FMAC4 soap_in_PointerTons1__classPresentationType(struct soap *soap, const char *tag, enum ns1__classPresentationType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__classPresentationType **)soap_malloc(soap, sizeof(enum ns1__classPresentationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__classPresentationType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__classPresentationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__classPresentationType, sizeof(enum ns1__classPresentationType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__classPresentationType(struct soap *soap, enum ns1__classPresentationType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__classPresentationType);
	if (soap_out_PointerTons1__classPresentationType(soap, tag?tag:"ns1:classPresentationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__classPresentationType ** SOAP_FMAC4 soap_get_PointerTons1__classPresentationType(struct soap *soap, enum ns1__classPresentationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__classPresentationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToLONG64(struct soap *soap, LONG64 *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToLONG64(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_LONG64);
	if (id < 0)
		return soap->error;
	return soap_out_LONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToLONG64(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_LONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_LONG64, sizeof(LONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToLONG64(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToLONG64);
	if (soap_out_PointerToLONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToLONG64(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__batchPresentation(struct soap *soap, ns1__batchPresentation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__batchPresentation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__batchPresentation(struct soap *soap, const char *tag, int id, ns1__batchPresentation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__batchPresentation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__batchPresentation ** SOAP_FMAC4 soap_in_PointerTons1__batchPresentation(struct soap *soap, const char *tag, ns1__batchPresentation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__batchPresentation **)soap_malloc(soap, sizeof(ns1__batchPresentation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__batchPresentation *)soap_instantiate_ns1__batchPresentation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__batchPresentation ** p = (ns1__batchPresentation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__batchPresentation, sizeof(ns1__batchPresentation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__batchPresentation(struct soap *soap, ns1__batchPresentation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__batchPresentation);
	if (soap_out_PointerTons1__batchPresentation(soap, tag?tag:"ns1:batchPresentation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__batchPresentation ** SOAP_FMAC4 soap_get_PointerTons1__batchPresentation(struct soap *soap, ns1__batchPresentation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__batchPresentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__actor(struct soap *soap, ns1__actor *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__actor))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__actor(struct soap *soap, const char *tag, int id, ns1__actor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__actor);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__actor ** SOAP_FMAC4 soap_in_PointerTons1__actor(struct soap *soap, const char *tag, ns1__actor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__actor **)soap_malloc(soap, sizeof(ns1__actor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__actor *)soap_instantiate_ns1__actor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__actor ** p = (ns1__actor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__actor, sizeof(ns1__actor), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__actor(struct soap *soap, ns1__actor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__actor);
	if (soap_out_PointerTons1__actor(soap, tag?tag:"ns1:actor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__actor ** SOAP_FMAC4 soap_get_PointerTons1__actor(struct soap *soap, ns1__actor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__actor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__user(struct soap *soap, ns1__user *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__user))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__user(struct soap *soap, const char *tag, int id, ns1__user *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__user);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__user ** SOAP_FMAC4 soap_in_PointerTons1__user(struct soap *soap, const char *tag, ns1__user **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__user **)soap_malloc(soap, sizeof(ns1__user *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__user *)soap_instantiate_ns1__user(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__user ** p = (ns1__user **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__user, sizeof(ns1__user), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__user(struct soap *soap, ns1__user *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__user);
	if (soap_out_PointerTons1__user(soap, tag?tag:"ns1:user", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__user ** SOAP_FMAC4 soap_get_PointerTons1__user(struct soap *soap, ns1__user **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__user(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__base64Binary **)soap_malloc(soap, sizeof(xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__base64Binary *)soap_instantiate_xsd__base64Binary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__base64Binary ** p = (xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__base64Binary);
	if (soap_out_PointerToxsd__base64Binary(soap, tag?tag:"xsd:base64Binary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstring(struct soap *soap, wchar_t *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_wstring);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstring(struct soap *soap, const char *tag, int id, wchar_t *const*a, const char *type)
{
	return soap_outwstring(soap, tag, id, a, type, SOAP_TYPE_wstring);
}

SOAP_FMAC3 wchar_t * * SOAP_FMAC4 soap_in_wstring(struct soap *soap, const char *tag, wchar_t **a, const char *type)
{	wchar_t **p;
	p = soap_inwstring(soap, tag, a, type, SOAP_TYPE_wstring, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstring(struct soap *soap, wchar_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wstring);
	if (soap_out_wstring(soap, tag?tag:"wchar", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wchar_t ** SOAP_FMAC4 soap_get_wstring(struct soap *soap, wchar_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
